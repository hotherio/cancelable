{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CHANGE-ME","text":""},{"location":"#test","title":"TEST","text":"\\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] <p>The <code>range()</code> function is used to generate a sequence of numbers. bubble_sort.py<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j] # (1)\n</code></pre></p> <ol> <li>:A lot of loops!</li> </ol> <pre><code>theme:\n  features:\n    - content.code.annotate # (1)\n</code></pre> <ol> <li> I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be expressed in Markdown<sup>1</sup>.</li> </ol>"},{"location":"#installation","title":"Installation","text":"WindowsLinux <p>For Windows</p> <p>For Linux</p> Method Description <code>GET</code>      Fetch resource <code>PUT</code>  Update resource <code>DELETE</code>      Delete resource"},{"location":"#test_1","title":"Test","text":"<p><code>mermaid sequenceDiagram   Alice-&gt;&gt;John: Hello John, how are you?   loop Healthcheck       John-&gt;&gt;John: Fight against hypochondria   end   Note right of John: Rational thoughts!   John--&gt;&gt;Alice: Great!   John-&gt;&gt;Bob: How about you?   Bob--&gt;&gt;John: Jolly good!</code></p> <p> </p> Image caption <ol> <li> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.\u00a0\u21a9</p> </li> </ol>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#core-classes","title":"Core Classes","text":""},{"location":"api_reference/#cancellable","title":"Cancellable","text":"<p>The main class for managing cancellable operations.</p> <pre><code>class Cancellable:\n    def __init__(\n        self,\n        operation_id: Optional[str] = None,\n        name: Optional[str] = None,\n        parent: Optional['Cancellable'] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n        register_globally: bool = False,\n    )\n</code></pre>"},{"location":"api_reference/#factory-methods","title":"Factory Methods","text":""},{"location":"api_reference/#with_timeout","title":"with_timeout","text":"<p><pre><code>@classmethod\ndef with_timeout(\n    cls,\n    timeout: Union[float, timedelta],\n    operation_id: Optional[str] = None,\n    name: Optional[str] = None,\n    **kwargs\n) -&gt; 'Cancellable'\n</code></pre> Create a cancellable that times out after the specified duration.</p>"},{"location":"api_reference/#with_token","title":"with_token","text":"<p><pre><code>@classmethod\ndef with_token(\n    cls,\n    token: CancellationToken,\n    operation_id: Optional[str] = None,\n    name: Optional[str] = None,\n    **kwargs\n) -&gt; 'Cancellable'\n</code></pre> Create a cancellable controlled by a cancellation token.</p>"},{"location":"api_reference/#with_signal","title":"with_signal","text":"<p><pre><code>@classmethod\ndef with_signal(\n    cls,\n    *signals: int,\n    operation_id: Optional[str] = None,\n    name: Optional[str] = None,\n    **kwargs\n) -&gt; 'Cancellable'\n</code></pre> Create a cancellable that responds to OS signals.</p>"},{"location":"api_reference/#with_condition","title":"with_condition","text":"<p><pre><code>@classmethod\ndef with_condition(\n    cls,\n    condition: Callable[[], Union[bool, Awaitable[bool]]],\n    check_interval: float = 0.1,\n    condition_name: Optional[str] = None,\n    operation_id: Optional[str] = None,\n    name: Optional[str] = None,\n    **kwargs\n) -&gt; 'Cancellable'\n</code></pre> Create a cancellable that monitors a condition.</p>"},{"location":"api_reference/#methods","title":"Methods","text":""},{"location":"api_reference/#combine","title":"combine","text":"<p><pre><code>def combine(self, *others: 'Cancellable') -&gt; 'Cancellable'\n</code></pre> Combine multiple cancellables into one.</p>"},{"location":"api_reference/#stream","title":"stream","text":"<p><pre><code>async def stream(\n    self,\n    async_iter: AsyncIterator[T],\n    report_interval: Optional[int] = None,\n    buffer_partial: bool = True,\n) -&gt; AsyncIterator[T]\n</code></pre> Wrap an async iterator with cancellation support.</p>"},{"location":"api_reference/#shield","title":"shield","text":"<p><pre><code>@asynccontextmanager\nasync def shield(self) -&gt; AsyncIterator['Cancellable']\n</code></pre> Create a shielded context that won't be cancelled.</p>"},{"location":"api_reference/#cancel","title":"cancel","text":"<p><pre><code>async def cancel(\n    self,\n    reason: CancellationReason = CancellationReason.MANUAL,\n    message: Optional[str] = None,\n    propagate_to_children: bool = True,\n) -&gt; None\n</code></pre> Cancel the operation.</p>"},{"location":"api_reference/#callbacks","title":"Callbacks","text":"<ul> <li><code>on_progress(callback)</code>: Register progress callback</li> <li><code>on_start(callback)</code>: Register start callback</li> <li><code>on_complete(callback)</code>: Register completion callback</li> <li><code>on_cancel(callback)</code>: Register cancellation callback</li> <li><code>on_error(callback)</code>: Register error callback</li> </ul>"},{"location":"api_reference/#cancellationtoken","title":"CancellationToken","text":"<p>Thread-safe token for manual cancellation.</p> <pre><code>class CancellationToken:\n    async def cancel(\n        self,\n        reason: CancellationReason = CancellationReason.MANUAL,\n        message: Optional[str] = None,\n    ) -&gt; bool\n\n    async def wait_for_cancel(self) -&gt; None\n\n    def check(self) -&gt; None  # Raises if cancelled\n\n    async def check_async(self) -&gt; None  # Async version\n\n    def is_cancellation_requested(self) -&gt; bool\n</code></pre>"},{"location":"api_reference/#operationregistry","title":"OperationRegistry","text":"<p>Global registry for operation management.</p> <pre><code>class OperationRegistry:\n    @classmethod\n    def get_instance(cls) -&gt; 'OperationRegistry'\n\n    async def register(self, operation: Cancellable) -&gt; None\n\n    async def get_operation(self, operation_id: str) -&gt; Optional[Cancellable]\n\n    async def list_operations(\n        self,\n        status: Optional[OperationStatus] = None,\n        parent_id: Optional[str] = None,\n        name_pattern: Optional[str] = None,\n    ) -&gt; List[OperationContext]\n\n    async def cancel_operation(\n        self,\n        operation_id: str,\n        reason: CancellationReason = CancellationReason.MANUAL,\n        message: Optional[str] = None,\n    ) -&gt; bool\n</code></pre>"},{"location":"api_reference/#enums","title":"Enums","text":""},{"location":"api_reference/#operationstatus","title":"OperationStatus","text":"<ul> <li><code>PENDING</code>: Operation created but not started</li> <li><code>RUNNING</code>: Operation is currently executing</li> <li><code>COMPLETED</code>: Operation completed successfully</li> <li><code>CANCELLED</code>: Operation was cancelled</li> <li><code>FAILED</code>: Operation failed with error</li> <li><code>TIMEOUT</code>: Operation timed out</li> <li><code>SHIELDED</code>: Operation is in shielded section</li> </ul>"},{"location":"api_reference/#cancellationreason","title":"CancellationReason","text":"<ul> <li><code>TIMEOUT</code>: Cancelled due to timeout</li> <li><code>MANUAL</code>: Cancelled manually via token or API</li> <li><code>SIGNAL</code>: Cancelled by OS signal</li> <li><code>CONDITION</code>: Cancelled by condition check</li> <li><code>PARENT</code>: Cancelled because parent was cancelled</li> <li><code>ERROR</code>: Cancelled due to error</li> </ul>"},{"location":"api_reference/#decorators","title":"Decorators","text":""},{"location":"api_reference/#cancellable_1","title":"@cancellable","text":"<p><pre><code>@cancellable(\n    timeout: Optional[Union[float, timedelta]] = None,\n    operation_id: Optional[str] = None,\n    name: Optional[str] = None,\n    register_globally: bool = False,\n    inject_param: Optional[str] = \"cancellable\",\n)\n</code></pre> Decorator to make async functions cancellable.</p>"},{"location":"api_reference/#cancellable_method","title":"@cancellable_method","text":"<p><pre><code>@cancellable_method(\n    timeout: Optional[Union[float, timedelta]] = None,\n    name: Optional[str] = None,\n    register_globally: bool = False,\n)\n</code></pre> Decorator for async methods (automatically includes class name).</p>"},{"location":"api_reference/#utility-functions","title":"Utility Functions","text":""},{"location":"api_reference/#with_timeout_1","title":"with_timeout","text":"<p><pre><code>async def with_timeout(\n    timeout: Union[float, timedelta],\n    coro: Awaitable[T],\n    operation_id: Optional[str] = None,\n    name: Optional[str] = None,\n) -&gt; T\n</code></pre> Run a coroutine with timeout.</p>"},{"location":"api_reference/#cancellable_stream","title":"cancellable_stream","text":"<p><pre><code>async def cancellable_stream(\n    stream: AsyncIterator[T],\n    timeout: Optional[Union[float, timedelta]] = None,\n    token: Optional[CancellationToken] = None,\n    report_interval: Optional[int] = None,\n    on_progress: Optional[Callable[[int, T], Any]] = None,\n    buffer_partial: bool = False,\n    operation_id: Optional[str] = None,\n    name: Optional[str] = None,\n) -&gt; AsyncIterator[T]\n</code></pre> Make any async iterator cancellable.</p>"},{"location":"api_reference/#exceptions","title":"Exceptions","text":"<ul> <li><code>CancellationError</code>: Base exception for cancellation</li> <li><code>TimeoutCancellation</code>: Operation timed out</li> <li><code>ManualCancellation</code>: Operation cancelled manually</li> <li><code>SignalCancellation</code>: Operation cancelled by signal</li> <li><code>ConditionCancellation</code>: Operation cancelled by condition</li> <li><code>ParentCancellation</code>: Operation cancelled by parent</li> </ul>"},{"location":"getting_started/","title":"Getting Started with Async Cancellation","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>The async cancellation system is part of the Forge framework. Ensure you have the required dependencies:</p> <pre><code>uv pip install anyio asyncer structlog pydantic httpx\n</code></pre>"},{"location":"getting_started/#basic-concepts","title":"Basic Concepts","text":""},{"location":"getting_started/#cancellable-operations","title":"Cancellable Operations","text":"<p>A <code>Cancellable</code> provides a context for managing async operations that can be cancelled from various sources:</p> <pre><code>from forge.async_cancellation import Cancellable\n\nasync with Cancellable() as cancel:\n    # Your async operation here\n    result = await some_async_operation()\n</code></pre>"},{"location":"getting_started/#cancellation-sources","title":"Cancellation Sources","text":"<p>Operations can be cancelled from multiple sources:</p> <ol> <li>Timeout: Cancel after a specified duration</li> <li>Token: Manual cancellation via a token</li> <li>Signal: OS signal handling (SIGINT, etc.)</li> <li>Condition: Custom condition checking</li> </ol>"},{"location":"getting_started/#quick-examples","title":"Quick Examples","text":""},{"location":"getting_started/#timeout-cancellation","title":"Timeout Cancellation","text":"<pre><code>from forge.async_cancellation import Cancellable\nfrom datetime import timedelta\n\n# Using seconds\nasync with Cancellable.with_timeout(30.0) as cancel:\n    result = await long_running_operation()\n\n# Using timedelta\nasync with Cancellable.with_timeout(timedelta(minutes=5)) as cancel:\n    result = await very_long_operation()\n</code></pre>"},{"location":"getting_started/#manual-cancellation","title":"Manual Cancellation","text":"<pre><code>from forge.async_cancellation import Cancellable, CancellationToken\n\n# Create a token\ntoken = CancellationToken()\n\n# In your async operation\nasync def my_operation():\n    async with Cancellable.with_token(token) as cancel:\n        # This will be cancelled when token.cancel() is called\n        await some_work()\n\n# Cancel from elsewhere\nawait token.cancel()\n</code></pre>"},{"location":"getting_started/#progress-reporting","title":"Progress Reporting","text":"<pre><code>async with Cancellable() as cancel:\n    # Register progress callback\n    cancel.on_progress(lambda op_id, msg, meta: print(f\"Progress: {msg}\"))\n\n    # Report progress during operation\n    await cancel.report_progress(\"Starting operation\")\n\n    for i in range(100):\n        await process_item(i)\n        if i % 10 == 0:\n            await cancel.report_progress(f\"Processed {i} items\", {\"count\": i})\n</code></pre>"},{"location":"getting_started/#stream-processing","title":"Stream Processing","text":"<pre><code>async with Cancellable.with_timeout(60) as cancel:\n    # Process async stream with automatic cancellation\n    async for item in cancel.stream(async_data_source()):\n        await process_item(item)\n</code></pre>"},{"location":"getting_started/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always use context managers: Ensures proper cleanup    <pre><code>async with Cancellable() as cancel:\n    # Your code here\n</code></pre></p> </li> <li> <p>Report progress for long operations: Helps with monitoring    <pre><code>await cancel.report_progress(\"Processing batch\", {\"size\": len(batch)})\n</code></pre></p> </li> <li> <p>Handle cancellation gracefully: Save partial results    <pre><code>try:\n    async with Cancellable.with_timeout(30) as cancel:\n        result = await process_all()\nexcept Exception:\n    # Save partial results from cancel.context.partial_result\n    pass\n</code></pre></p> </li> <li> <p>Use appropriate cancellation sources: Choose based on your needs</p> </li> <li>Timeout: For operations with known maximum duration</li> <li>Token: For user-initiated cancellation</li> <li>Signal: For system-level interruption</li> <li>Condition: For resource-based cancellation</li> </ol>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>Read the API Reference for detailed documentation</li> <li>Check out Common Patterns for advanced usage</li> <li>See the <code>examples/</code> directory for complete examples</li> </ul>"},{"location":"migrating_guide/","title":"Migration Guide","text":""},{"location":"migrating_guide/#migrating-from-asynciotimeout","title":"Migrating from asyncio.timeout","text":"<p>If you're currently using <code>asyncio.timeout</code> (Python 3.11+):</p>"},{"location":"migrating_guide/#before","title":"Before:","text":"<pre><code>import asyncio\n\nasync with asyncio.timeout(30):\n    result = await long_operation()\n</code></pre>"},{"location":"migrating_guide/#after","title":"After:","text":"<pre><code>from forge.async_cancellation import Cancellable\n\nasync with Cancellable.with_timeout(30) as cancel:\n    result = await long_operation()\n</code></pre>"},{"location":"migrating_guide/#benefits","title":"Benefits:","text":"<ul> <li>Progress reporting</li> <li>Multiple cancellation sources</li> <li>Better error handling</li> <li>Operation tracking</li> </ul>"},{"location":"migrating_guide/#migrating-from-anyiocancelscope","title":"Migrating from anyio.CancelScope","text":"<p>If you're using anyio's cancel scopes directly:</p>"},{"location":"migrating_guide/#before_1","title":"Before:","text":"<pre><code>import anyio\n\nwith anyio.CancelScope() as scope:\n    scope.deadline = anyio.current_time() + 30\n    await operation()\n</code></pre>"},{"location":"migrating_guide/#after_1","title":"After:","text":"<pre><code>from forge.async_cancellation import Cancellable\n\nasync with Cancellable.with_timeout(30) as cancel:\n    await operation()\n</code></pre>"},{"location":"migrating_guide/#benefits_1","title":"Benefits:","text":"<ul> <li>Higher-level API</li> <li>Built-in progress tracking</li> <li>Automatic cleanup</li> <li>Integration with other libraries</li> </ul>"},{"location":"migrating_guide/#migrating-manual-cancellation","title":"Migrating Manual Cancellation","text":"<p>If you have manual cancellation patterns:</p>"},{"location":"migrating_guide/#before_2","title":"Before:","text":"<pre><code>class Worker:\n    def __init__(self):\n        self.should_stop = False\n\n    async def run(self):\n        while not self.should_stop:\n            await self.do_work()\n\n    def stop(self):\n        self.should_stop = True\n</code></pre>"},{"location":"migrating_guide/#after_2","title":"After:","text":"<pre><code>from forge.async_cancellation import CancellationToken\n\nclass Worker:\n    def __init__(self):\n        self.token = CancellationToken()\n\n    async def run(self):\n        while True:\n            await self.token.check_async()\n            await self.do_work()\n\n    async def stop(self):\n        await self.token.cancel()\n</code></pre>"},{"location":"migrating_guide/#benefits_2","title":"Benefits:","text":"<ul> <li>Thread-safe cancellation</li> <li>Proper async/await support</li> <li>Cancellation callbacks</li> <li>Integration with Cancellable</li> </ul>"},{"location":"migrating_guide/#migrating-stream-processing","title":"Migrating Stream Processing","text":"<p>If you have custom stream cancellation:</p>"},{"location":"migrating_guide/#before_3","title":"Before:","text":"<pre><code>async def process_stream(stream):\n    try:\n        async for item in stream:\n            if should_stop():\n                break\n            await process_item(item)\n    except asyncio.CancelledError:\n        # Handle cancellation\n        pass\n</code></pre>"},{"location":"migrating_guide/#after_3","title":"After:","text":"<pre><code>from forge.async_cancellation import Cancellable\n\nasync def process_stream(stream):\n    async with Cancellable() as cancel:\n        async for item in cancel.stream(stream):\n            await process_item(item)\n</code></pre>"},{"location":"migrating_guide/#benefits_3","title":"Benefits:","text":"<ul> <li>Automatic cancellation propagation</li> <li>Progress reporting</li> <li>Partial result preservation</li> <li>Clean error handling</li> </ul>"},{"location":"migrating_guide/#adding-to-existing-code","title":"Adding to Existing Code","text":"<p>You can gradually adopt the cancellation system:</p>"},{"location":"migrating_guide/#step-1-add-to-critical-operations","title":"Step 1: Add to Critical Operations","text":"<p>Start with operations that need timeouts:</p> <pre><code># Before\nresult = await critical_operation()\n\n# After\nfrom forge.async_cancellation import with_timeout\nresult = await with_timeout(30.0, critical_operation())\n</code></pre>"},{"location":"migrating_guide/#step-2-add-progress-reporting","title":"Step 2: Add Progress Reporting","text":"<p>Enhance long-running operations:</p> <pre><code>from forge.async_cancellation import cancellable\n\n@cancellable(timeout=300)\nasync def process_data(data: list, cancellable=None):\n    for i, item in enumerate(data):\n        await process_item(item)\n        if i % 100 == 0:\n            await cancellable.report_progress(f\"Processed {i} items\")\n</code></pre>"},{"location":"migrating_guide/#step-3-integrate-with-your-framework","title":"Step 3: Integrate with Your Framework","text":"<p>For web applications:</p> <pre><code># FastAPI example\nfrom forge.async_cancellation.integrations.fastapi import cancellable_dependency\n\n@app.post(\"/process\")\nasync def process_endpoint(\n    data: List[str],\n    cancel: Cancellable = Depends(cancellable_dependency)\n):\n    async with cancel:\n        return await process_data(data)\n</code></pre>"},{"location":"migrating_guide/#common-gotchas","title":"Common Gotchas","text":""},{"location":"migrating_guide/#1-context-manager-scope","title":"1. Context Manager Scope","text":"<p>Remember that cancellation is scoped to the context manager:</p> <pre><code># \u274c Wrong: cancellable out of scope\ncancel = Cancellable()\nawait operation()  # Not cancellable!\n\n# \u2705 Correct: use context manager\nasync with Cancellable() as cancel:\n    await operation()  # Cancellable\n</code></pre>"},{"location":"migrating_guide/#2-shielding-side-effects","title":"2. Shielding Side Effects","text":"<p>Be careful with shielding:</p> <pre><code># \u274c Wrong: entire operation shielded\nasync with cancel.shield():\n    await long_operation()  # Won't be cancelled!\n\n# \u2705 Correct: shield only critical parts\nawait long_operation()\nasync with cancel.shield():\n    await critical_cleanup()  # Protected from cancellation\n</code></pre>"},{"location":"migrating_guide/#3-token-lifecycle","title":"3. Token Lifecycle","text":"<p>Tokens can be reused but not reset:</p> <pre><code>token = CancellationToken()\n\n# First use\nasync with Cancellable.with_token(token):\n    await operation1()\n\n# Token can be cancelled later\nawait token.cancel()\n\n# \u274c Wrong: token is already cancelled\nasync with Cancellable.with_token(token):\n    await operation2()  # Will be immediately cancelled!\n\n# \u2705 Correct: create new token\nnew_token = CancellationToken()\nasync with Cancellable.with_token(new_token):\n    await operation2()\n</code></pre>"},{"location":"migrating_guide/#performance-considerations","title":"Performance Considerations","text":"<p>The cancellation system adds minimal overhead:</p> <ul> <li>Context manager: ~10-50% overhead vs raw async</li> <li>Cancellation checks: &lt;10\u03bcs per check</li> <li>Stream processing: &lt;100% overhead vs direct iteration</li> </ul> <p>For most applications, this overhead is negligible compared to I/O operations.</p>"},{"location":"migrating_guide/#getting-help","title":"Getting Help","text":"<ul> <li>Check the examples/ directory for complete examples</li> <li>Read the API Reference for detailed documentation</li> <li>Review Common Patterns for best practices</li> </ul>"},{"location":"patterns/","title":"Common Patterns and Best Practices","text":""},{"location":"patterns/#pattern-graceful-shutdown","title":"Pattern: Graceful Shutdown","text":"<p>Handle application shutdown gracefully:</p> <pre><code>import signal\nfrom forge.async_cancellation import Cancellable\n\nasync def main():\n    # Handle SIGINT and SIGTERM\n    async with Cancellable.with_signal(signal.SIGINT, signal.SIGTERM) as cancel:\n        cancel.on_cancel(lambda ctx: print(\"Shutting down gracefully...\"))\n\n        # Your application logic\n        await run_application()\n</code></pre>"},{"location":"patterns/#pattern-resource-cleanup","title":"Pattern: Resource Cleanup","text":"<p>Ensure resources are cleaned up even on cancellation:</p> <pre><code>async def process_with_cleanup():\n    resource = None\n\n    async with Cancellable.with_timeout(30) as cancel:\n        try:\n            # Acquire resource\n            resource = await acquire_resource()\n\n            # Process\n            result = await process(resource)\n\n            return result\n\n        finally:\n            # Shield cleanup from cancellation\n            if resource:\n                async with cancel.shield():\n                    await resource.cleanup()\n</code></pre>"},{"location":"patterns/#pattern-batch-processing-with-progress","title":"Pattern: Batch Processing with Progress","text":"<p>Process data in batches with progress reporting:</p> <pre><code>async def process_large_dataset(data: List[Any], batch_size: int = 100):\n    async with Cancellable(name=\"batch_processing\") as cancel:\n        cancel.on_progress(lambda op_id, msg, meta: logger.info(msg, **meta))\n\n        total = len(data)\n        processed = 0\n\n        for i in range(0, total, batch_size):\n            batch = data[i:i + batch_size]\n\n            # Process batch\n            await process_batch(batch)\n            processed += len(batch)\n\n            # Report progress\n            progress = (processed / total) * 100\n            await cancel.report_progress(\n                f\"Processed {processed}/{total} items\",\n                {\"progress_percent\": progress, \"batch_number\": i // batch_size + 1}\n            )\n</code></pre>"},{"location":"patterns/#pattern-retry-with-cancellation","title":"Pattern: Retry with Cancellation","text":"<p>Implement retry logic with cancellation support:</p> <pre><code>async def retry_with_cancellation(\n    operation: Callable,\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n):\n    async with Cancellable(name=\"retry_operation\") as cancel:\n        last_error = None\n\n        for attempt in range(max_retries):\n            try:\n                # Check cancellation before retry\n                await cancel._token.check_async()\n\n                # Attempt operation\n                result = await operation()\n                return result\n\n            except Exception as e:\n                last_error = e\n\n                if attempt &lt; max_retries - 1:\n                    await cancel.report_progress(\n                        f\"Attempt {attempt + 1} failed, retrying...\",\n                        {\"error\": str(e)}\n                    )\n\n                    # Wait with exponential backoff\n                    await anyio.sleep(delay)\n                    delay *= backoff\n\n        raise last_error\n</code></pre>"},{"location":"patterns/#pattern-concurrent-operations-with-shared-cancellation","title":"Pattern: Concurrent Operations with Shared Cancellation","text":"<p>Run multiple operations with shared cancellation:</p> <pre><code>async def parallel_operations():\n    async with Cancellable(name=\"parallel_work\") as cancel:\n        async def worker(worker_id: int, items: List[Any]):\n            for item in items:\n                # Check cancellation\n                await cancel._token.check_async()\n\n                # Process item\n                await process_item(item)\n\n                # Report progress\n                await cancel.report_progress(\n                    f\"Worker {worker_id} processed item\",\n                    {\"worker_id\": worker_id, \"item\": item}\n                )\n\n        # Split work among workers\n        work_items = split_into_chunks(all_items, worker_count=4)\n\n        # Run workers concurrently\n        async with anyio.create_task_group() as tg:\n            for i, items in enumerate(work_items):\n                tg.start_soon(worker, i, items)\n</code></pre>"},{"location":"patterns/#pattern-hierarchical-cancellation","title":"Pattern: Hierarchical Cancellation","text":"<p>Create operation hierarchies with parent-child relationships:</p> <pre><code>async def hierarchical_operations():\n    async with Cancellable(name=\"parent_operation\") as parent:\n        # Create child operations\n        async def child_operation(child_id: int):\n            child = Cancellable(\n                name=f\"child_{child_id}\",\n                parent=parent\n            )\n\n            async with child:\n                # Child will be cancelled if parent is cancelled\n                await do_child_work()\n\n        # Run children\n        async with anyio.create_task_group() as tg:\n            for i in range(5):\n                tg.start_soon(child_operation, i)\n</code></pre>"},{"location":"patterns/#pattern-conditional-cancellation","title":"Pattern: Conditional Cancellation","text":"<p>Cancel based on system resources:</p> <pre><code>import psutil\n\ndef check_memory_usage():\n    \"\"\"Cancel if memory usage is too high.\"\"\"\n    return psutil.virtual_memory().percent &gt; 90\n\nasync def memory_aware_operation():\n    async with Cancellable.with_condition(\n        check_memory_usage,\n        check_interval=5.0,\n        condition_name=\"memory_check\"\n    ) as cancel:\n        cancel.on_cancel(\n            lambda ctx: logger.warning(\"Operation cancelled due to high memory usage\")\n        )\n\n        await memory_intensive_operation()\n</code></pre>"},{"location":"patterns/#pattern-stream-processing-with-backpressure","title":"Pattern: Stream Processing with Backpressure","text":"<p>Handle backpressure in stream processing:</p> <pre><code>async def process_stream_with_backpressure(source: AsyncIterator[Any]):\n    # Create bounded channel for backpressure\n    send_channel, receive_channel = anyio.create_memory_object_stream(max_buffer_size=100)\n\n    async with Cancellable(name=\"stream_processing\") as cancel:\n        async def producer():\n            async with send_channel:\n                async for item in cancel.stream(source):\n                    try:\n                        # Try to send without blocking\n                        send_channel.send_nowait(item)\n                    except anyio.WouldBlock:\n                        # Handle backpressure\n                        await cancel.report_progress(\n                            \"Backpressure detected, waiting for consumer\"\n                        )\n                        await send_channel.send(item)\n\n        async def consumer():\n            async with receive_channel:\n                async for item in receive_channel:\n                    # Process item\n                    await process_item(item)\n\n        # Run producer and consumer concurrently\n        async with anyio.create_task_group() as tg:\n            tg.start_soon(producer)\n            tg.start_soon(consumer)\n</code></pre>"},{"location":"patterns/#anti-patterns-to-avoid","title":"Anti-Patterns to Avoid","text":""},{"location":"patterns/#dont-forget-to-check-cancellation-in-loops","title":"Don't forget to check cancellation in loops","text":"<p>\u274c Bad: <pre><code>async with Cancellable.with_timeout(10) as cancel:\n    for item in large_list:\n        # This might run forever if list is large\n        await process_item(item)\n</code></pre></p> <p>\u2705 Good: <pre><code>async with Cancellable.with_timeout(10) as cancel:\n    for item in large_list:\n        # Check cancellation in each iteration\n        await cancel._token.check_async()\n        await process_item(item)\n</code></pre></p>"},{"location":"patterns/#dont-ignore-cancellation-in-cleanup","title":"Don't ignore cancellation in cleanup","text":"<p>\u274c Bad: <pre><code>try:\n    async with Cancellable.with_timeout(10) as cancel:\n        result = await operation()\nfinally:\n    # This might not run if cancelled\n    await cleanup()\n</code></pre></p> <p>\u2705 Good: <pre><code>async with Cancellable.with_timeout(10) as cancel:\n    try:\n        result = await operation()\n    finally:\n        # Shield cleanup from cancellation\n        async with cancel.shield():\n            await cleanup()\n</code></pre></p>"},{"location":"patterns/#dont-create-unnecessary-cancellables","title":"Don't create unnecessary cancellables","text":"<p>\u274c Bad: <pre><code># Creating new cancellable for each item\nfor item in items:\n    async with Cancellable() as cancel:\n        await process_item(item)\n</code></pre></p> <p>\u2705 Good: <pre><code># Reuse single cancellable\nasync with Cancellable() as cancel:\n    for item in items:\n        await process_item(item)\n</code></pre></p>"}]}