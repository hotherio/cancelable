{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cancelable","text":""},{"location":"#cancelable","title":"Cancelable","text":"<p>Comprehensive async cancelation for Python - the missing piece for production-grade async operations.</p> <p> </p>"},{"location":"#what-is-cancelable","title":"What is Cancelable?","text":"<p>Cancelable provides streaming cancelation and thread-safe cancelation for async Python. Cancel async streams at any point, bridge between threading and async contexts, and compose multiple cancelation sources (timeout + manual + signals + conditions) with built-in progress tracking and monitoring. It is built on top of anyio and support <code>asyncio</code> backend.</p> uvpip <pre><code>uv add hother-cancelable\n</code></pre> <pre><code>pip install hother-cancelable\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import threading\nimport time\nimport anyio\nfrom hother.cancelable import Cancelable, CancelationToken, cancelable\n\n# Create a cancellation token\ntoken = CancelationToken()\n\n# Cancel from another thread after 5 seconds\ndef monitor_thread():\n    time.sleep(5.0)\n    token.cancel_sync(message=\"Cancelled by monitor\")  # (1)!\n\nthreading.Thread(target=monitor_thread, daemon=True).start()\n\n# Progress tracking callback\ndef on_progress(op_id, message, metadata):\n    progress = metadata.get('progress', 0)\n    print(f\"[Progress] {message} ({progress}%)\")  # (2)!\n\n# Using decorator with multiple conditions\n@cancelable(timeout=10.0, name=\"data_processor\")  # (3)!\nasync def process_data(cancel: Cancelable):\n    # Register progress callback\n    cancel.on_progress(on_progress)\n\n    # Combine timeout with manual token\n    cancel = cancel.combine(Cancelable.with_token(token))  # (4)!\n\n    # Stream processing with cancellation\n    async def data_stream():\n        for i in range(100):\n            await anyio.sleep(0.1)\n            yield {\"id\": i, \"data\": f\"item_{i}\"}\n\n    processed = []\n    async for item in cancel.stream(data_stream(), report_interval=10):  # (5)!\n        # Report progress periodically\n        await cancel.report_progress(\n            f\"Processing item {item['id']}\",\n            {\"progress\": item['id'], \"total\": 100}  # (6)!\n        )\n        processed.append(item)\n\n    return processed\n\n# Run the operation\ntry:\n    result = await process_data()\n    print(f\"Processed {len(result)} items\")\nexcept anyio.get_cancelled_exc_class():\n    print(f\"Cancelled: {token.message}\")  # (7)!\n</code></pre> <ol> <li>Thread-safe cancellation from regular Python threads</li> <li>Progress callback receives messages and metadata</li> <li><code>@cancelable</code> decorator with timeout - auto-injects Cancelable parameter</li> <li>Combine decorator timeout with manual token - cancels on FIRST trigger</li> <li>Stream wrapper with automatic progress reporting every 10 items</li> <li>Manual progress reporting with custom metadata</li> <li>Handle cancellation and access the reason</li> </ol>"},{"location":"#framework-integration","title":"Framework Integration","text":"<p>Seamless integration with popular async frameworks:</p>"},{"location":"#fastapi","title":"FastAPI","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom hother.cancelable.integrations.fastapi import cancelable_dependency\n\napp = FastAPI()\n\n@app.get(\"/process\")\nasync def process_data(cancel: Cancelable = Depends(cancelable_dependency)):\n    async with cancel:  # Auto-cancelled on client disconnect\n        return await heavy_computation()\n</code></pre> <p>Learn more about FastAPI integration \u2192</p>"},{"location":"#tenacity-retry","title":"Tenacity (Retry)","text":"<pre><code>from tenacity import AsyncRetrying, stop_after_attempt\n\nasync with Cancelable.with_timeout(60.0, name=\"fetch\") as cancel:\n    wrapped_fetch = cancel.wrap(fetch_data)  # (1)!\n\n    async for attempt in AsyncRetrying(stop=stop_after_attempt(3)):\n        with attempt:\n            result = await wrapped_fetch(url)  # (2)!\n            return result\n</code></pre> <ol> <li>Wrap function to respect cancellation during retries</li> <li>Retries up to 3 times, but stops immediately if cancelled</li> </ol> <p>Learn more about Tenacity integration \u2192</p>"},{"location":"#common-use-cases","title":"Common Use Cases","text":"Scenario What Cancelable Provides Web APIs Request timeouts + client disconnect + graceful shutdown Data Pipelines Progress tracking + timeout protection + manual stop Background Jobs Dashboard monitoring + multi-condition cancelation Stream Processing Condition-based stopping + buffer management Microservices Cross-service cancelation propagation"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p> Get Started</p> <p>Install Cancelable and learn the basics in 5 minutes</p> <p> Installation</p> </li> <li> <p> Core Concepts</p> <p>Understand cancelation sources, operations, and monitoring</p> <p> Learn Concepts</p> </li> <li> <p> Browse Examples</p> <p>Complete runnable examples for common use cases</p> <p> View Examples</p> </li> <li> <p> API Reference</p> <p>Complete API documentation for all modules</p> <p> API Docs</p> </li> </ul> <p>Built by the Hother team \u2022 GitHub \u2022 PyPI</p>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#advanced-usage","title":"Advanced Usage","text":"<p>In addition to the basic cancelation mechanism, Cancelable offers some features to manage finely the context and monitor progress.</p>"},{"location":"advanced/#operation-context","title":"Operation Context","text":"<p>The cancel context provides state and metadata that can be directly accessed:</p> <pre><code>async with Cancelable.with_timeout(30.0, name=\"task\") as cancel:\n    # Context properties\n    print(f\"ID: {cancel.context.id}\")  # (1)!\n    print(f\"Name: {cancel.context.name}\")\n    print(f\"Status: {cancel.context.status}\")  # (2)!\n    print(f\"Started: {cancel.context.start_time}\")\n\n    await operation()\n\n# After completion\nprint(f\"Reason: {cancel.context.cancel_reason}\")  # (3)!\nprint(f\"Message: {cancel.context.cancel_message}\")\nprint(f\"Elapsed: {cancel.context.elapsed_time}s\")  # (4)!\n</code></pre> <ol> <li>Unique UUID for operation tracking and log correlation</li> <li>Lifecycle: PENDING \u2192 RUNNING \u2192 CANCELLED or COMPLETED</li> <li>Why it cancelled: TIMEOUT, MANUAL, SIGNAL, or CONDITION</li> <li>Performance metrics available after completion</li> </ol>"},{"location":"advanced/#get-current-context-with-current_operation","title":"Get current context with <code>current_operation()</code>","text":"<p>You can access the current <code>Cancelable</code> from anywhere without parameter passing:</p> <pre><code>from hother.cancelable import Cancelable, current_operation\n\nasync def nested_function():\n    \"\"\"No explicit cancel parameter needed.\"\"\"\n    ctx = current_operation()  # (1)!\n    if ctx:\n        await ctx.report_progress(\"Working in nested function\")  # (2)!\n        print(f\"Operation: {ctx.context.name}\")\n\nasync def main():\n    async with Cancelable.with_timeout(30.0, name=\"my_op\") as cancel:\n        await nested_function()  # (3)!\n</code></pre> <ol> <li>Retrieve current <code>Cancelable</code> from context vars - magic!</li> <li>Full access to all features without explicit parameter</li> <li>Clean function signatures - cancelation is implicit</li> </ol> <p>Context Variable Safety</p> <p><code>current_operation()</code> uses <code>contextvars.ContextVar</code>, which is automatically scoped to async contexts. Safe for concurrent operations.</p>"},{"location":"advanced/#hierarchical-operations","title":"Hierarchical Operations","text":"<p>Create parent-child relationships for structured concurrency:</p> <pre><code>async with Cancelable(name=\"parent\") as parent:  # (1)!\n    await parent_setup()\n\n    # Child operations\n    async with Cancelable(name=\"child_1\", parent=parent) as child1:  # (2)!\n        await child1_work()\n\n    async with Cancelable(name=\"child_2\", parent=parent) as child2:\n        await child2_work()\n\n    # (3)!\n</code></pre> <ol> <li>Parent operation defines the outer scope</li> <li>Children link to parent via <code>parent</code> parameter</li> <li>When parent cancels, all children cancel automatically (cascade)</li> </ol> <p>Benefits:</p> <ul> <li>Automatic propagation - Parent cancelation cascades to all children</li> <li>Clean hierarchy - Track operation relationships in registry</li> <li>Monitoring - Visualize operation trees</li> </ul>"},{"location":"advanced/#nested-timeouts","title":"Nested Timeouts","text":"<p>Different timeout requirements for different steps:</p> <pre><code># Outer: 60-second total budget\nasync with Cancelable.with_timeout(60.0, name=\"outer\") as outer:\n\n    # Inner: 10-second timeout for quick step\n    async with Cancelable.with_timeout(10.0, name=\"step1\", parent=outer) as step1:\n        await quick_operation()\n\n    # Inner: 45-second timeout for slow step\n    async with Cancelable.with_timeout(45.0, name=\"step2\", parent=outer) as step2:\n        await long_operation()\n\n    # If outer times out, both steps cancel\n    # If step times out, only that step cancels\n</code></pre>"},{"location":"advanced/#progress-reporting","title":"Progress Reporting","text":"<p>Track and report operation progress with callbacks:</p> <pre><code>async with Cancelable(name=\"processor\") as cancel:\n    # Register progress callback\n    def on_progress(operation_id: str, message: str, metadata: dict):  # (1)!\n        print(f\"[{operation_id}] {message}\")\n        progress_percent = metadata.get('progress', 0)\n        print(f\"Progress: {progress_percent}%\")\n\n    cancel.on_progress(on_progress)  # (2)!\n\n    # Report progress during operation\n    total = len(items)\n    for i, item in enumerate(items):\n        await process_item(item)\n\n        if i % 100 == 0:  # (3)!\n            await cancel.report_progress(  # (4)!\n                f\"Processed {i}/{total} items\",\n                {\n                    \"progress\": (i / total) * 100,\n                    \"current\": i,\n                    \"total\": total\n                }\n            )\n</code></pre> <ol> <li>Callback receives operation ID, human-readable message, and structured metadata</li> <li>Register callback to receive all progress updates</li> <li>Report periodically to avoid performance overhead</li> <li>Include both message and metadata for flexible consumption (UIs, logs, metrics)</li> </ol>"},{"location":"advanced/#multiple-callbacks","title":"Multiple Callbacks","text":"<p>Register different callbacks for different purposes:</p> <pre><code>async with Cancelable(name=\"processor\") as cancel:\n    # UI callback\n    def update_ui(op_id, msg, meta):\n        progress_bar.update(meta.get('progress', 0))\n        status_label.set_text(msg)\n\n    # Logging callback\n    def log_progress(op_id, msg, meta):\n        logger.info(f\"Operation {op_id}: {msg}\", extra=meta)\n\n    # Metrics callback\n    def update_metrics(op_id, msg, meta):\n        metrics.gauge('operation.progress', meta.get('progress', 0))\n\n    # Register all\n    cancel.on_progress(update_ui)\n    cancel.on_progress(log_progress)\n    cancel.on_progress(update_metrics)\n\n    await process_data()\n</code></pre>"},{"location":"advanced/#progress-in-hierarchies","title":"Progress in Hierarchies","text":"<p>Progress reports bubble up through the hierarchy:</p> <pre><code>async with Cancelable(name=\"pipeline\") as pipeline:\n    def pipeline_progress(op_id, msg, meta):\n        print(f\"Pipeline: {msg}\")\n\n    pipeline.on_progress(pipeline_progress)  # (1)!\n\n    async with Cancelable(name=\"step1\", parent=pipeline) as step1:\n        step1.on_progress(lambda oid, m, meta: print(f\"  Step1: {m}\"))\n        await step1.report_progress(\"Starting step 1\")  # (2)!\n        await work()\n\n    async with Cancelable(name=\"step2\", parent=pipeline) as step2:\n        step2.on_progress(lambda oid, m, meta: print(f\"  Step2: {m}\"))\n        await step2.report_progress(\"Starting step 2\")  # (3)!\n        await work()\n</code></pre> <ol> <li>Pipeline callback receives progress from all children</li> <li>Step 1 reports to its own callback and bubbles to pipeline callback</li> <li>Step 2 reports to its own callback and bubbles to pipeline callback</li> </ol>"},{"location":"advanced/#metadata-structure","title":"Metadata Structure","text":"<p>Use consistent metadata structure for better tooling:</p> <pre><code># Standard fields\nmetadata = {\n    \"progress\": 65.5,        # Percentage (0-100)\n    \"current\": 655,          # Current item number\n    \"total\": 1000,           # Total items\n    \"rate\": 12.5,            # Items per second\n    \"eta\": 27.6,             # Estimated seconds remaining\n    \"phase\": \"processing\"    # Current phase name\n}\n\nawait cancel.report_progress(\"Processing batch 7/10\", metadata)\n</code></pre>"},{"location":"advanced/#async-progress-reporting","title":"Async Progress Reporting","text":"<p>Progress reporting is async to allow for async callbacks:</p> <pre><code>async def async_progress_handler(op_id, msg, meta):\n    \"\"\"Callback can be async for database/API updates.\"\"\"\n    await db.update_job_progress(op_id, meta['progress'])\n    await metrics_api.send(op_id, meta)\n\nasync with Cancelable(name=\"job\") as cancel:\n    cancel.on_progress(async_progress_handler)  # (1)!\n    await process_job()\n</code></pre> <ol> <li>Async callbacks are awaited automatically</li> </ol>"},{"location":"advanced/#performance-tips","title":"Performance Tips","text":"<p>\u2705 Do:</p> <ul> <li>Report at milestones (every 100-1000 items)</li> <li>Use lightweight callbacks</li> <li>Include structured metadata for flexibility</li> <li>Report less frequently for high-throughput operations</li> </ul> <p>\u274c Don't:</p> <ul> <li>Report on every iteration (huge overhead)</li> <li>Do expensive work in callbacks (blocks operation)</li> <li>Report more than once per second for UI updates</li> <li>Forget to include context in metadata</li> </ul>"},{"location":"advanced/#example-web-ui-progress","title":"Example: Web UI Progress","text":"<pre><code>from fastapi import WebSocket\n\n@app.websocket(\"/progress/{job_id}\")\nasync def progress_websocket(websocket: WebSocket, job_id: str):\n    await websocket.accept()\n\n    async def send_progress(op_id, msg, meta):\n        \"\"\"Send progress updates to WebSocket client.\"\"\"\n        await websocket.send_json({\n            \"operation_id\": op_id,\n            \"message\": msg,\n            \"metadata\": meta\n        })\n\n    async with Cancelable(name=f\"job_{job_id}\") as cancel:\n        cancel.on_progress(send_progress)\n\n        for i, item in enumerate(items):\n            await process_item(item)\n\n            if i % 10 == 0:  # Update UI every 10 items\n                await cancel.report_progress(\n                    f\"Processing item {i}/{len(items)}\",\n                    {\n                        \"progress\": (i / len(items)) * 100,\n                        \"current\": i,\n                        \"total\": len(items)\n                    }\n                )\n</code></pre>"},{"location":"advanced/#combining-hierarchies-and-progress","title":"Combining Hierarchies and Progress","text":"<p>Use together for comprehensive operation monitoring:</p> <pre><code>async with Cancelable(name=\"workflow\") as workflow:\n    workflow.on_progress(lambda oid, m, meta: logger.info(f\"Workflow: {m}\"))\n\n    async with Cancelable(name=\"stage1\", parent=workflow) as stage1:\n        stage1.on_progress(lambda oid, m, meta: print(f\"  Stage 1: {m}\"))\n\n        for i in range(100):\n            await work()\n            if i % 10 == 0:\n                await stage1.report_progress(\n                    f\"Stage 1: {i}/100\",\n                    {\"progress\": i, \"stage\": \"fetch\"}\n                )\n\n    async with Cancelable(name=\"stage2\", parent=workflow) as stage2:\n        stage2.on_progress(lambda oid, m, meta: print(f\"  Stage 2: {m}\"))\n\n        for i in range(200):\n            await work()\n            if i % 20 == 0:\n                await stage2.report_progress(\n                    f\"Stage 2: {i}/200\",\n                    {\"progress\": i, \"stage\": \"process\"}\n                )\n</code></pre>"},{"location":"advanced/#custom-combining-patterns","title":"Custom Combining Patterns","text":""},{"location":"advanced/#or-vs-and-logic-for-source-combining","title":"OR vs AND Logic for Source Combining","text":"<p>Cancelable supports two ways to combine cancellation sources:</p> Logic When Cancels Use Case Implementation OR (any-of) When ANY source triggers Safety nets, failsafes <code>Cancelable.combine()</code>, <code>CompositeSource</code>, or <code>AnyOfSource</code> AND (all-of) When ALL sources trigger Requirements, conditions <code>AllOfSource</code>"},{"location":"advanced/#and-logic-all-of-require-multiple-conditions","title":"AND Logic (All-Of) - Require Multiple Conditions","text":"<p>Use <code>AllOfSource</code> when ALL conditions must be met before cancelling:</p> <pre><code>from hother.cancelable import Cancelable\nfrom hother.cancelable.sources.composite import AllOfSource\nfrom hother.cancelable.sources.timeout import TimeoutSource\nfrom hother.cancelable.sources.condition import ConditionSource\n\n# Example: Batch job that needs BOTH minimum time AND target count\nitems_processed = 0\nstart_time = time.time()\n\nmin_time_source = TimeoutSource(timeout=60.0)  # (1)!\ntarget_reached_source = ConditionSource(\n    condition=lambda: items_processed &gt;= 1000,  # (2)!\n    check_interval=1.0\n)\n\n# Combine with AND logic\nall_of = AllOfSource([min_time_source, target_reached_source])  # (3)!\n\ncancelable = Cancelable(name=\"batch_job\")\ncancelable.add_source(all_of)\n\nasync with cancelable:\n    for item in items:\n        await process_item(item)\n        items_processed += 1\n        # Continues until BOTH 60s passed AND 1000 items processed\n</code></pre> <ol> <li>First requirement: minimum 60 seconds must pass</li> <li>Second requirement: must process at least 1000 items</li> <li><code>AllOfSource</code> ensures BOTH conditions are met before cancelling</li> </ol>"},{"location":"advanced/#practical-use-cases-for-and-logic","title":"Practical Use Cases for AND Logic","text":""},{"location":"advanced/#1-rate-limited-operations-with-minimum-duration","title":"1. Rate-Limited Operations with Minimum Duration","text":"<pre><code># Process at least 100 items AND respect 30-second minimum\nmin_items = ConditionSource(\n    condition=lambda: processed_count &gt;= 100,\n    check_interval=0.5\n)\nmin_time = TimeoutSource(timeout=30.0)\n\nall_of = AllOfSource([min_items, min_time])\n# Ensures quality (minimum items) AND prevents too-fast completion\n</code></pre>"},{"location":"advanced/#2-resource-ready-and-quota-available","title":"2. Resource-Ready AND Quota-Available","text":"<pre><code># Wait until BOTH disk space available AND API quota refreshed\ndisk_available = ConditionSource(\n    condition=lambda: shutil.disk_usage(\"/\").free &gt; 1_000_000_000,  # 1GB\n    check_interval=5.0\n)\nquota_available = ConditionSource(\n    condition=lambda: api_quota_remaining &gt; 100,\n    check_interval=10.0\n)\n\nall_of = AllOfSource([disk_available, quota_available])\n# Only proceeds when both resources are ready\n</code></pre>"},{"location":"advanced/#3-multi-stage-completion-gates","title":"3. Multi-Stage Completion Gates","text":"<pre><code># All stages must signal completion\nstage1_complete = ConditionSource(condition=lambda: stage1_done, check_interval=1.0)\nstage2_complete = ConditionSource(condition=lambda: stage2_done, check_interval=1.0)\nstage3_complete = ConditionSource(condition=lambda: stage3_done, check_interval=1.0)\n\nall_of = AllOfSource([stage1_complete, stage2_complete, stage3_complete])\n# Pipeline completes only when all stages finish\n</code></pre>"},{"location":"advanced/#thread-safety","title":"Thread Safety","text":"<p><code>AllOfSource</code> is thread-safe using <code>anyio.Lock()</code> for tracking triggered sources:</p> <pre><code>async def _monitor_source(self, source: CancelationSource) -&gt; None:\n    \"\"\"Monitor a single source and check if all have triggered.\"\"\"\n    original_trigger = source.trigger_cancelation\n\n    async def wrapped_trigger(message: str | None = None):\n        async with self._lock:  # Thread-safe\n            self.triggered_sources.add(source)\n\n            # Check if all sources have triggered\n            if len(self.triggered_sources) == len(self.sources):\n                await self.trigger_cancelation(\n                    f\"All {len(self.sources)} sources have triggered\"\n                )\n</code></pre> <p>Safe for concurrent source triggering from multiple tasks or threads.</p>"},{"location":"advanced/#combining-or-and-and-logic","title":"Combining OR and AND Logic","text":"<p>Nest <code>AllOfSource</code> within <code>CompositeSource</code> or <code>AnyOfSource</code> for complex logic:</p> <pre><code>from hother.cancelable import AnyOfSource, AllOfSource\n\n# Complex: (Timeout OR Signal) OR (MinTime AND TargetReached)\nsafety_net = AnyOfSource([  # OR logic (AnyOfSource is an alias for CompositeSource)\n    TimeoutSource(timeout=300.0),  # 5-minute hard timeout\n    SignalSource(signal.SIGTERM),  # Or graceful shutdown\n])\n\ncompletion_requirements = AllOfSource([  # AND logic\n    TimeoutSource(timeout=60.0),  # Minimum 60 seconds\n    ConditionSource(lambda: items &gt;= 1000, 1.0),  # AND 1000 items\n])\n\n# Combine both (OR of two groups)\nfinal = AnyOfSource([safety_net, completion_requirements])\n# Cancels on: hard timeout OR signal OR (minimum time AND target count)\n</code></pre> <p>Semantic Clarity with AnyOfSource</p> <p><code>AnyOfSource</code> is an alias for <code>CompositeSource</code> that makes the intent clearer when contrasting with <code>AllOfSource</code>. Use whichever name makes your code more readable.</p>"},{"location":"advanced/#best-practices","title":"Best Practices","text":"<p>\u2705 Do:</p> <ul> <li>Use AND logic for quality gates (minimum time, minimum items)</li> <li>Use AND logic for resource synchronization (all resources ready)</li> <li>Keep check intervals reasonable (1-10 seconds)</li> <li>Document why all conditions are required</li> </ul> <p>\u274c Don't:</p> <ul> <li>Use AND logic for safety timeouts (use OR instead)</li> <li>Combine too many conditions (&gt; 4-5 gets complex)</li> <li>Use very short check intervals (&lt; 0.1s) on conditions</li> <li>Forget that ALL conditions must eventually trigger (or operation never cancels)</li> </ul>"},{"location":"advanced/#decorators","title":"Decorators","text":"<p>Instead of manually creating <code>Cancelable</code> contexts with <code>async with</code>, decorators:</p> <ul> <li>Simplify code - Reduce boilerplate for common cancelation patterns</li> <li>Inject context - Automatically provide <code>Cancelable</code> instances as parameters</li> <li>Compose sources - Combine multiple cancelation triggers</li> <li>Share contexts - Coordinate cancelation across multiple functions</li> </ul>"},{"location":"advanced/#cancelable-vs-with_cancelable","title":"@cancelable vs @with_cancelable","text":"<p>Two decorator styles for different needs:</p> Feature <code>@cancelable</code> <code>@with_cancelable</code> Context Creation \u2705 Creates new for each call \u274c Uses existing instance Context Management \u2705 Auto <code>async with</code> \u274c Manual <code>async with</code> required Timeout Configuration \u2705 Per decorator params \u274c Pre-configured Context Sharing \u274c Independent per call \u2705 Shared across functions Default Injection \u2705 Yes (<code>inject_param</code>) \u274c No (<code>inject=False</code>) Use Case Individual operations Coordinated workflows <p><code>@cancelable</code> - Independent Contexts</p> <p>Each call gets its own timeout:</p> <pre><code>from hother.cancelable import cancelable\n\n@cancelable(timeout=5.0, name=\"process_item\")  # (1)!\nasync def process_item(item: str, cancelable: Cancelable):\n    await cancelable.report_progress(f\"Processing {item}\")\n    await do_work(item)\n    return f\"Done: {item}\"\n\n# Each call is independent\nawait process_item(\"A\")  # \u2713 Fresh 5s timeout\nawait process_item(\"B\")  # \u2713 Fresh 5s timeout\nawait process_item(\"C\")  # \u2713 Fresh 5s timeout\n# Total time can exceed 5 seconds\n</code></pre> <ol> <li>Decorator creates and manages context automatically</li> </ol> <p><code>@with_cancelable</code> - Shared Context</p> <p>All calls share one timeout:</p> <pre><code>from hother.cancelable import Cancelable, with_cancelable, current_operation\n\n# Create ONE shared context\nbatch_cancel = Cancelable.with_timeout(5.0, name=\"batch\")  # (1)!\n\n@with_cancelable(batch_cancel)  # (2)!\nasync def process_item(item: str):\n    ctx = current_operation()  # (3)!\n    await ctx.report_progress(f\"Processing {item}\")\n    await do_work(item)\n    return f\"Done: {item}\"\n\n# All share the same 5-second budget\nasync with batch_cancel:  # (4)!\n    await process_item(\"A\")\n    await process_item(\"B\")\n    await process_item(\"C\")\n    # Total time for ALL items must be &lt; 5 seconds\n</code></pre> <ol> <li>One cancelable instance shared across multiple functions</li> <li>Decorator wraps function with existing instance</li> <li>Access via <code>current_operation()</code> - no parameter injection by default</li> <li>Manual context entry required with <code>async with</code></li> </ol>"},{"location":"advanced/#all-decorator-variants","title":"All Decorator Variants","text":"<p><code>@cancelable</code> - Basic Timeout</p> <pre><code>@cancelable(timeout=30.0, name=\"fetch_data\")\nasync def fetch_data(url: str, cancelable: Cancelable):\n    return await http_client.get(url)\n</code></pre> <p><code>@cancelable_with_token</code> - Manual Control</p> <pre><code>token = CancelationToken()\n\n@cancelable_with_token(token, name=\"worker\")\nasync def background_worker(data: list, cancelable: Cancelable):\n    for item in data:\n        await process_item(item)\n</code></pre> <p><code>@cancelable_with_signal</code> - Graceful Shutdown</p> <pre><code>@cancelable_with_signal(signal.SIGTERM, signal.SIGINT, name=\"service\")\nasync def long_running_service(cancelable: Cancelable):\n    while True:\n        await process_batch()\n        await anyio.sleep(1)\n</code></pre> <p><code>@cancelable_with_condition</code> - Custom Logic</p> <pre><code>def check_memory():\n    return psutil.virtual_memory().percent &gt; 90\n\n@cancelable_with_condition(check_memory, check_interval=5.0)\nasync def memory_intensive_task(data: list, cancelable: Cancelable):\n    return await process_large_dataset(data)\n</code></pre> <p><code>@cancelable_combine</code> - Multiple Sources</p> <pre><code>@cancelable_combine(\n    Cancelable.with_timeout(300.0),\n    Cancelable.with_token(token),\n    Cancelable.with_signal(signal.SIGTERM),\n    name=\"robust_operation\"\n)\nasync def download_file(url: str, cancelable: Cancelable):\n    return await download(url)\n</code></pre>"},{"location":"advanced/#parameter-injection","title":"Parameter Injection","text":"<p>By default, decorators inject the <code>Cancelable</code> instance as a parameter:</p> <pre><code>@cancelable(timeout=30.0)\nasync def my_function(arg1, arg2, cancelable: Cancelable):  # (1)!\n    await cancelable.report_progress(\"Working...\")\n    return await do_work(arg1, arg2)\n</code></pre> <ol> <li><code>cancelable</code> parameter is automatically injected</li> </ol> <p>Even without injection, it is possible to access the <code>Cancelable</code> via <code>current_operation()</code> instead:</p> <pre><code>from hother.cancelable import cancelable, current_operation\n\n@cancelable(timeout=30.0, inject_param=None)  # (1)!\nasync def clean_signature(arg1, arg2):  # (2)!\n    ctx = current_operation()  # (3)!\n    if ctx:\n        await ctx.report_progress(\"Working...\")\n    return await do_work(arg1, arg2)\n</code></pre> <ol> <li>Set <code>inject_param=None</code> to disable injection</li> <li>Clean function signature without cancelable parameter</li> <li>Access context via <code>current_operation()</code> when needed</li> </ol> <p>You can use a custom parameter name for the injection:</p> <pre><code>@cancelable(timeout=30.0, inject_param=\"cancel\")\nasync def my_function(arg1, cancel=None):  # Uses 'cancel' instead\n    await cancel.report_progress(\"Working...\")\n</code></pre>"},{"location":"advanced/#decision-guide","title":"Decision Guide","text":"<p>Choose <code>@cancelable</code> when:</p> <ul> <li>Each call needs its own independent timeout</li> <li>You want declarative cancelation at function level</li> <li>Functions should be self-contained</li> <li>Example: API endpoints, isolated tasks</li> </ul> <p>Choose <code>@with_cancelable</code> when:</p> <ul> <li>Multiple functions share one timeout/cancelation state</li> <li>You want cleaner function signatures</li> <li>Building coordinated workflows/pipelines</li> <li>Example: Request-scoped operations, batch jobs</li> </ul>"},{"location":"advanced/#additional-decorators","title":"Additional Decorators","text":"<p><code>@cancelable_method</code> - For Class Methods</p> <p>Decorator for class methods with automatic operation naming:</p> <pre><code>from hother.cancelable import cancelable_method\n\nclass DataProcessor:\n    @cancelable_method(timeout=30.0)\n    async def process(self, data, cancelable: Cancelable):\n        # Operation name automatically includes class name\n        # e.g., \"DataProcessor.process\"\n        await cancelable.report_progress(\"Processing...\")\n        return await heavy_computation(data)\n\nprocessor = DataProcessor()\nresult = await processor.process(data)\n# Each instance method call gets its own 30s timeout\n</code></pre> <p>Benefits: - Automatic naming: <code>ClassName.method_name</code> - Works with instance and class methods - Same features as <code>@cancelable</code></p> <p><code>@with_current_operation</code> - Inject Current Context</p> <p>Inject current operation without creating new context:</p> <pre><code>from hother.cancelable.utils.decorators import with_current_operation\n\n@with_current_operation()\nasync def helper_function(data, operation=None):\n    # Gets current operation from context\n    if operation:\n        await operation.report_progress(f\"Processing {data}\")\n    return await work(data)\n\nasync with Cancelable.with_timeout(30.0) as cancel:\n    # helper_function automatically gets current operation\n    result = await helper_function(\"data\")\n</code></pre> <p>Use cases: - Utility functions that need operation context - Avoiding explicit parameter passing - Clean function signatures</p>"},{"location":"advanced/#wrapping-operations","title":"Wrapping Operations","text":"<p>The <code>wrap()</code> method provides automatic cancelation checking for operations, especially useful in retry loops and batch processing where you want clean cancelation semantics without explicit checks.</p>"},{"location":"advanced/#using-wrap","title":"Using <code>wrap()</code>","text":"<p>Wrap a callable to automatically check for cancelation before each execution:</p> <pre><code>async with Cancelable.with_timeout(30.0, name=\"retry_operation\") as cancel:  # (1)!\n    wrapped_fetch = cancel.wrap(fetch_data)  # (2)!\n\n    # Retry loop - checks cancelation before each attempt\n    for attempt in range(3):  # (3)!\n        try:\n            result = await wrapped_fetch(url)\n            break\n        except Exception as e:\n            if attempt &lt; 2:  # Don't sleep on last attempt\n                await anyio.sleep(1)\n</code></pre> <ol> <li>Create cancelable context with timeout</li> <li>Wrap the operation once - returns a callable that checks cancelation</li> <li>Each call automatically checks all cancelation sources before executing</li> </ol> <p>How it works:</p> <ul> <li><code>wrap()</code> returns a new callable that wraps your original function</li> <li>Before each call, it checks if any cancelation source has triggered</li> <li>If cancelled, raises <code>CancelledError</code> immediately</li> <li>If not cancelled, executes your original function normally</li> </ul>"},{"location":"advanced/#using-wrapping-context-manager","title":"Using <code>wrapping()</code> Context Manager","text":"<p>For scoped wrapping operations with cleaner syntax:</p> <pre><code>async with Cancelable.with_timeout(30.0) as cancel:\n    async with cancel.wrapping() as wrap:  # (1)!\n        result = await wrap(operation)  # (2)!\n        another = await wrap(another_operation)\n</code></pre> <ol> <li>Context manager that provides wrapping function in scope</li> <li>Clean scoped access - wrap multiple operations without storing references</li> </ol>"},{"location":"advanced/#when-to-use-wrapping","title":"When to Use Wrapping","text":"<p>Use <code>wrap()</code> for:</p> <ul> <li>Retry loops: Automatic cancelation between retry attempts</li> <li>Batch processing: Check cancelation for each item without manual checks</li> <li>Integration with retry libraries: Works seamlessly with Tenacity, backoff, etc.</li> <li>Long-running loops: Clean cancelation in <code>for</code> or <code>while</code> loops</li> </ul> <p>Example: Batch Processing</p> <pre><code>async with Cancelable.with_timeout(60.0, name=\"batch\") as cancel:\n    wrapped_process = cancel.wrap(process_item)  # (1)!\n\n    for item in large_dataset:  # (2)!\n        # Cancelation checked automatically\n        result = await wrapped_process(item)\n        results.append(result)\n</code></pre> <ol> <li>Wrap once outside the loop</li> <li>Each iteration checks cancelation first - clean early exit on timeout</li> </ol> <p>Example: Retry with Tenacity</p> <pre><code>from tenacity import AsyncRetrying, stop_after_attempt\n\nasync with Cancelable.with_timeout(60.0, name=\"fetch\") as cancel:\n    wrapped_fetch = cancel.wrap(fetch_data)  # (1)!\n\n    async for attempt in AsyncRetrying(stop=stop_after_attempt(3)):  # (2)!\n        with attempt:\n            result = await wrapped_fetch(url)\n            return result\n</code></pre> <ol> <li>Wrap function to respect cancelation during retries</li> <li>Retries up to 3 times, but stops immediately if cancelled (timeout, manual, etc.)</li> </ol>"},{"location":"advanced/#advanced-token-features","title":"Advanced Token Features","text":""},{"location":"advanced/#linkedcancelationtoken","title":"LinkedCancelationToken","text":"<p>Advanced token with chaining and reason propagation:</p> <pre><code>from hother.cancelable import CancelationToken\nfrom hother.cancelable.core.token import LinkedCancelationToken\n\n# Create linked token\nparent_token = CancelationToken()\nchild_token = LinkedCancelationToken()\n\n# Link child to parent - child cancels when parent cancels\nchild_token.link(parent_token)\n\n# Cancel parent - child is automatically cancelled\nawait parent_token.cancel(\"Parent cancelled\")\n\n# Check child - it's cancelled too with reason propagated\nassert child_token.is_cancelled\nprint(child_token.cancel_message)  # \"Linked from parent: Parent cancelled\"\n</code></pre> <p>Use cases: - Building token hierarchies - Propagating cancelation through pipelines - Preserving cancelation reasons across boundaries</p>"},{"location":"advanced/#token-callbacks","title":"Token Callbacks","text":"<p>Register async callbacks triggered on cancelation:</p> <pre><code>token = CancelationToken()\n\n# Register callback\nasync def on_cancel(message: str):\n    print(f\"Cancelled: {message}\")\n    await cleanup_resources()\n    await notify_users()\n\ntoken.register_callback(on_cancel)\n\n# Later: cancel triggers callback\nawait token.cancel(\"Timeout reached\")  # Calls on_cancel(\"Timeout reached\")\n</code></pre> <p>Use cases: - Custom cleanup logic - Notification systems - Logging and metrics - Integration with external systems</p>"},{"location":"advanced/#token-checking-methods","title":"Token Checking Methods","text":"<p>Two different check methods with different exception types:</p> <pre><code>token = CancelationToken()\n\n# check() - raises ManualCancelation (custom exception)\ntry:\n    token.check()\nexcept ManualCancelation as e:\n    print(f\"Cancelled: {e.message}\")\n\n# check_async() - raises anyio.CancelledError (anyio exception)\ntry:\n    await token.check_async()\nexcept anyio.get_cancelled_exc_class():\n    print(\"Cancelled\")\n</code></pre> <p>When to use: - <code>check()</code> - When you want to catch cancelation separately from other async cancelations - <code>check_async()</code> - When you want cancelation to bubble up like normal async cancelation</p>"},{"location":"advanced/#partial-results","title":"Partial Results","text":""},{"location":"advanced/#operationcontextpartial_result","title":"OperationContext.partial_result","text":"<p>Store intermediate results that can be retrieved even if operation is cancelled:</p> <pre><code>async with Cancelable.with_timeout(60.0) as cancel:\n    results = []\n\n    for i, item in enumerate(large_dataset):\n        result = await process_item(item)\n        results.append(result)\n\n        # Store partial results periodically\n        if i % 100 == 0:\n            cancel.context.partial_result = {\n                \"processed\": i,\n                \"results\": results[:],\n                \"progress\": i / len(large_dataset)\n            }\n\n    return results\n\n# If cancelled, retrieve partial results\ntry:\n    final = await process_dataset()\nexcept anyio.get_cancelled_exc_class():\n    # Get what we processed before cancelation\n    partial = cancel.context.partial_result\n    print(f\"Processed {partial['processed']} items before cancel\")\n    return partial['results']\n</code></pre> <p>Use cases: - Long-running batch jobs - Data processing pipelines - Resumable operations - Progress checkpointing</p>"},{"location":"basics/","title":"Basics","text":""},{"location":"basics/#basics","title":"Basics","text":"<p>Cancelable evolves around <code>Cancelable</code> object and the different sources of cancelation. Most other features are convenience or syntactic sugar to enable more pythonic idioms.   In this tutorial, you will learn the essential concepts to start using Cancelable in your async Python applications.</p>"},{"location":"basics/#what-is-cancelable","title":"What is Cancelable?","text":"<p><code>Cancelable</code> is an async context manager that wraps your operations and provides clean, composable cancelation from multiple sources:</p> <ul> <li>Timeouts - Automatic cancelation after a duration</li> <li>Manual tokens - Programmatic cancelation from code or threads</li> <li>OS signals - Graceful shutdown (SIGTERM, SIGINT)</li> <li>Custom conditions - Resource limits, business logic triggers</li> </ul> <p>Think of it as \"structured cancelation\" for async Python - similar to how <code>anyio</code> provides structured concurrency.</p>"},{"location":"basics/#quick-start","title":"Quick Start","text":"<p>The simplest pattern - timeout after 30 seconds:</p> <pre><code>from hother.cancelable import Cancelable\nimport anyio\n\nasync def main():\n    try:\n        async with Cancelable.with_timeout(30.0, name=\"api_call\") as cancel:  # (1)!\n            result = await external_api.fetch_data()\n            return result\n    except anyio.get_cancelled_exc_class():  # (2)!\n        print(\"Operation timed out after 30 seconds\")\n        return None\n\nanyio.run(main)\n</code></pre> <ol> <li>Create a cancelable context with a 30-second timeout - operation cancels automatically if exceeded</li> <li>Handle the cancelation exception using <code>anyio.get_cancelled_exc_class()</code> for backend-agnostic code</li> </ol>"},{"location":"basics/#four-ways-to-trigger-cancelation","title":"Four Ways to Trigger Cancelation","text":""},{"location":"basics/#1-timeout-time-based-cancelation","title":"1. Timeout - Time-Based Cancelation","text":"<p>Automatically cancel after a specific duration:</p> <pre><code>from hother.cancelable import Cancelable\n\nasync with Cancelable.with_timeout(60.0, name=\"batch_job\") as cancel:  # (1)!\n    await process_large_batch()\n</code></pre> <ol> <li>Most common pattern for API calls, database queries, and any operation with an SLA</li> </ol> <p>When to use:</p> <ul> <li>API calls with response time limits</li> <li>Database queries that shouldn't run too long</li> <li>Batch operations with processing windows</li> <li>Any operation that needs a deadline</li> </ul>"},{"location":"basics/#2-manual-token-programmatic-control","title":"2. Manual Token - Programmatic Control","text":"<p>Cancel from anywhere in your code, even from other tasks or threads:</p> <pre><code>from hother.cancelable import Cancelable, CancelationToken\n\n# Create a shared token\ntoken = CancelationToken()  # (1)!\n\nasync def worker():\n    async with Cancelable.with_token(token, name=\"worker\") as cancel:  # (2)!\n        for i in range(1000):\n            await process_item(i)\n            await anyio.sleep(0.1)\n\nasync def controller():\n    \"\"\"Cancel worker after 5 seconds.\"\"\"\n    await anyio.sleep(5)\n    await token.cancel(message=\"Time's up!\")  # (3)!\n\n# Run both concurrently\nasync with anyio.create_task_group() as tg:\n    tg.start_soon(worker)\n    tg.start_soon(controller)\n</code></pre> <ol> <li>Token can be shared across tasks and even threads for coordination</li> <li>Worker operation respects cancelation from the shared token</li> <li>Controller triggers cancelation - worker stops immediately</li> </ol> <p>Thread-safe cancelation:</p> <pre><code>import threading\nimport time\n\ndef sync_canceller():\n    \"\"\"Cancel from a regular Python thread.\"\"\"\n    time.sleep(5)\n    token.cancel_sync(message=\"Cancelled from thread\")  # (1)!\n\nthread = threading.Thread(target=sync_canceller)\nthread.start()\nawait worker()  # Will be cancelled by the thread\nthread.join()\n</code></pre> <ol> <li><code>cancel_sync()</code> is thread-safe - safe to call from any thread</li> </ol> <p>When to use:</p> <ul> <li>User-triggered cancelation (cancel buttons, close dialogs)</li> <li>Cross-task coordination (one task cancels another)</li> <li>API endpoints that stop background jobs</li> <li>Thread-to-async communication</li> </ul>"},{"location":"basics/#3-os-signals-graceful-shutdown","title":"3. OS Signals - Graceful Shutdown","text":"<p>Respond to termination signals for clean application shutdown:</p> <pre><code>import signal\nfrom hother.cancelable import Cancelable\n\nasync def main():\n    async with Cancelable.with_signal(  # (1)!\n        signal.SIGTERM,  # Graceful shutdown\n        signal.SIGINT,   # Ctrl+C\n        name=\"application\"\n    ) as cancel:\n        try:\n            print(\"Running... (Ctrl+C to stop)\")\n            await run_server()\n        finally:\n            # Shield cleanup from cancelation  # (2)!\n            async with cancel.shield():\n                print(\"Shutting down gracefully...\")\n                await cleanup_resources()\n                print(\"Shutdown complete\")\n\nanyio.run(main)\n</code></pre> <ol> <li>Responds to SIGTERM (container orchestrators) and SIGINT (Ctrl+C)</li> <li>Shield ensures cleanup code runs even during cancelation</li> </ol> <p>Platform Compatibility</p> <p>Signal handling works on Unix-like systems (Linux, macOS). Windows only supports <code>SIGINT</code> (Ctrl+C).</p> <p>When to use:</p> <ul> <li>Production services needing graceful shutdown</li> <li>CLI tools responding to Ctrl+C</li> <li>Container/Docker lifecycle management</li> <li>Development servers (quick stop with Ctrl+C)</li> </ul>"},{"location":"basics/#4-custom-conditions-resource-monitoring","title":"4. Custom Conditions - Resource Monitoring","text":"<p>Cancel based on custom logic - disk space, memory usage, business rules:</p> <pre><code>import psutil\nfrom hother.cancelable import Cancelable\n\ndef check_resources():\n    \"\"\"Cancel if memory usage exceeds 90%.\"\"\"  # (1)!\n    return psutil.virtual_memory().percent &gt; 90\n\nasync with Cancelable.with_condition(  # (2)!\n    predicate=check_resources,\n    check_interval=5.0,  # Check every 5 seconds\n    name=\"memory_intensive_task\"\n) as cancel:\n    await process_large_dataset()\n</code></pre> <ol> <li>Custom predicate - returns True when cancelation should occur</li> <li>Checks condition periodically - cancels immediately when True</li> </ol> <p>Performance</p> <p>Set <code>check_interval</code> appropriately: too frequent wastes CPU, too slow delays cancelation.</p> <p>When to use:</p> <ul> <li>Resource monitoring (disk, memory, CPU limits)</li> <li>Business rule triggers (rate limits, quotas exceeded)</li> <li>External state checks (database flags, file existence)</li> <li>Stop flags for user-controlled operations</li> </ul>"},{"location":"basics/#combining-multiple-sources","title":"Combining Multiple Sources","text":"<p>The power of Cancelable comes from composing multiple cancelation triggers. Use <code>Cancelable.combine()</code> to create operations that respond to timeouts, manual cancelation, signals, and custom conditions simultaneously.</p> <p>Key concept: First-wins semantics - the operation cancels as soon as any source triggers.</p> <pre><code>from hother.cancelable import Cancelable, CancelationToken\nimport signal\n\ntoken = CancelationToken()\n\nasync with Cancelable.combine([  # (1)!\n    Cancelable.with_timeout(60.0),               # 60-second timeout\n    Cancelable.with_token(token),                # Manual cancel\n    Cancelable.with_signal(signal.SIGTERM),      # Graceful shutdown\n], name=\"multi_source_operation\") as cancel:\n    await operation()  # (2)!\n</code></pre> <ol> <li><code>combine()</code> accepts a list of Cancelable instances with different sources</li> <li>Cancels immediately when the first source triggers (timeout OR manual OR signal)</li> </ol>"},{"location":"basics/#or-vs-and-logic","title":"OR vs AND Logic","text":"<p>By default, <code>combine()</code> uses OR logic (any-of) - cancels when any source triggers. For AND logic (all-of) where all sources must trigger, use <code>AllOfSource</code>:</p> <p>OR Logic (Default) - Cancel when ANY triggers:</p> <pre><code># Cancels on FIRST trigger (timeout OR manual OR signal)\nasync with Cancelable.combine([\n    Cancelable.with_timeout(60.0),\n    Cancelable.with_token(token),\n    Cancelable.with_signal(signal.SIGTERM),\n]) as cancel:\n    await operation()\n</code></pre> <p>AND Logic - Cancel when ALL trigger:</p> <pre><code>from hother.cancelable import Cancelable\nfrom hother.cancelable.sources.composite import AllOfSource\nfrom hother.cancelable.sources.timeout import TimeoutSource\nfrom hother.cancelable.sources.condition import ConditionSource\n\n# Both conditions must be met\nmin_time = TimeoutSource(timeout=60.0)  # (1)!\ndata_ready = ConditionSource(\n    condition=lambda: is_data_complete(),\n    check_interval=1.0\n)\n\nall_of = AllOfSource([min_time, data_ready])  # (2)!\n\ncancelable = Cancelable(name=\"requires_both\")\ncancelable.add_source(all_of)\n\nasync with cancelable:\n    await process_data()  # (3)!\n</code></pre> <ol> <li>Minimum 60 seconds must pass</li> <li>Wrap sources in <code>AllOfSource</code> for AND logic</li> <li>Only cancels when BOTH timeout reached AND data is complete</li> </ol> <p>When to use each:</p> <ul> <li>OR (any-of): Safety nets - cancel on timeout OR user action OR signal (most common)</li> <li>AND (all-of): Requirements - wait until minimum time AND target reached AND resources available</li> </ul> <p>Advanced: Direct Source Composition</p> <p>For more control, you can use <code>AnyOfSource</code> (for OR logic) and <code>AllOfSource</code> (for AND logic) directly instead of <code>Cancelable.combine()</code>:</p> <pre><code>from hother.cancelable import Cancelable, AnyOfSource\nfrom hother.cancelable.sources import TimeoutSource, SignalSource\n\n# Equivalent to Cancelable.combine() but with explicit control\nany_of = AnyOfSource([\n    TimeoutSource(timeout=60.0),\n    SignalSource(signal.SIGTERM),\n])\n\ncancelable = Cancelable(name=\"my_operation\")\ncancelable.add_source(any_of)\n\nasync with cancelable:\n    await operation()\n</code></pre> <p>This approach is useful when you need to nest sources or create reusable source combinations. <code>AnyOfSource</code> is an alias for <code>CompositeSource</code> that provides semantic clarity when contrasting with <code>AllOfSource</code>. See Advanced Usage for complex nesting examples.</p>"},{"location":"basics/#using-decorators","title":"Using Decorators","text":"<p>For cleaner code, it is possible to use the <code>@cancelable</code> decorator:</p> <pre><code>from hother.cancelable import cancelable\n\n@cancelable(timeout=30.0, name=\"fetch_user\")  # (1)!\nasync def fetch_user(user_id: int, cancelable: Cancelable):  # (2)!\n    \"\"\"Fetch user with automatic 30-second timeout.\"\"\"\n    await cancelable.report_progress(f\"Fetching user {user_id}\")\n    response = await api.get(f\"/users/{user_id}\")\n    return response.json()\n\n# Each call gets its own 30-second timeout\nuser1 = await fetch_user(123)  # (3)!\nuser2 = await fetch_user(456)\n</code></pre> <ol> <li>Decorator creates a new <code>Cancelable</code> context for each function call</li> <li><code>cancelable</code> parameter is auto-injected - access context features</li> <li>No manual <code>async with</code> needed - decorator handles it</li> </ol> <p>See Advanced Usage for all decorator variants.</p>"},{"location":"basics/#error-handling","title":"Error Handling","text":""},{"location":"basics/#catching-cancelation","title":"Catching Cancelation","text":"<pre><code>import anyio\nfrom hother.cancelable import CancelationReason\n\ntry:\n    async with Cancelable.with_timeout(5.0) as cancel:\n        result = await operation()\nexcept anyio.get_cancelled_exc_class() as e:  # (1)!\n    # Access cancel details\n    reason = cancel.context.cancel_reason  # (2)!\n    message = cancel.context.cancel_message\n\n    print(f\"Cancelled: {reason} - {message}\")\n\n    # Handle based on reason\n    if reason == CancelationReason.TIMEOUT:  # (3)!\n        print(\"Operation timed out - maybe retry?\")\n    elif reason == CancelationReason.MANUAL:\n        print(\"User cancelled - don't retry\")\n</code></pre> <ol> <li>Use <code>anyio.get_cancelled_exc_class()</code> for backend compatibility (asyncio, trio)</li> <li>Context provides cancel reason and custom message for detailed error handling</li> <li>Different reasons warrant different responses (retry timeouts, log manual cancels, etc.)</li> </ol>"},{"location":"basics/#cleanup-with-shielding","title":"Cleanup with Shielding","text":"<p>Protect critical cleanup code from cancelation:</p> <pre><code>async with Cancelable.with_timeout(30.0) as cancel:\n    try:\n        await risky_operation()\n    finally:\n        # Shield ensures cleanup runs even if cancelled\n        async with cancel.shield():  # (1)!\n            await save_important_state()\n            await close_connections()\n</code></pre> <ol> <li>Shielded section always completes - cancelation waits until done</li> </ol> <p>Use Shields Sparingly</p> <p>Shields prevent cancelation propagation. Overuse can lead to deadlocks or hung operations.</p>"},{"location":"basics/#wrapping-operations","title":"Wrapping Operations","text":"<p>For retry loops or batch processing, use <code>wrap()</code> to check cancelation automatically:</p> <pre><code>async with Cancelable.with_timeout(30.0) as cancel:\n    wrapped_fetch = cancel.wrap(fetch_data)  # (1)!\n\n    # Retry loop - automatic cancelation checking\n    for attempt in range(3):\n        try:\n            result = await wrapped_fetch(url)  # (2)!\n            break\n        except Exception:\n            await anyio.sleep(1)\n</code></pre> <ol> <li>Wrap the operation once - returns callable that checks cancelation</li> <li>Each call automatically checks if cancelled before executing</li> </ol> <p>See Advanced Usage for complete details on <code>wrap()</code> and <code>wrapping()</code> context manager.</p>"},{"location":"clickup-gpg-signing-correction/","title":"GPG Signing with python-semantic-release","text":""},{"location":"clickup-gpg-signing-correction/#gpg-signing-with-python-semantic-release","title":"GPG Signing with python-semantic-release","text":""},{"location":"clickup-gpg-signing-correction/#overview","title":"Overview","text":"<p>Python-semantic-release supports GPG signing through both Docker action and pip installation approaches. The common misconception that \"Docker can't access GPG\" is incorrect.</p>"},{"location":"clickup-gpg-signing-correction/#how-docker-based-gpg-signing-works","title":"How Docker-Based GPG Signing Works","text":"<p>The <code>crazy-max/ghaction-import-gpg</code> action configures GPG on the GitHub Actions runner (host). The PSR Docker action inherits this configuration automatically through GitHub Actions' standard mounts.</p> <p>No special Docker configuration needed!</p>"},{"location":"clickup-gpg-signing-correction/#workflow-configuration-docker-action","title":"Workflow Configuration (Docker Action)","text":"<pre><code>- name: Import GPG key\n  id: import-gpg\n  uses: crazy-max/ghaction-import-gpg@v6\n  with:\n    gpg_private_key: ${{ secrets.HOTHER_BOT_GPG_KEY }}\n    passphrase: ${{ secrets.HOTHER_BOT_GPG_PASSPHRASE }}\n    git_user_signingkey: true\n    git_commit_gpgsign: true\n    git_tag_gpgsign: true\n\n- name: Configure Git\n  env:\n    GIT_EMAIL: ${{ steps.import-gpg.outputs.email }}\n    GIT_NAME: ${{ steps.import-gpg.outputs.name }}\n  run: |\n    git config user.email \"$GIT_EMAIL\"\n    git config user.name \"$GIT_NAME\"\n    git config commit.gpgsign true\n    git config tag.gpgsign true\n\n- name: Python Semantic Release\n  id: release\n  uses: python-semantic-release/python-semantic-release@v10.5.3\n  with:\n    github_token: ${{ secrets.GITHUB_TOKEN }}\n    git_committer_name: ${{ steps.import-gpg.outputs.name }}\n    git_committer_email: ${{ steps.import-gpg.outputs.email }}\n</code></pre> <p>How it works: 1. GPG key imported to runner's keyring by <code>crazy-max/ghaction-import-gpg</code> 2. Git configured globally on runner 3. PSR Docker action inherits Git config via GitHub Actions mounts 4. Signing works automatically</p>"},{"location":"clickup-gpg-signing-correction/#alternative-pip-installed-psr","title":"Alternative: pip-installed PSR","text":"<p>Both approaches support GPG signing equally well.</p>"},{"location":"clickup-gpg-signing-correction/#when-to-use-docker-action-recommended","title":"When to use Docker action (Recommended)","text":"<ul> <li>\u2705 Standard workflow</li> <li>\u2705 Simpler setup (one step)</li> <li>\u2705 Better caching</li> <li>\u2705 Consistent environment</li> </ul>"},{"location":"clickup-gpg-signing-correction/#when-to-use-pip-install","title":"When to use pip install","text":"<ul> <li>Need specific PSR version not available as Docker action</li> <li>Want to run PSR locally in dev environment</li> <li>Need to customize PSR execution extensively</li> </ul>"},{"location":"clickup-gpg-signing-correction/#pip-installation-example","title":"pip Installation Example","text":"<pre><code>- name: Setup Python\n  uses: actions/setup-python@v4\n  with:\n    python-version: '3.11'\n\n- name: Install PSR\n  run: pip install python-semantic-release\n\n- name: Import GPG key\n  uses: crazy-max/ghaction-import-gpg@v6\n  with:\n    gpg_private_key: ${{ secrets.HOTHER_BOT_GPG_KEY }}\n    passphrase: ${{ secrets.HOTHER_BOT_GPG_PASSPHRASE }}\n    git_user_signingkey: true\n    git_commit_gpgsign: true\n    git_tag_gpgsign: true\n\n- name: Run PSR\n  run: semantic-release version\n  env:\n    GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>Both produce identical results - GPG-signed commits and tags.</p>"},{"location":"clickup-gpg-signing-correction/#common-misconception-docker-cant-access-gpg","title":"Common Misconception: \"Docker can't access GPG\"","text":"<p>False. This misconception arises from: 1. Default Docker isolation (true for standalone Docker) 2. Missing configuration (forgetting to enable signing) 3. Misunderstanding GitHub Actions' mount behavior</p> <p>Reality: GitHub Actions automatically makes host Git configuration available to Docker actions, including GPG setup.</p>"},{"location":"clickup-gpg-signing-correction/#ssh-signing-alternative","title":"SSH Signing Alternative","text":"<p>PSR Docker action also supports SSH signing natively:</p> <pre><code>- name: Python Semantic Release\n  uses: python-semantic-release/python-semantic-release@v10.5.3\n  with:\n    github_token: ${{ secrets.GITHUB_TOKEN }}\n    ssh_private_signing_key: ${{ secrets.SSH_PRIVATE_SIGNING_KEY }}\n    ssh_public_signing_key: ${{ secrets.SSH_PUBLIC_SIGNING_KEY }}\n</code></pre>"},{"location":"clickup-gpg-signing-correction/#comparison-gpg-vs-ssh-vs-unsigned","title":"Comparison: GPG vs SSH vs Unsigned","text":"Feature GPG (Docker) GPG (pip) SSH (Docker native) Unsigned Setup complexity Low Medium Low Lowest Expiration support \u2705 \u2705 \u274c N/A Revocation support \u2705 \u2705 \u274c N/A GitHub verified badge \u2705 \u2705 \u2705 \u274c Docker action support \u2705 N/A \u2705 Native \u2705"},{"location":"clickup-gpg-signing-correction/#troubleshooting","title":"Troubleshooting","text":""},{"location":"clickup-gpg-signing-correction/#commits-not-signed-with-docker-action","title":"\"Commits not signed\" with Docker action","text":"<p>Check: 1. <code>git_commit_gpgsign: true</code> in import-gpg action 2. <code>git config commit.gpgsign true</code> in workflow 3. Secrets configured: <code>HOTHER_BOT_GPG_KEY</code>, <code>HOTHER_BOT_GPG_PASSPHRASE</code></p> <p>Verify in workflow logs: </p><pre><code>git config --global --get commit.gpgsign  # Should be: true\ngit config --global --get user.signingkey # Should show key ID\n</code></pre><p></p>"},{"location":"clickup-gpg-signing-correction/#gpg-cannot-run-gpg-no-such-file-or-directory","title":"\"gpg: cannot run gpg: No such file or directory\"","text":"<p>Cause: Git config not properly set before PSR runs</p> <p>Solution: Ensure <code>Configure Git</code> step runs before PSR step and has: </p><pre><code>git config commit.gpgsign true\ngit config tag.gpgsign true\n</code></pre><p></p> <p>Also ensure <code>git_commit_gpgsign: true</code> in the import-gpg action.</p>"},{"location":"clickup-gpg-signing-correction/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Docker DOES support GPG signing with <code>crazy-max/ghaction-import-gpg</code></li> <li>Docker action is simpler than pip installation for CI/CD</li> <li>Both approaches work equally well for GPG signing</li> <li>GitHub Actions automatically mounts Git config to Docker containers</li> <li>No special Docker configuration needed - standard PSR action works</li> </ol>"},{"location":"clickup-gpg-signing-correction/#references","title":"References","text":"<ul> <li>crazy-max/ghaction-import-gpg - Handles GPG setup for GitHub Actions</li> <li>python-semantic-release Docker action</li> <li>GitHub Actions Docker container mounts</li> </ul>"},{"location":"community/","title":"Community & Support","text":""},{"location":"community/#community-support","title":"Community &amp; Support","text":"<p>Get help, connect with other users, and contribute to Cancelable.</p>"},{"location":"community/#getting-help","title":"Getting Help","text":""},{"location":"community/#github-discussions","title":"GitHub Discussions","text":"<p>The best place to ask questions and get help:</p> <p>Visit GitHub Discussions \u2192</p> <ul> <li>\ud83d\udcac Ask questions</li> <li>\ud83d\udca1 Share ideas</li> <li>\ud83d\udc1b Report issues</li> <li>\ud83d\udce2 Announcements</li> </ul>"},{"location":"community/#github-issues","title":"GitHub Issues","text":"<p>For bug reports and feature requests:</p> <p>Open an Issue \u2192</p> <p>When reporting bugs, please include:</p> <ul> <li>Python version</li> <li>Cancelable version</li> <li>Minimal reproducible example</li> <li>Expected vs actual behavior</li> <li>Relevant error messages</li> </ul>"},{"location":"community/#contributing","title":"Contributing","text":"<p>We welcome contributions! See our Contributing Guide for details.</p>"},{"location":"community/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>\ud83d\udcdd Documentation - Improve docs, add examples</li> <li>\ud83d\udc1b Bug Fixes - Fix issues, improve reliability</li> <li>\u2728 Features - Implement new functionality</li> <li>\ud83e\uddea Tests - Increase test coverage</li> <li>\ud83d\udcd6 Examples - Share real-world use cases</li> <li>\ud83c\udf0d Translations - Help internationalize docs</li> </ul>"},{"location":"community/#stay-updated","title":"Stay Updated","text":""},{"location":"community/#github","title":"GitHub","text":"<ul> <li>\u2b50 Star the repo - hotherio/cancelable</li> <li>\ud83d\udc40 Watch releases - Get notified of new versions</li> <li>\ud83c\udf74 Fork - Experiment and contribute</li> </ul>"},{"location":"community/#social-media","title":"Social Media","text":"<ul> <li>Twitter - @hother_io (if available)</li> <li>Blog - blog.hother.io (if available)</li> </ul>"},{"location":"community/#resources","title":"Resources","text":""},{"location":"community/#documentation","title":"Documentation","text":"<ul> <li>Getting Started - Installation and basics</li> <li>Core Concepts - Understand fundamentals</li> <li>Examples - Complete code examples</li> <li>API Reference - Complete API docs</li> </ul>"},{"location":"community/#external-resources","title":"External Resources","text":"<ul> <li>Awesome Cancelable - Community resources (if exists)</li> <li>PyPI Package - Package page</li> <li>GitHub Repository - Source code</li> </ul>"},{"location":"community/#code-of-conduct","title":"Code of Conduct","text":"<p>We are committed to providing a welcoming and inclusive community. Please read and follow our Code of Conduct.</p>"},{"location":"community/#license","title":"License","text":"<p>Cancelable is licensed under the MIT License.</p> <p>You are free to:</p> <ul> <li>\u2705 Use commercially</li> <li>\u2705 Modify</li> <li>\u2705 Distribute</li> <li>\u2705 Use privately</li> </ul>"},{"location":"community/#support-the-project","title":"Support the Project","text":""},{"location":"community/#sponsor","title":"Sponsor","text":"<p>If Cancelable helps your project, consider sponsoring:</p> <ul> <li>GitHub Sponsors (if available)</li> </ul>"},{"location":"community/#spread-the-word","title":"Spread the Word","text":"<ul> <li>Star the repository on GitHub</li> <li>Share on social media</li> <li>Mention in blog posts</li> <li>Recommend to colleagues</li> </ul>"},{"location":"community/#recognition","title":"Recognition","text":""},{"location":"community/#contributors","title":"Contributors","text":"<p>Thank you to all our contributors! \ud83c\udf89</p> <p>See the Contributors page for the full list.</p>"},{"location":"community/#built-with","title":"Built With","text":"<p>Cancelable is built on:</p> <ul> <li>anyio - Backend-agnostic async</li> <li>pydantic - Data validation</li> </ul>"},{"location":"community/#contact","title":"Contact","text":"<ul> <li>Email - contact@hother.io (if available)</li> <li>GitHub - @hotherio</li> </ul> <p>Ready to contribute? Check out our Contributing Guide to get started!</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-guide","title":"Contributing Guide","text":"<p>Thank you for considering contributing to Cancelable! This guide will help you get started.</p>"},{"location":"contributing/#quick-start","title":"Quick Start","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally</li> <li>Create a branch for your changes</li> <li>Make your changes with tests</li> <li>Submit a pull request</li> </ol>"},{"location":"contributing/#development-setup","title":"Development Setup","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or 3.13</li> <li>uv for dependency management</li> <li>Git</li> </ul>"},{"location":"contributing/#clone-and-setup","title":"Clone and Setup","text":"<pre><code># Clone your fork\ngit clone https://github.com/YOUR_USERNAME/cancelable.git\ncd cancelable\n\n# Sync dependencies\nuv sync --all-extras\n\n# Run tests to verify setup\nuv run pytest\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run with coverage\nuv run pytest --cov=hother.cancelable\n\n# Run specific test file\nuv run pytest tests/unit/test_cancelable.py -v\n\n# Run specific test\nuv run pytest tests/unit/test_cancelable.py::test_name -v\n</code></pre>"},{"location":"contributing/#linting-and-formatting","title":"Linting and Formatting","text":"<pre><code># Run linter\nuv run ruff check src\n\n# Fix linting issues automatically\nuv run ruff check --fix src\n\n# Type checking\nuv run mypy src\n</code></pre>"},{"location":"contributing/#running-examples","title":"Running Examples","text":"<pre><code># Basic examples\nuv run python examples/01_basics/01_basic_cancelation.py\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<pre><code># Serve documentation locally\nuv run mkdocs serve\n\n# Build documentation\nuv run mkdocs build\n\n# Deploy with versioning\nuv run mike deploy --update-aliases 0.1 latest\n</code></pre>"},{"location":"contributing/#making-changes","title":"Making Changes","text":""},{"location":"contributing/#branching-strategy","title":"Branching Strategy","text":"<ul> <li>main - Stable production code</li> <li>feature/* - New features</li> <li>fix/* - Bug fixes</li> <li>docs/* - Documentation improvements</li> </ul>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>Follow Conventional Commits:</p> <pre><code>feat: add custom cancelation source support\nfix: resolve race condition in registry cleanup\ndocs: improve getting started guide\ntest: add coverage for signal handling\nrefactor: simplify token cancelation logic\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8</li> <li>Use type hints</li> <li>Write docstrings for public APIs</li> <li>Keep functions focused and small</li> <li>Add comments for complex logic</li> </ul>"},{"location":"contributing/#testing-requirements","title":"Testing Requirements","text":"<ul> <li>Unit tests for all new functionality</li> <li>Integration tests for framework integrations</li> <li>Maintain coverage above 80%</li> <li>Test edge cases and error conditions</li> </ul> <p>Example test structure:</p> <pre><code>import pytest\nimport anyio\nfrom hother.cancelable import Cancelable\n\ndef test_timeout_cancelation():\n    \"\"\"Test that operations timeout correctly.\"\"\"\n    async def main():\n        with pytest.raises(anyio.get_cancelled_exc_class()):\n            async with Cancelable.with_timeout(0.1) as cancel:\n                await anyio.sleep(1.0)\n\n    anyio.run(main)\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li>Run tests - Ensure all tests pass</li> <li>Run linter - Fix all linting issues</li> <li>Update docs - Document new features</li> <li>Add tests - Cover your changes</li> <li>Update changelog - Note your changes (if applicable)</li> </ol>"},{"location":"contributing/#pr-checklist","title":"PR Checklist","text":"<ul> <li> Tests pass (<code>uv run pytest</code>)</li> <li> Linter passes (<code>uv run ruff check src</code>)</li> <li> Type checks pass (<code>uv run mypy src</code>)</li> <li> Documentation updated</li> <li> Examples added (if applicable)</li> <li> Changelog updated (if applicable)</li> <li> Commit messages follow convention</li> </ul>"},{"location":"contributing/#pr-title","title":"PR Title","text":"<p>Follow conventional commits format:</p> <pre><code>feat: add condition-based cancelation source\nfix: resolve registry cleanup race condition\ndocs: add LLM streaming example\n</code></pre>"},{"location":"contributing/#pr-description","title":"PR Description","text":"<p>Include:</p> <ul> <li>What - What does this PR do?</li> <li>Why - Why is this change needed?</li> <li>How - How does it work?</li> <li>Testing - How was it tested?</li> <li>Breaking Changes - Any breaking changes?</li> </ul> <p>Example:</p> <pre><code>## What\n\nAdds support for custom condition-based cancelation sources.\n\n## Why\n\nUsers need to cancel operations based on custom business logic,\nnot just timeouts or signals.\n\n## How\n\n- Created `ConditionSource` class\n- Added predicate function support\n- Implemented background monitoring task\n\n## Testing\n\n- Added unit tests for ConditionSource\n- Added integration test with resource monitoring\n- All existing tests pass\n\n## Breaking Changes\n\nNone\n</code></pre>"},{"location":"contributing/#contributing-areas","title":"Contributing Areas","text":""},{"location":"contributing/#documentation_1","title":"Documentation","text":"<ul> <li>Improve guides - Make concepts clearer</li> <li>Add examples - Share real-world use cases</li> <li>Fix typos - Even small improvements help</li> <li>Add diagrams - Visual explanations</li> </ul>"},{"location":"contributing/#code","title":"Code","text":"<ul> <li>Bug fixes - Fix reported issues</li> <li>New features - Implement requested features</li> <li>Performance - Optimize hot paths</li> <li>Tests - Increase coverage</li> </ul>"},{"location":"contributing/#examples","title":"Examples","text":"<ul> <li>Real-world patterns - Share your use cases</li> <li>Framework integrations - New frameworks</li> <li>Best practices - Production patterns</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful, inclusive, and constructive. We're all here to learn and improve together.</p>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Discussions - GitHub Discussions</li> <li>Issues - GitHub Issues</li> </ul>"},{"location":"contributing/#recognition","title":"Recognition","text":"<p>All contributors are recognized in:</p> <ul> <li>GitHub contributors page</li> <li>Release notes</li> <li>Documentation credits</li> </ul> <p>Thank you for contributing! \ud83c\udf89</p> <p>Questions? Open a discussion or reach out in an issue.</p>"},{"location":"custom_sources/","title":"Custom Sources","text":""},{"location":"custom_sources/#custom-cancelation-sources","title":"Custom Cancelation Sources","text":"<p>Build your own cancelation sources for specialized use cases.</p>"},{"location":"custom_sources/#creating-a-custom-source","title":"Creating a Custom Source","text":"<p>To create custom cancelation sources, you can extend <code>CancelationSource</code>.</p>"},{"location":"custom_sources/#basic-structure","title":"Basic Structure","text":"<pre><code>from hother.cancelable.sources.base import CancelationSource\nfrom hother.cancelable import CancelationReason\nimport anyio\n\nclass CustomSource(CancelationSource):  # (1)!\n    \"\"\"Custom cancelation source.\"\"\"\n\n    def __init__(self, description: str = \"Custom source\"):\n        super().__init__(description=description)\n        # Your custom initialization\n\n    async def monitor(self) -&gt; None:  # (2)!\n        \"\"\"Monitor for cancelation conditions.\"\"\"\n        while not self.is_cancelled:\n            if await self.should_cancel():\n                await self.trigger_cancelation(\n                    reason=CancelationReason.CONDITION,\n                    message=\"Custom condition met\"\n                )\n                break\n            await anyio.sleep(self.check_interval)\n\n    async def should_cancel(self) -&gt; bool:  # (3)!\n        \"\"\"Implement your cancelation logic.\"\"\"\n        # Your custom logic here\n        return False\n</code></pre> <ol> <li>Extend <code>CancelationSource</code> to create custom sources</li> <li>The <code>monitor()</code> method runs in background to check for cancelation conditions</li> <li>Implement <code>should_cancel()</code> with your cancelation logic - return <code>True</code> to cancel</li> </ol>"},{"location":"custom_sources/#file-watcher-example","title":"File Watcher Example","text":"<pre><code>from pathlib import Path\n\nclass FileWatcherSource(CancelationSource):\n    \"\"\"Cancel when a file appears.\"\"\"\n\n    def __init__(self, filepath: Path, check_interval: float = 1.0):\n        super().__init__(description=f\"File watcher: {filepath}\")\n        self.filepath = filepath\n        self.check_interval = check_interval\n\n    async def should_cancel(self) -&gt; bool:  # (1)!\n        \"\"\"Check if the stop file exists.\"\"\"\n        return self.filepath.exists()\n\n    async def monitor(self) -&gt; None:\n        \"\"\"Monitor for file appearance.\"\"\"\n        while not self.is_cancelled:\n            if await self.should_cancel():\n                await self.trigger_cancelation(\n                    reason=CancelationReason.CONDITION,\n                    message=f\"File {self.filepath} appeared\"\n                )\n                break\n            await anyio.sleep(self.check_interval)\n\n# Usage\nstop_file = Path(\"/tmp/stop_processing\")\nasync with Cancelable(\n    sources=[FileWatcherSource(stop_file)],\n    name=\"file_processor\"\n) as cancel:\n    await process_files()\n</code></pre> <ol> <li>Simple cancelation logic - return <code>True</code> when file exists</li> </ol>"},{"location":"custom_sources/#http-endpoint-source","title":"HTTP Endpoint Source","text":"<pre><code>import httpx\n\nclass HTTPCheckSource(CancelationSource):\n    \"\"\"Cancel when HTTP endpoint returns specific status.\"\"\"\n\n    def __init__(self, url: str, check_interval: float = 5.0):\n        super().__init__(description=f\"HTTP check: {url}\")\n        self.url = url\n        self.check_interval = check_interval\n        self.client = None\n\n    async def should_cancel(self) -&gt; bool:  # (1)!\n        \"\"\"Check if service is unavailable.\"\"\"\n        try:\n            response = await self.client.get(self.url)\n            return response.status_code == 503\n        except httpx.RequestError:\n            return False  # Don't cancel on network errors\n\n    async def monitor(self) -&gt; None:\n        \"\"\"Monitor HTTP endpoint for service availability.\"\"\"\n        async with httpx.AsyncClient() as client:\n            self.client = client\n            while not self.is_cancelled:\n                if await self.should_cancel():\n                    await self.trigger_cancelation(\n                        reason=CancelationReason.CONDITION,\n                        message=\"Service unavailable\"\n                    )\n                    break\n                await anyio.sleep(self.check_interval)\n</code></pre> <ol> <li>Wrap checks in try-except and handle errors gracefully - don't accidentally trigger cancelation on errors</li> </ol>"},{"location":"custom_sources/#best-practices","title":"Best Practices","text":""},{"location":"custom_sources/#keep-monitoring-logic-lightweight","title":"Keep Monitoring Logic Lightweight","text":"<pre><code># \u2705 Good - simple check\nasync def should_cancel(self) -&gt; bool:\n    return self.filepath.exists()\n\n# \u274c Bad - expensive operation in monitor loop\nasync def should_cancel(self) -&gt; bool:\n    data = await fetch_large_dataset()  # Slow!\n    return process_complex_logic(data)\n</code></pre>"},{"location":"custom_sources/#use-appropriate-check-intervals","title":"Use Appropriate Check Intervals","text":"<pre><code># \u2705 Good - reasonable intervals\nFileWatcherSource(filepath, check_interval=1.0)     # File checks: 1s\nHTTPCheckSource(url, check_interval=5.0)            # HTTP checks: 5s\nDatabaseCheckSource(query, check_interval=10.0)     # DB checks: 10s\n\n# \u274c Bad - too frequent\nFileWatcherSource(filepath, check_interval=0.01)    # 100 checks/second!\n</code></pre>"},{"location":"custom_sources/#built-in-advanced-sources","title":"Built-in Advanced Sources","text":""},{"location":"custom_sources/#resourceconditionsource","title":"ResourceConditionSource","text":"<p>Pre-built source for monitoring system resources (requires <code>psutil</code>):</p> <pre><code>from hother.cancelable.sources.condition import ResourceConditionSource\n\n# Cancel if memory usage exceeds 90%\nmemory_source = ResourceConditionSource(\n    memory_percent_threshold=90.0,\n    check_interval=5.0\n)\n\n# Cancel if CPU usage exceeds 95% for 10 seconds\ncpu_source = ResourceConditionSource(\n    cpu_percent_threshold=95.0,\n    check_interval=1.0,\n    sustained_seconds=10.0  # Must be sustained for 10s\n)\n\n# Cancel if disk usage exceeds 95%\ndisk_source = ResourceConditionSource(\n    disk_percent_threshold=95.0,\n    disk_path=\"/data\",\n    check_interval=10.0\n)\n\nasync with Cancelable(\n    sources=[memory_source, cpu_source, disk_source],\n    name=\"resource_monitored\"\n) as cancel:\n    await intensive_operation()\n</code></pre> <p>Parameters: - <code>memory_percent_threshold</code> - Memory usage percentage (0-100) - <code>cpu_percent_threshold</code> - CPU usage percentage (0-100) - <code>disk_percent_threshold</code> - Disk usage percentage (0-100) - <code>disk_path</code> - Path to monitor for disk usage - <code>sustained_seconds</code> - Threshold must be sustained for this duration - <code>check_interval</code> - How often to check (seconds)</p> <p>Use cases: - Production workload protection - Resource-intensive operations - Multi-tenant systems</p> <p>Note: Requires <code>psutil</code> package (<code>pip install psutil</code>)</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#getting-started-with-async-cancelation","title":"Getting Started with Async Cancelation","text":"<p>Installation</p> <p>See the Installation guide for complete installation instructions, including optional integrations and examples.</p>"},{"location":"getting_started/#basic-concepts","title":"Basic Concepts","text":""},{"location":"getting_started/#cancelable-operations","title":"Cancelable Operations","text":"<p>A <code>Cancelable</code> provides a context for managing async operations that can be cancelled from various sources:</p> <pre><code>from hother.cancelable import Cancelable\n\nasync with Cancelable() as cancel:\n    # Your async operation here\n    result = await some_async_operation()\n</code></pre>"},{"location":"getting_started/#cancelation-sources","title":"Cancelation Sources","text":"<p>Operations can be cancelled from multiple sources:</p> <ol> <li>Timeout: Cancel after a specified duration</li> <li>Token: Manual cancelation via a token</li> <li>Signal: OS signal handling (SIGINT, etc.)</li> <li>Condition*: Custom condition checking</li> </ol> <p>*: we provide <code>ResourceConditionSource</code> to cancel on system resource using <code>psutil</code> - particularly suitable for IoT applications.</p>"},{"location":"getting_started/#quick-examples","title":"Quick Examples","text":""},{"location":"getting_started/#timeout-cancelation","title":"Timeout Cancelation","text":"<pre><code>from hother.cancelable import Cancelable\nfrom datetime import timedelta\n\n# Using seconds\nasync with Cancelable.with_timeout(30.0) as cancel:\n    result = await long_running_operation()\n\n# Using timedelta\nasync with Cancelable.with_timeout(timedelta(minutes=5)) as cancel:\n    result = await very_long_operation()\n</code></pre>"},{"location":"getting_started/#manual-cancelation","title":"Manual Cancelation","text":"<pre><code>from hother.cancelable import Cancelable, CancelationToken\n\n# Create a token\ntoken = CancelationToken()\n\n# In your async operation\nasync def my_operation():\n    async with Cancelable.with_token(token) as cancel:\n        # This will be cancelled when token.cancel() is called\n        await some_work()\n\n# Cancel from elsewhere\nawait token.cancel()\n</code></pre>"},{"location":"getting_started/#progress-reporting","title":"Progress Reporting","text":"<pre><code>async with Cancelable() as cancel:\n    # Register progress callback\n    cancel.on_progress(lambda op_id, msg, meta: print(f\"Progress: {msg}\"))\n\n    # Report progress during operation\n    await cancel.report_progress(\"Starting operation\")\n\n    for i in range(100):\n        await process_item(i)\n        if i % 10 == 0:\n            await cancel.report_progress(f\"Processed {i} items\", {\"count\": i})\n</code></pre>"},{"location":"getting_started/#stream-processing","title":"Stream Processing","text":"<pre><code>async with Cancelable.with_timeout(60) as cancel:\n    # Process async stream with automatic cancelation\n    async for item in cancel.stream(async_data_source()):\n        await process_item(item)\n</code></pre>"},{"location":"getting_started/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always use context managers: Ensures proper cleanup    </p><pre><code>async with Cancelable() as cancel:\n    # Your code here\n</code></pre><p></p> </li> <li> <p>Report progress for long operations: Helps with monitoring    </p><pre><code>await cancel.report_progress(\"Processing batch\", {\"size\": len(batch)})\n</code></pre><p></p> </li> <li> <p>Handle cancelation gracefully: Save partial results    </p><pre><code>try:\n    async with Cancelable.with_timeout(30) as cancel:\n        result = await process_all()\nexcept Exception:\n    # Save partial results from cancel.context.partial_result\n    pass\n</code></pre><p></p> </li> </ol>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>See the Core Concepts to learn more about the concepts</li> <li>Read the API Reference for detailed documentation</li> <li>Check out Common Patterns for advanced usage</li> <li>Explore the Examples for complete examples</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>Cancelable requires Python 3.12+.</p>"},{"location":"installation/#quick-start","title":"Quick Start","text":"uvpip <pre><code>uv add hother-cancelable\n</code></pre> <pre><code>pip install hother-cancelable\n</code></pre>"},{"location":"installation/#with-integrations","title":"With Integrations","text":"<p>Install with optional integration groups:</p> uvpip <pre><code># Web framework\nuv add \"hother-cancelable[fastapi]\"\n</code></pre> <pre><code># Web framework\npip install \"hother-cancelable[fastapi]\"\n</code></pre>"},{"location":"installation/#with-examples","title":"With Examples","text":"<p>To run the example scripts from the repository:</p> uvpip <pre><code>uv add \"hother-cancelable[examples]\"\n</code></pre> <pre><code>pip install \"hother-cancelable[examples]\"\n</code></pre> <p>Includes:</p> <ul> <li><code>google-genai</code> - For LLM streaming examples</li> <li><code>pynput</code> - For input monitoring examples</li> <li><code>psutil</code> - For resource monitoring</li> </ul> <p>Then clone the repository and run examples:</p> <pre><code>git clone https://github.com/hotherio/cancelable.git\ncd cancelable\nuv run examples/01_basics/01_basic_cancelation.py\n</code></pre> <p>Browse all examples: Examples Documentation</p>"},{"location":"installation/#available-extras","title":"Available Extras","text":"Extra Includes Use Case <code>fastapi</code> fastapi Web framework integration <code>examples</code> google-genai, pynput, psutil Running example scripts from repository"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li> <p> Getting Started</p> <p>Learn the basics and start using Cancelable</p> <p> Get Started</p> </li> <li> <p> Browse Examples</p> <p>Complete runnable examples for common use cases</p> <p> View Examples</p> </li> <li> <p> Integrations</p> <p>Framework-specific integration guides</p> <p> Learn Integrations</p> </li> <li> <p> API Reference</p> <p>Complete API documentation</p> <p> API Docs</p> </li> </ul>"},{"location":"patterns/","title":"Common Patterns","text":""},{"location":"patterns/#common-patterns-and-best-practices","title":"Common Patterns and Best Practices","text":"<p>Here is a collection of common patterns that leverage <code>Cancelable</code>.</p>"},{"location":"patterns/#graceful-shutdown","title":"Graceful Shutdown","text":"<p>Handle application shutdown gracefully:</p> <pre><code>import signal\nfrom hother.cancelable import Cancelable\n\nasync def main():\n    # Handle SIGINT and SIGTERM\n    async with Cancelable.with_signal(signal.SIGINT, signal.SIGTERM) as cancel:\n        cancel.on_cancel(lambda ctx: print(\"Shutting down gracefully...\"))\n\n        # Your application logic\n        await run_application()\n</code></pre> <p>Or using the decorator:</p> <pre><code>import signal\nfrom hother.cancelable import cancelable_with_signal\n\n@cancelable_with_signal(signal.SIGINT, signal.SIGTERM)\nasync def main(cancelable=None):\n    \"\"\"Application with graceful shutdown.\"\"\"\n    cancelable.on_cancel(lambda ctx: print(\"Shutting down gracefully...\"))\n    await run_application()\n</code></pre>"},{"location":"patterns/#resource-cleanup","title":"Resource Cleanup","text":"<p>Ensure resources are cleaned up even on cancelation:</p> <pre><code>async def process_with_cleanup():\n    resource = None\n\n    async with Cancelable.with_timeout(30) as cancel:\n        try:\n            # Acquire resource\n            resource = await acquire_resource()\n\n            # Process\n            result = await process(resource)\n\n            return result\n\n        finally:\n            # Shield cleanup from cancelation\n            if resource:\n                async with cancel.shield():\n                    await resource.cleanup()\n</code></pre>"},{"location":"patterns/#batch-processing-with-progress","title":"Batch Processing with Progress","text":"<p>Process data in batches with progress reporting:</p> <pre><code>async def process_large_dataset(data: List[Any], batch_size: int = 100):\n    async with Cancelable(name=\"batch_processing\") as cancel:\n        cancel.on_progress(lambda op_id, msg, meta: logger.info(msg, **meta))\n\n        total = len(data)\n        processed = 0\n\n        for i in range(0, total, batch_size):\n            batch = data[i:i + batch_size]\n\n            # Process batch\n            await process_batch(batch)\n            processed += len(batch)\n\n            # Report progress\n            progress = (processed / total) * 100\n            await cancel.report_progress(\n                f\"Processed {processed}/{total} items\",\n                {\"progress_percent\": progress, \"batch_number\": i // batch_size + 1}\n            )\n</code></pre>"},{"location":"patterns/#retry-with-cancelation","title":"Retry with Cancelation","text":"<p>Implement retry logic with cancelation support:</p> <pre><code>async def retry_with_cancelation(\n    operation: Callable,\n    max_retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n):\n    async with Cancelable(name=\"retry_operation\") as cancel:\n        last_error = None\n\n        # Wrap operation to automatically check cancelation\n        wrapped_op = cancel.wrap(operation)\n\n        for attempt in range(max_retries):\n            try:\n                # Cancelation checked automatically by wrap()\n                result = await wrapped_op()\n                return result\n\n            except Exception as e:\n                last_error = e\n\n                if attempt &lt; max_retries - 1:\n                    await cancel.report_progress(\n                        f\"Attempt {attempt + 1} failed, retrying...\",\n                        {\"error\": str(e)}\n                    )\n\n                    # Wait with exponential backoff\n                    await anyio.sleep(delay)\n                    delay *= backoff\n\n        raise last_error\n</code></pre>"},{"location":"patterns/#concurrent-operations-with-shared-cancelation","title":"Concurrent Operations with Shared Cancelation","text":"<p>Run multiple operations with shared cancelation:</p> <pre><code>async def parallel_operations():\n    async with Cancelable(name=\"parallel_work\") as cancel:\n        # Wrap process_item to automatically check cancelation\n        wrapped_process = cancel.wrap(process_item)\n\n        async def worker(worker_id: int, items: List[Any]):\n            for item in items:\n                # Cancelation checked automatically\n                await wrapped_process(item)\n\n                # Report progress\n                await cancel.report_progress(\n                    f\"Worker {worker_id} processed item\",\n                    {\"worker_id\": worker_id, \"item\": item}\n                )\n\n        # Split work among workers\n        work_items = split_into_chunks(all_items, worker_count=4)\n\n        # Run workers concurrently\n        async with anyio.create_task_group() as tg:\n            for i, items in enumerate(work_items):\n                tg.start_soon(worker, i, items)\n</code></pre>"},{"location":"patterns/#hierarchical-cancelation","title":"Hierarchical Cancelation","text":"<p>Create operation hierarchies with parent-child relationships:</p> <pre><code>async def hierarchical_operations():\n    async with Cancelable(name=\"parent_operation\") as parent:\n        # Create child operations\n        async def child_operation(child_id: int):\n            child = Cancelable(\n                name=f\"child_{child_id}\",\n                parent=parent\n            )\n\n            async with child:\n                # Child will be cancelled if parent is cancelled\n                await do_child_work()\n\n        # Run children\n        async with anyio.create_task_group() as tg:\n            for i in range(5):\n                tg.start_soon(child_operation, i)\n</code></pre>"},{"location":"patterns/#conditional-cancelation","title":"Conditional Cancelation","text":"<p>Cancel based on system resources:</p> <pre><code>import psutil\n\ndef check_memory_usage():\n    \"\"\"Cancel if memory usage is too high.\"\"\"\n    return psutil.virtual_memory().percent &gt; 90\n\nasync def memory_aware_operation():\n    async with Cancelable.with_condition(\n        check_memory_usage,\n        check_interval=5.0,\n        condition_name=\"memory_check\"\n    ) as cancel:\n        cancel.on_cancel(\n            lambda ctx: logger.warning(\"Operation cancelled due to high memory usage\")\n        )\n\n        await memory_intensive_operation()\n</code></pre>"},{"location":"performance/","title":"Performance","text":""},{"location":"performance/#performance-considerations","title":"Performance Considerations","text":"<p>Understanding the performance characteristics and overhead of Cancelable.</p>"},{"location":"performance/#overhead-analysis","title":"Overhead Analysis","text":"<p>Cancelable adds minimal overhead to async operations:</p>"},{"location":"performance/#baseline-overhead","title":"Baseline Overhead","text":"<ul> <li>Context manager entry/exit: &lt; 1\u03bcs</li> <li>Registry operations: &lt; 5\u03bcs</li> <li>Progress reporting: &lt; 10\u03bcs per report</li> <li>Source monitoring: Depends on check interval</li> </ul>"},{"location":"performance/#benchmarks","title":"Benchmarks","text":"<p>Typical overhead compared to pure asyncio:</p> <pre><code># Pure asyncio\nasync with asyncio.timeout(30):\n    await operation()  # Baseline\n\n# Cancelable (single source)\nasync with Cancelable.with_timeout(30.0):\n    await operation()  # &lt; 1% overhead\n\n# Cancelable (multiple sources)\nasync with Cancelable.combine([...]):\n    await operation()  # &lt; 2% overhead\n</code></pre>"},{"location":"performance/#optimization-tips","title":"Optimization Tips","text":""},{"location":"performance/#limit-progress-reporting","title":"Limit Progress Reporting","text":"<pre><code># \u274c Too frequent - high overhead\nfor i in range(1_000_000):\n    await process(i)\n    await cancel.report_progress(...)  # Million calls!\n\n# \u2705 Good frequency\nfor i in range(1_000_000):\n    await process(i)\n    if i % 1000 == 0:\n        await cancel.report_progress(...)  # Thousand calls\n</code></pre>"},{"location":"performance/#choose-appropriate-check-intervals","title":"Choose Appropriate Check Intervals","text":"<pre><code># \u274c Too frequent - wastes CPU\nConditionSource(check_disk_space, check_interval=0.01)\n\n# \u2705 Reasonable interval\nConditionSource(check_disk_space, check_interval=5.0)\n</code></pre>"},{"location":"performance/#disable-auto-registration","title":"Disable Auto-Registration","text":"<p>Only if registry monitoring is not needed:</p> <pre><code># Saves ~5\u03bcs per operation\nasync with Cancelable(auto_register=False) as cancel:\n    await operation()\n</code></pre>"},{"location":"performance/#memory-usage","title":"Memory Usage","text":""},{"location":"performance/#registry-memory","title":"Registry Memory","text":"<p>Each registered operation uses ~1KB:</p> <ul> <li>Small applications: Negligible (&lt; 100 ops = &lt; 100KB)</li> <li>Large applications: Monitor with cleanup</li> </ul>"},{"location":"performance/#cleanup","title":"Cleanup","text":"<p>Registry auto-cleans completed operations. For long-running apps:</p> <pre><code># Periodic cleanup in production\nregistry = OperationRegistry.get_instance()\nregistry.cleanup_completed()  # If needed\n</code></pre>"},{"location":"performance/#production-recommendations","title":"Production Recommendations","text":""},{"location":"performance/#do","title":"Do","text":"<ul> <li>\u2705 Use appropriate check intervals (1-10s typical)</li> <li>\u2705 Report progress at milestones (every 100-1000 items)</li> <li>\u2705 Monitor registry size in long-running apps</li> <li>\u2705 Profile your specific use case</li> </ul>"},{"location":"performance/#dont","title":"Don't","text":"<ul> <li>\u274c Don't report progress on every iteration</li> <li>\u274c Don't use sub-100ms check intervals</li> <li>\u274c Don't create excessive nested hierarchies</li> <li>\u274c Don't keep references to completed operations</li> </ul>"},{"location":"performance/#profiling","title":"Profiling","text":"<p>Measure Cancelable overhead in your application:</p> <pre><code>import time\n\nasync def benchmark():\n    # Without Cancelable\n    start = time.perf_counter()\n    await operation()\n    baseline = time.perf_counter() - start\n\n    # With Cancelable\n    start = time.perf_counter()\n    async with Cancelable.with_timeout(30.0) as cancel:\n        await operation()\n    with_cancel = time.perf_counter() - start\n\n    overhead = ((with_cancel - baseline) / baseline) * 100\n    print(f\"Overhead: {overhead:.2f}%\")\n</code></pre>"},{"location":"registry/","title":"Operation Registry","text":""},{"location":"registry/#operation-registry","title":"Operation Registry","text":"<p>The global registry tracks all active cancelable operations for monitoring and debugging.</p>"},{"location":"registry/#overview","title":"Overview","text":"<p>The <code>OperationRegistry</code> is a singleton that automatically tracks all <code>Cancelable</code> operations. It provides visibility into:</p> <ul> <li>Currently active operations</li> <li>Operation status and progress</li> <li>Hierarchical relationships</li> <li>Historical operation data</li> </ul>"},{"location":"registry/#accessing-the-registry","title":"Accessing the Registry","text":"<pre><code>from hother.cancelable import OperationRegistry\n\n# Get singleton instance\nregistry = OperationRegistry.get_instance()\n</code></pre>"},{"location":"registry/#querying-operations","title":"Querying Operations","text":""},{"location":"registry/#get-all-active-operations","title":"Get All Active Operations","text":"<pre><code>from hother.cancelable import OperationRegistry\n\nregistry = OperationRegistry.get_instance()\n\n# Get all currently running operations\nactive_ops = registry.get_active_operations()\n\nfor op in active_ops:\n    print(f\"Operation: {op.name}\")\n    print(f\"  ID: {op.id}\")\n    print(f\"  Status: {op.status}\")\n    print(f\"  Elapsed: {op.elapsed_time:.2f}s\")\n    print(f\"  Parent: {op.parent_id}\")\n</code></pre>"},{"location":"registry/#get-operation-by-id","title":"Get Operation by ID","text":"<pre><code>op_id = \"operation-123\"\noperation = registry.get_operation(op_id)\n\nif operation:\n    print(f\"Found: {operation.name}\")\n    print(f\"Status: {operation.status}\")\n</code></pre>"},{"location":"registry/#get-operation-by-name","title":"Get Operation by Name","text":"<pre><code>operation = registry.get_operation_by_name(\"data_processor\")\n\nif operation:\n    print(f\"ID: {operation.id}\")\n    print(f\"Running for: {operation.elapsed_time:.1f}s\")\n</code></pre>"},{"location":"registry/#get-child-operations","title":"Get Child Operations","text":"<pre><code># Get all children of a parent operation\nparent_op = registry.get_operation_by_name(\"parent_task\")\nchildren = registry.get_children(parent_op.id)\n\nfor child in children:\n    print(f\"Child: {child.name} ({child.status})\")\n</code></pre>"},{"location":"registry/#operation-information","title":"Operation Information","text":"<p>Each operation in the registry contains:</p> <pre><code>class OperationContext:\n    id: str                    # Unique operation ID\n    name: str                  # Human-readable name\n    status: OperationStatus    # PENDING, RUNNING, CANCELLED, COMPLETED\n    start_time: float          # Timestamp when started\n    end_time: Optional[float]  # Timestamp when finished\n    parent_id: Optional[str]   # Parent operation ID\n    cancel_reason: Optional[CancelationReason]  # Why cancelled\n    cancel_message: str        # Cancelation message\n    progress_callbacks: List   # Registered progress handlers\n</code></pre>"},{"location":"registry/#status-values","title":"Status Values","text":"<pre><code>from hother.cancelable import OperationStatus\n\n# Possible statuses\nOperationStatus.PENDING    # Created but not started\nOperationStatus.RUNNING    # Currently executing\nOperationStatus.CANCELLED  # Cancelled by source\nOperationStatus.COMPLETED  # Finished successfully\nOperationStatus.FAILED     # Finished with error\n</code></pre>"},{"location":"registry/#cancelation-reasons","title":"Cancelation Reasons","text":"<pre><code>from hother.cancelable import CancelationReason\n\n# Why operations cancel\nCancelationReason.TIMEOUT     # TimeoutSource triggered\nCancelationReason.MANUAL      # TokenSource triggered\nCancelationReason.SIGNAL      # SignalSource triggered\nCancelationReason.CONDITION   # ConditionSource triggered\n</code></pre>"},{"location":"registry/#monitoring-dashboard-example","title":"Monitoring Dashboard Example","text":"<p>Build a real-time monitoring dashboard:</p> <pre><code>import anyio\nfrom hother.cancelable import OperationRegistry, Cancelable\n\nasync def monitor_operations():\n    \"\"\"Print operation status every second.\"\"\"\n    registry = OperationRegistry.get_instance()\n\n    while True:\n        active = registry.get_active_operations()\n\n        print(\"\\n\" + \"=\"*60)\n        print(f\"Active Operations: {len(active)}\")\n        print(\"=\"*60)\n\n        for op in active:\n            elapsed = op.elapsed_time\n            print(f\"\ud83d\udcca {op.name}\")\n            print(f\"   ID: {op.id[:8]}...\")\n            print(f\"   Status: {op.status}\")\n            print(f\"   Elapsed: {elapsed:.1f}s\")\n\n            if op.parent_id:\n                parent = registry.get_operation(op.parent_id)\n                if parent:\n                    print(f\"   Parent: {parent.name}\")\n\n        await anyio.sleep(1.0)\n\nasync def main():\n    # Start monitoring in background\n    async with anyio.create_task_group() as tg:\n        tg.start_soon(monitor_operations)\n\n        # Run some operations\n        async with Cancelable(name=\"task_1\") as cancel:\n            await anyio.sleep(5)\n\nanyio.run(main)\n</code></pre>"},{"location":"registry/#operation-lifecycle","title":"Operation Lifecycle","text":"<p>Understanding operation registration and cleanup:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Registered: Cancelable created\n    Registered --&gt; Running: __aenter__\n    Running --&gt; Completed: operation succeeds\n    Running --&gt; Cancelled: source triggers\n    Running --&gt; Failed: exception raised\n    Completed --&gt; Unregistered\n    Cancelled --&gt; Unregistered\n    Failed --&gt; Unregistered\n    Unregistered --&gt; [*]</code></pre>"},{"location":"registry/#automatic-registration","title":"Automatic Registration","text":"<p>Operations are automatically registered when created:</p> <pre><code># Auto-registered (default)\nasync with Cancelable(name=\"auto_registered\") as cancel:\n    await operation()\n    # Automatically unregistered after context exits\n\n# Disable auto-registration (not recommended)\nasync with Cancelable(name=\"manual\", auto_register=False) as cancel:\n    await operation()\n    # NOT in registry\n</code></pre>"},{"location":"registry/#manual-cleanup","title":"Manual Cleanup","text":"<p>The registry automatically cleans up completed operations, but you can manually clear if needed:</p> <pre><code>registry = OperationRegistry.get_instance()\n\n# Clear all operations (use with caution!)\nregistry.clear()\n\n# In tests, use clean registry\nregistry.clear()\n# ... run test ...\nregistry.clear()  # Cleanup after\n</code></pre>"},{"location":"registry/#hierarchical-tracking","title":"Hierarchical Tracking","text":"<p>The registry tracks parent-child relationships:</p> <pre><code>registry = OperationRegistry.get_instance()\n\nasync with Cancelable(name=\"parent\") as parent:\n    parent_id = parent.context.id\n\n    async with Cancelable(name=\"child_1\", parent=parent) as child1:\n        # Query hierarchy\n        children = registry.get_children(parent_id)\n        assert len(children) == 1\n        assert children[0].name == \"child_1\"\n\n    async with Cancelable(name=\"child_2\", parent=parent) as child2:\n        children = registry.get_children(parent_id)\n        assert len(children) == 1  # child_1 already completed\n</code></pre>"},{"location":"registry/#examples","title":"Examples","text":""},{"location":"registry/#export-metrics","title":"Export Metrics","text":"<pre><code>def export_operation_metrics():\n    \"\"\"Export metrics for Prometheus/Datadog.\"\"\"\n    registry = OperationRegistry.get_instance()\n    active = registry.get_active_operations()\n\n    metrics = {\n        \"active_operations\": len(active),\n        \"operations_by_status\": {\n            \"running\": sum(1 for op in active if op.status == OperationStatus.RUNNING),\n            \"pending\": sum(1 for op in active if op.status == OperationStatus.PENDING),\n        },\n        \"longest_running\": max(\n            (op.elapsed_time for op in active),\n            default=0\n        )\n    }\n\n    return metrics\n</code></pre>"},{"location":"registry/#health-check-endpoint","title":"Health Check Endpoint","text":"<pre><code>from fastapi import FastAPI\nfrom hother.cancelable import OperationRegistry\n\napp = FastAPI()\n\n@app.get(\"/health/operations\")\nasync def operation_health():\n    \"\"\"Health check showing active operations.\"\"\"\n    registry = OperationRegistry.get_instance()\n    active = registry.get_active_operations()\n\n    return {\n        \"status\": \"healthy\",\n        \"active_count\": len(active),\n        \"operations\": [\n            {\n                \"name\": op.name,\n                \"status\": op.status.value,\n                \"elapsed\": round(op.elapsed_time, 2)\n            }\n            for op in active\n        ]\n    }\n</code></pre>"},{"location":"registry/#alert-on-long-running-operations","title":"Alert on Long-Running Operations","text":"<pre><code>import anyio\n\nasync def monitor_long_running():\n    \"\"\"Alert if operations run too long.\"\"\"\n    registry = OperationRegistry.get_instance()\n\n    while True:\n        active = registry.get_active_operations()\n\n        for op in active:\n            if op.elapsed_time &gt; 300:  # 5 minutes\n                await send_alert(\n                    f\"Long-running operation: {op.name} \"\n                    f\"({op.elapsed_time:.0f}s)\"\n                )\n\n        await anyio.sleep(60)  # Check every minute\n</code></pre>"},{"location":"registry/#common-patterns","title":"Common Patterns","text":""},{"location":"registry/#find-stuck-operations","title":"Find Stuck Operations","text":"<pre><code>def find_stuck_operations(threshold_seconds: float = 300):\n    \"\"\"Find operations running longer than threshold.\"\"\"\n    registry = OperationRegistry.get_instance()\n    active = registry.get_active_operations()\n\n    stuck = [\n        op for op in active\n        if op.elapsed_time &gt; threshold_seconds\n    ]\n\n    return stuck\n</code></pre>"},{"location":"registry/#operation-tree-visualization","title":"Operation Tree Visualization","text":"<pre><code>def print_operation_tree():\n    \"\"\"Print hierarchical operation tree.\"\"\"\n    registry = OperationRegistry.get_instance()\n    active = registry.get_active_operations()\n\n    # Find root operations (no parent)\n    roots = [op for op in active if not op.parent_id]\n\n    def print_node(op, indent=0):\n        prefix = \"  \" * indent\n        print(f\"{prefix}\u251c\u2500 {op.name} ({op.status}, {op.elapsed_time:.1f}s)\")\n\n        children = registry.get_children(op.id)\n        for child in children:\n            print_node(child, indent + 1)\n\n    for root in roots:\n        print_node(root)\n</code></pre>"},{"location":"registry/#progress-aggregation","title":"Progress Aggregation","text":"<pre><code>def aggregate_progress():\n    \"\"\"Calculate overall progress across all operations.\"\"\"\n    registry = OperationRegistry.get_instance()\n    active = registry.get_active_operations()\n\n    total_weight = len(active)\n    completed_weight = sum(\n        1 for op in active\n        if op.status == OperationStatus.COMPLETED\n    )\n\n    if total_weight == 0:\n        return 100.0\n\n    return (completed_weight / total_weight) * 100\n</code></pre>"},{"location":"registry/#maintenance","title":"Maintenance","text":""},{"location":"registry/#cleanup_completed","title":"cleanup_completed()","text":"<p>Remove completed operations from registry to prevent memory growth:</p> <pre><code>from hother.cancelable import OperationRegistry\n\nregistry = OperationRegistry.get_instance()\n\n# Remove operations completed more than 1 hour ago\nawait registry.cleanup_completed(max_age_seconds=3600)\n\n# Or cleanup all completed\nawait registry.cleanup_completed()\n</code></pre> <p>Use cases: - Long-running services - Preventing memory leaks - Periodic maintenance tasks</p>"},{"location":"registry/#historical-queries","title":"Historical Queries","text":""},{"location":"registry/#get_history","title":"get_history()","text":"<p>Retrieve historical operations including completed and cancelled:</p> <pre><code># Get last 100 operations\nhistory = await registry.get_history(limit=100)\n\nfor op in history:\n    print(f\"{op.name}: {op.status} - {op.elapsed_time}s\")\n\n# Filter by status\ncompleted = await registry.get_history(\n    status=OperationStatus.COMPLETED,\n    limit=50\n)\n</code></pre> <p>Parameters: - <code>limit</code> - Maximum operations to return - <code>status</code> - Filter by status (COMPLETED, CANCELLED, etc.) - <code>since</code> - Operations after timestamp</p>"},{"location":"registry/#bulk-cancelation","title":"Bulk Cancelation","text":""},{"location":"registry/#cancel_all-with-filters","title":"cancel_all() with Filters","text":"<p>Bulk cancelation with pattern matching:</p> <pre><code># Cancel all operations for a user\nawait registry.cancel_all(\n    name_pattern=\"user_123_*\",\n    reason=CancelationReason.MANUAL\n)\n\n# Cancel all long-running operations\nawait registry.cancel_all(\n    min_age_seconds=300,  # Older than 5 minutes\n    reason=CancelationReason.TIMEOUT\n)\n\n# Cancel operations matching complex criteria\nawait registry.cancel_all(\n    filter_func=lambda op: op.context.metadata.get('priority') == 'low',\n    reason=CancelationReason.MANUAL\n)\n</code></pre> <p>Parameters: - <code>name_pattern</code> - Glob pattern for operation names - <code>min_age_seconds</code> - Minimum age in seconds - <code>max_age_seconds</code> - Maximum age in seconds - <code>filter_func</code> - Custom filter function - <code>reason</code> - Cancelation reason to record</p>"},{"location":"releases/","title":"Release Automation Guide","text":""},{"location":"releases/#release-automation-guide","title":"Release Automation Guide","text":"<p>This guide documents the automated release process for the Cancelable project using python-semantic-release.</p>"},{"location":"releases/#overview","title":"Overview","text":"<p>The Cancelable project uses fully automated semantic versioning. Every commit to the <code>main</code> branch is analyzed, and when appropriate, a new version is automatically released.</p>"},{"location":"releases/#workflow-diagram","title":"Workflow Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Push to main    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Analyze commits \u2502 \u2190 python-semantic-release\n\u2502 (conventional)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         v\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502 Release \u2502\n    \u2502 needed? \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502   No    \u2502 \u2500\u2500\u2192 [Stop]\n    \u2502         \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502   Yes   \u2502\n    \u2502         \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. Bump version \u2502 \u2500\u2500 Update pyproject.toml\n\u2502 2. Update       \u2502 \u2500\u2500 Update CHANGELOG.md\n\u2502 3. Create tag   \u2502 \u2500\u2500 Git tag (GPG signed)\n\u2502 4. Build dist   \u2502 \u2500\u2500 uv build\n\u2502 5. Publish PyPI \u2502 \u2500\u2500 Trusted Publishing\n\u2502 6. Create GH    \u2502 \u2500\u2500 GitHub Release\n\u2502    Release      \u2502\n\u2502 7. Deploy docs  \u2502 \u2500\u2500 mike deploy\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"releases/#conventional-commits","title":"Conventional Commits","text":""},{"location":"releases/#format","title":"Format","text":"<pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre>"},{"location":"releases/#commit-types","title":"Commit Types","text":"Type Description Version Bump Example <code>feat</code> New feature Minor (0.5.0 \u2192 0.6.0) <code>feat: add signal-based cancellation</code> <code>fix</code> Bug fix Patch (0.5.0 \u2192 0.5.1) <code>fix: resolve race condition in token</code> <code>perf</code> Performance improvement Patch <code>perf: optimize registry lookup</code> <code>refactor</code> Code refactoring Patch <code>refactor: simplify token linking</code> <code>docs</code> Documentation only None <code>docs: update README examples</code> <code>chore</code> Build/tooling changes None <code>chore: update dependencies</code> <code>ci</code> CI configuration None <code>ci: add coverage reporting</code> <code>style</code> Code style/formatting None <code>style: format with ruff</code> <code>test</code> Add/update tests None <code>test: add timeout source tests</code> <code>revert</code> Revert previous commit None <code>revert: \"feat: add feature X\"</code>"},{"location":"releases/#breaking-changes","title":"Breaking Changes","text":"<p>Breaking changes trigger a major version bump (0.5.0 \u2192 1.0.0):</p> <p>Option 1: Use <code>!</code> after type: </p><pre><code>git commit -m \"feat!: redesign cancellation API\n\nThe CancellationToken.cancel() method is now async.\nSynchronous code should use cancel_sync() instead.\"\n</code></pre><p></p> <p>Option 2: Use <code>BREAKING CHANGE:</code> footer: </p><pre><code>git commit -m \"feat: redesign cancellation API\n\nBREAKING CHANGE: The CancellationToken.cancel() method is now\nasync. Synchronous code should use cancel_sync() instead.\"\n</code></pre><p></p>"},{"location":"releases/#examples","title":"Examples","text":"<p>Feature (minor bump): </p><pre><code>git commit -m \"feat: add condition-based cancellation source\n\nAdds ConditionSource that polls a predicate function and\ncancels when it returns True. Useful for resource monitoring.\"\n</code></pre><p></p> <p>Bug fix (patch bump): </p><pre><code>git commit -m \"fix: prevent deadlock in cross-thread cancellation\n\nEnsures proper lock ordering when cancelling from different threads.\"\n</code></pre><p></p> <p>Performance (patch bump): </p><pre><code>git commit -m \"perf: cache compiled regex patterns in commit parser\"\n</code></pre><p></p> <p>Documentation (no release): </p><pre><code>git commit -m \"docs: add FastAPI integration examples\"\n</code></pre><p></p> <p>Multiple changes (use highest priority): </p><pre><code># This will trigger a minor bump (feat takes precedence)\ngit commit -m \"feat: add new source type\n\nAlso fixes minor bug in existing timeout source.\"\n</code></pre><p></p>"},{"location":"releases/#enforcement","title":"Enforcement","text":""},{"location":"releases/#pre-commit-validation","title":"Pre-commit Validation","text":"<p>Commit messages are validated before commit using lefthook:</p> <pre><code># lefthook.yml\ncommit-msg:\n  commands:\n    conventional:\n      run: |\n        if ! head -1 {1} | grep -qE '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\\(.+?\\))?: .{1,}$'; then\n          echo \"\u274c Commit message must follow Conventional Commits format\"\n          exit 1\n        fi\n</code></pre> <p>Bypass if needed (not recommended): </p><pre><code>git commit --no-verify -m \"wip: temporary commit\"\n</code></pre><p></p>"},{"location":"releases/#github-pr-title-check","title":"GitHub PR Title Check","text":"<p>PR titles are also validated in CI to ensure they follow conventional commits.</p>"},{"location":"releases/#local-development","title":"Local Development","text":""},{"location":"releases/#preview-next-version","title":"Preview Next Version","text":"<p>Check what version would be released without making changes:</p> <pre><code># Must be on main branch\ngit checkout main\ngit pull\n\n# Preview next version\nuv run semantic-release --noop version --print\n\n# With debug output\nuv run semantic-release --noop --verbose version --print\n</code></pre> <p>Example output: </p><pre><code>0.6.0  # Next version would be 0.6.0\n</code></pre><p></p>"},{"location":"releases/#preview-changelog","title":"Preview Changelog","text":"<p>Generate changelog for unreleased commits:</p> <pre><code>uv run semantic-release changelog\n</code></pre>"},{"location":"releases/#test-configuration","title":"Test Configuration","text":"<p>Validate semantic-release configuration:</p> <pre><code># Show configuration\nuv run semantic-release generate-config\n\n# Check if release would happen\nuv run semantic-release --noop version --print\n</code></pre>"},{"location":"releases/#manual-release-trigger","title":"Manual Release Trigger","text":"<p>While releases are automatic, you can manually trigger the workflow:</p>"},{"location":"releases/#via-github-ui","title":"Via GitHub UI","text":"<ol> <li>Go to Actions \u2192 Semantic Release</li> <li>Click Run workflow</li> <li>Select branch: <code>main</code></li> <li>Click Run workflow</li> </ol>"},{"location":"releases/#via-github-cli","title":"Via GitHub CLI","text":"<pre><code>gh workflow run semantic-release.yml\n</code></pre>"},{"location":"releases/#pypi-trusted-publishing","title":"PyPI Trusted Publishing","text":"<p>The project uses PyPI's Trusted Publishing for secure, token-free releases.</p>"},{"location":"releases/#how-it-works","title":"How It Works","text":"<ol> <li>GitHub Actions workflow runs with <code>id-token: write</code> permission</li> <li>GitHub provides OIDC token proving workflow identity</li> <li>PyPI verifies token and authorizes publish</li> <li>No API tokens stored or managed!</li> </ol>"},{"location":"releases/#configuration","title":"Configuration","text":"<p>On PyPI: - Publisher: GitHub Actions - Owner: <code>hotherio</code> - Repository: <code>cancelable</code> - Workflow: <code>semantic-release.yml</code> - Environment: (none)</p> <p>In workflow: </p><pre><code>permissions:\n  id-token: write  # Required for Trusted Publishing\n  contents: write  # Create tags and releases\n\n- name: Publish to PyPI\n  uses: pypa/gh-action-pypi-publish@release/v1\n  # No password/token needed!\n</code></pre><p></p>"},{"location":"releases/#setup-for-new-projects","title":"Setup for New Projects","text":"<ol> <li>Create package on PyPI (one-time manual publish)</li> <li>Go to PyPI \u2192 Project \u2192 Publishing</li> <li>Add GitHub publisher:    - Owner: organization/user    - Repository: repo-name    - Workflow: semantic-release.yml</li> <li>Save configuration</li> <li>Future releases publish automatically!</li> </ol>"},{"location":"releases/#troubleshooting","title":"Troubleshooting","text":""},{"location":"releases/#no-release-created","title":"No Release Created","text":"<p>Problem: Pushed to main, but no release was created.</p> <p>Possible causes:</p> <ol> <li>No releasable commits since last release: <pre><code># Check commits since last tag\ngit log $(git describe --tags --abbrev=0)..HEAD --oneline\n\n# Look for feat:, fix:, perf:, or refactor: commits\n</code></pre></li> </ol> <p>Solution: Only <code>feat</code>, <code>fix</code>, <code>perf</code>, and <code>refactor</code> trigger releases.</p> <ol> <li>Branch not configured for releases: <pre><code># Verify you're on main\ngit branch --show-current\n</code></pre></li> </ol> <p>Solution: Releases only happen from <code>main</code> branch.</p> <ol> <li>Invalid commit format: <pre><code># Check recent commits\ngit log --oneline -5\n</code></pre></li> </ol> <p>Solution: Ensure commits follow conventional commits format.</p>"},{"location":"releases/#version-conflict","title":"Version Conflict","text":"<p>Problem: <code>Version x.y.z already exists on PyPI</code></p> <p>Cause: Tag exists but PyPI publish failed previously.</p> <p>Solution: </p><pre><code># Option 1: Delete local and remote tag, create new commit\ngit tag -d vX.Y.Z\ngit push origin :refs/tags/vX.Y.Z\n\n# Make a small change\ngit commit --allow-empty -m \"chore: trigger new release\"\ngit push\n\n# Option 2: Manually publish to PyPI\nuv build\nuv publish\n</code></pre><p></p>"},{"location":"releases/#pypi-upload-fails","title":"PyPI Upload Fails","text":"<p>Problem: <code>Error: Trusted publishing exchange failure</code></p> <p>Possible causes:</p> <ol> <li> <p>Publisher not configured on PyPI:    - Go to PyPI project settings \u2192 Publishing    - Add GitHub publisher with correct details</p> </li> <li> <p>Workflow permissions incorrect: </p><pre><code># Verify in .github/workflows/semantic-release.yml\npermissions:\n  id-token: write  # Must be present\n</code></pre><p></p> </li> <li> <p>Wrong workflow name:    - PyPI publisher must match exact workflow filename    - Default: <code>semantic-release.yml</code></p> </li> </ol>"},{"location":"releases/#documentation-not-deployed","title":"Documentation Not Deployed","text":"<p>Problem: Release succeeded but docs not updated.</p> <p>Cause: Docs workflow depends on <code>release.published</code> event.</p> <p>Check: </p><pre><code># Verify docs.yaml uses correct event\ngrep -A 3 \"release:\" .github/workflows/docs.yaml\n\n# Should show:\n#   release:\n#     types:\n#     - published\n</code></pre><p></p> <p>Manual deploy: </p><pre><code>uv sync --group doc\nuv run mike deploy --push --update-aliases v0.5 latest\n</code></pre><p></p>"},{"location":"releases/#migration-from-git-cliff","title":"Migration from git-cliff","text":""},{"location":"releases/#what-changed","title":"What Changed","text":"Before (git-cliff) After (PSR) Manual trigger via GitHub Actions Automatic on push to main Three-stage releases (dev/rc/final) Single semantic release <code>tools/release.py</code> custom script python-semantic-release <code>cliff.toml</code> configuration <code>pyproject.toml</code> configuration Manual version bumping Automatic from commits Separate changelog generation Integrated changelog"},{"location":"releases/#removed-files","title":"Removed Files","text":"<ul> <li><code>tools/release.py</code> - Custom release script</li> <li><code>cliff.toml</code> - git-cliff configuration</li> <li><code>.github/workflows/bump.yml</code> - Manual bump workflow</li> <li><code>.github/workflows/release.yml</code> - Tag-triggered release</li> </ul>"},{"location":"releases/#preserved","title":"Preserved","text":"<ul> <li>Conventional commits - Still required (now enforced)</li> <li>GPG signing - Tags and commits still signed</li> <li>CHANGELOG.md - Still auto-generated</li> <li>PyPI publishing - Now via Trusted Publishing</li> <li>Documentation deployment - Still automatic</li> </ul>"},{"location":"releases/#best-practices","title":"Best Practices","text":""},{"location":"releases/#commit-messages","title":"Commit Messages","text":"<ol> <li> <p>Write clear, descriptive messages: </p><pre><code># Good\nfeat: add timeout parameter to Cancelable context\n\n# Bad\nfeat: add timeout\n</code></pre><p></p> </li> <li> <p>Include context in body: </p><pre><code>feat: add condition-based cancellation\n\nAllows cancellation based on custom predicates that are\npolled periodically. Useful for resource monitoring and\nexternal stop signals.\n</code></pre><p></p> </li> <li> <p>Document breaking changes: </p><pre><code>feat!: make CancellationToken.cancel() async\n\nBREAKING CHANGE: The cancel() method is now async and must\nbe awaited. Synchronous callers should use cancel_sync()\ninstead.\n\nMigration guide:\n- Old: token.cancel()\n- New: await token.cancel()  # async context\n- New: token.cancel_sync()   # sync context\n</code></pre><p></p> </li> </ol>"},{"location":"releases/#pull-requests","title":"Pull Requests","text":"<ol> <li> <p>Use conventional format in PR title: </p><pre><code>feat: add feature X\nfix: resolve bug Y\ndocs: update guide Z\n</code></pre><p></p> </li> <li> <p>PR title becomes the commit message when squash merging</p> </li> <li> <p>Include breaking changes in PR description if applicable</p> </li> </ol>"},{"location":"releases/#versioning-strategy","title":"Versioning Strategy","text":"<ul> <li>0.x.y: Pre-1.0 development (current)</li> <li>Breaking changes allowed on minor bumps</li> <li> <p>Set <code>major_on_zero = false</code> in config</p> </li> <li> <p>1.x.y: Stable releases (future)</p> </li> <li>Breaking changes require major bump</li> <li>Set <code>major_on_zero = true</code> when ready</li> </ul>"},{"location":"releases/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"releases/#custom-commit-types","title":"Custom Commit Types","text":"<p>To add custom commit types, edit <code>pyproject.toml</code>:</p> <pre><code>[tool.semantic_release.commit_parser_options]\nallowed_tags = [\n    \"build\", \"chore\", \"ci\", \"docs\", \"feat\", \"fix\",\n    \"perf\", \"refactor\", \"style\", \"test\", \"revert\",\n    \"custom\",  # Add custom type\n]\nminor_tags = [\"feat\", \"custom\"]  # Types that trigger minor bump\npatch_tags = [\"fix\", \"perf\", \"refactor\"]  # Types that trigger patch bump\n</code></pre>"},{"location":"releases/#changelog-template","title":"Changelog Template","text":"<p>Custom changelog templates can be added in <code>templates/</code> directory:</p> <pre><code># Project structure\ntemplates/\n  \u2514\u2500\u2500 CHANGELOG.md.j2\n</code></pre>"},{"location":"releases/#version-variables","title":"Version Variables","text":"<p>Access version in other files using template variables:</p> <pre><code>[tool.semantic_release]\nversion_toml = [\n    \"pyproject.toml:project.version\",\n    \"src/hother/cancelable/__init__.py:__version__\",\n]\n</code></pre>"},{"location":"releases/#reference","title":"Reference","text":"<ul> <li>python-semantic-release Documentation</li> <li>Conventional Commits Specification</li> <li>Semantic Versioning</li> <li>PyPI Trusted Publishing</li> <li>Keep a Changelog</li> </ul>"},{"location":"streaming/","title":"Streaming Cancellation","text":""},{"location":"streaming/#streaming-cancelation","title":"Streaming Cancelation","text":"<p>The primary reason why Cancelable was developed is to managed properly stream cancelable, and in particular in the context of canceling async streams from another thread or processe.</p>"},{"location":"streaming/#overview","title":"Overview","text":"<p>Streaming cancelation is a core feature of Cancelable that allows you to safely cancel async stream processing operations. </p>"},{"location":"streaming/#basic-stream-cancelation","title":"Basic Stream Cancelation","text":""},{"location":"streaming/#simple-stream-with-timeout","title":"Simple Stream with Timeout","text":"<pre><code>from hother.cancelable import Cancelable, cancelable_stream\nimport anyio\n\nasync def process_stream():\n    async with Cancelable.with_timeout(60.0, name=\"stream_processor\") as cancel:\n        async for item in cancelable_stream(data_source(), cancel): # (1)!\n            await process_item(item)\n            # Stream automatically stops on timeout\n\nanyio.run(process_stream)\n</code></pre> <ol> <li><code>cancelable_stream()</code> wraps any async iterator to make it cancelation-aware</li> </ol>"},{"location":"streaming/#manual-stream-cancelation","title":"Manual Stream Cancelation","text":"<pre><code>from hother.cancelable import CancelationToken\n\ntoken = CancelationToken()\n\nasync def stream_worker():\n    async with Cancelable.with_token(token) as cancel:\n        async for item in cancelable_stream(data(), cancel):\n            await process(item)\n\nasync def stream_controller():\n    await anyio.sleep(10)\n    await token.cancel(\"User stopped stream\")\n\n# Run both\nasync with anyio.create_task_group() as tg:\n    tg.start_soon(stream_worker)\n    tg.start_soon(stream_controller)\n</code></pre>"},{"location":"streaming/#the-cancelable_stream-utility","title":"The cancelable_stream Utility","text":"<p>The <code>cancelable_stream()</code> function wraps any async iterator to make it respect cancelation:</p> <pre><code>from hother.cancelable.utils.streams import cancelable_stream\n\nasync with Cancelable.with_timeout(30.0) as cancel:\n    # Wrap any async iterator\n    wrapped = cancelable_stream(\n        async_iterator=my_stream(),  # Any async generator\n        cancelable=cancel,           # Cancelable context\n        buffer_size=100               # Optional buffering\n    )\n\n    async for item in wrapped:\n        await process(item)\n</code></pre>"},{"location":"streaming/#how-it-works","title":"How It Works","text":"<p><code>cancelable_stream()</code> monitors the cancelable context and:</p> <ol> <li>Yields items from the source stream normally</li> <li>Checks cancelation before each yield</li> <li>Stops iteration cleanly if cancelled</li> <li>Handles buffering to prevent backpressure</li> </ol>"},{"location":"streaming/#class-based-iterator","title":"Class-Based Iterator","text":""},{"location":"streaming/#cancelableasynciterator","title":"CancelableAsyncIterator","text":"<p>Class-based alternative to <code>cancelable_stream()</code>:</p> <pre><code>from hother.cancelable.utils.streams import CancelableAsyncIterator\n\nasync with Cancelable.with_timeout(60.0) as cancel:\n    # Wrap any async iterator\n    stream = CancelableAsyncIterator(data_source(), cancel)\n\n    async for item in stream:\n        await process(item)\n        # Stream automatically stops on cancelation\n</code></pre> <p>Features: - Implements <code>__aiter__</code> and <code>__anext__</code> - Checks cancelation before each item - Graceful termination</p> <p>Use case: When you need more control over stream iteration or prefer class-based APIs.</p>"},{"location":"streaming/#chunked-processing","title":"Chunked Processing","text":""},{"location":"streaming/#chunked_cancelable_stream","title":"chunked_cancelable_stream()","text":"<p>Process streams in chunks with cancelation support:</p> <pre><code>from hother.cancelable.utils.streams import chunked_cancelable_stream\n\nasync with Cancelable.with_timeout(300.0) as cancel:\n    # Process in chunks of 100 items\n    async for chunk in chunked_cancelable_stream(\n        data_stream(),\n        cancel,\n        chunk_size=100\n    ):\n        # chunk is a list of up to 100 items\n        await batch_process(chunk)\n        # Cancelation checked between chunks\n</code></pre> <p>Parameters: - <code>stream</code> - Source async iterator - <code>cancelable</code> - Cancelable context - <code>chunk_size</code> - Items per chunk</p> <p>Use cases: - Batch database inserts - Bulk API calls - Memory-efficient processing</p>"},{"location":"threading/","title":"Threading & Bridges","text":""},{"location":"threading/#threading-cross-context-cancelation","title":"Threading &amp; Cross-Context Cancelation","text":"<p>Cancel async operations from threads and bridge between sync/async worlds.</p>"},{"location":"threading/#overview","title":"Overview","text":"<p>Cross-thread cancelation is a core feature that allows you to cancel async operations from synchronous code or different threads. This solves the fundamental problem of coordinating between Python's threading and async ecosystems.</p> <p>Cancelable solves this with thread-safe cancelation:</p> <pre><code>token = CancelationToken()\n\ndef button_click_handler():  # Runs in GUI thread\n    token.cancel_sync(\"User clicked cancel\")  # Thread-safe!\n\nasync def long_async_operation():\n    async with Cancelable.with_token(token) as cancel:\n        await process_data()  # Respects cancelation from thread\n</code></pre>"},{"location":"threading/#thread-safe-cancelation","title":"Thread-Safe Cancelation","text":"<p>Cancel async operations from synchronous threads:</p> <pre><code>import threading\nimport time\nfrom hother.cancelable import CancelationToken, Cancelable\n\ntoken = CancelationToken()\n\nasync def async_worker():\n    \"\"\"Long-running async operation.\"\"\"\n    async with Cancelable.with_token(token, name=\"worker\") as cancel:\n        for i in range(100):\n            await process_item(i)\n            await anyio.sleep(0.1)\n\ndef sync_canceller():\n    \"\"\"Runs in separate thread.\"\"\"\n    time.sleep(5)  # Wait 5 seconds\n    # Thread-safe cancelation\n    token.cancel_sync(message=\"Cancelled from thread\")  # (1)!\n\n# Start thread\nthread = threading.Thread(target=sync_canceller)\nthread.start()\n\n# Run async work\nawait async_worker()  # Will be cancelled after 5 seconds\nthread.join()\n</code></pre> <ol> <li><code>cancel_sync()</code> is thread-safe and works from any thread</li> </ol>"},{"location":"threading/#thread-safe-registry-operations","title":"Thread-Safe Registry Operations","text":""},{"location":"threading/#threadsaferegistry","title":"ThreadSafeRegistry","text":"<p>Synchronous API for the operation registry, designed for thread-based web frameworks (Flask, Django).</p> <p>Why you need this: <code>OperationRegistry</code> is async by default, but many Python web frameworks run in synchronous threads.</p> <pre><code>from hother.cancelable.utils.threading_bridge import ThreadSafeRegistry\n\n# In Flask/Django view\nregistry = ThreadSafeRegistry()\n\n# Cancel an operation from a synchronous endpoint\n@app.post(\"/jobs/&lt;job_id&gt;/cancel\")\ndef cancel_job(job_id):\n    registry.cancel_operation(job_id, \"User requested cancel\")\n    return {\"status\": \"cancelled\"}\n\n# Get statistics synchronously\n@app.get(\"/stats\")\ndef get_stats():\n    stats = registry.get_statistics()\n    return {\n        \"total\": stats.total_operations,\n        \"running\": stats.running_operations,\n        \"cancelled\": stats.cancelled_operations\n    }\n\n# Cancel all operations matching a pattern\n@app.post(\"/jobs/cancel-all\")\ndef cancel_all_user_jobs(user_id):\n    registry.cancel_all(name_pattern=f\"user_{user_id}_*\")\n    return {\"status\": \"all_cancelled\"}\n</code></pre> <p>Methods: - <code>cancel_operation(operation_id, reason)</code> - Cancel specific operation - <code>cancel_all(name_pattern=None)</code> - Cancel all or filtered operations - <code>get_statistics()</code> - Get registry statistics - <code>get_operation(operation_id)</code> - Retrieve operation context</p>"},{"location":"threading/#context-propagation-to-threads","title":"Context Propagation to Threads","text":""},{"location":"threading/#contextbridge","title":"ContextBridge","text":"<p>Propagate context variables (like <code>current_operation()</code>) to threads safely.</p> <p>The problem: Python's <code>contextvars</code> don't automatically propagate to threads, so <code>current_operation()</code> returns <code>None</code> in threads.</p> <p>The solution:</p> <pre><code>from hother.cancelable.utils.context_bridge import ContextBridge\n\nasync def main():\n    async with Cancelable.with_timeout(30.0, name=\"parent\") as cancel:\n        # Run blocking operation in thread with context preserved\n        bridge = ContextBridge()\n\n        def sync_work():\n            # current_operation() works here!\n            ctx = current_operation()\n            print(f\"Operation: {ctx.context.name}\")  # Prints \"parent\"\n\n        result = await bridge.run_in_thread_with_context(sync_work)\n</code></pre> <p>Methods: - <code>run_in_thread_with_context(func, *args, **kwargs)</code> - Run function in thread with context - <code>copy_context()</code> - Capture current context - <code>restore_context(context)</code> - Restore captured context</p>"},{"location":"threading/#running-blocking-operations-in-threads","title":"Running Blocking Operations in Threads","text":""},{"location":"threading/#run_in_thread-method","title":"run_in_thread() Method","text":"<p>Run synchronous functions in threads while preserving cancelation context.</p> <pre><code>async with Cancelable.with_timeout(30.0) as cancel:\n    # Run blocking I/O in thread\n    def blocking_database_query():\n        # Simulates blocking call that can't be async\n        return database.execute_slow_query()\n\n    result = await cancel.run_in_thread(blocking_database_query)\n    # Respects cancelation even while running in thread\n</code></pre> <p>Use case: Integrating blocking libraries (database drivers, file operations) that don't have async support.</p>"},{"location":"threading/#thread-to-async-communication","title":"Thread-to-Async Communication","text":""},{"location":"threading/#anyiobridge","title":"AnyioBridge","text":"<p>Thread-to-anyio communication bridge for high-throughput scenarios.</p> <pre><code>from hother.cancelable.utils.anyio_bridge import AnyioBridge\n\nbridge = AnyioBridge(buffer_size=1000)  # Configure buffer\n\nasync with bridge:\n    # From another thread, send data to async code\n    def thread_producer():\n        for item in generate_data():\n            bridge.call_soon_threadsafe(process_item, item)\n\n    # Start thread\n    thread = threading.Thread(target=thread_producer)\n    thread.start()\n\n    # Process in async context\n    await process_all_items()\n</code></pre> <p>Parameters: - <code>buffer_size</code> - Queue size for thread-to-async communication - <code>max_workers</code> - Thread pool size</p> <p>Use cases: - High-throughput data ingestion - Integrating synchronous libraries - Thread pool management</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#troubleshooting-guide","title":"Troubleshooting Guide","text":"<p>This guide helps you resolve common issues and understand limitations when using the cancelable library.</p>"},{"location":"troubleshooting/#common-runtime-errors","title":"Common Runtime Errors","text":""},{"location":"troubleshooting/#cancelscope-not-properly-closed","title":"\"CancelScope not properly closed\"","text":"<p>Cause: Improper async context manager usage Fix: </p><pre><code># Correct usage\nasync with Cancelable() as cancel:\n    await operation()\n\n# Avoid this\ncancel = Cancelable()\ntry:\n    await operation()\nfinally:\n    await cancel.__aexit__(None, None, None)\n</code></pre><p></p>"},{"location":"troubleshooting/#signal-handler-issues","title":"Signal Handler Issues","text":"<p>Error: Signals not working on Windows  Note: Signal handling has limited support on Windows (primarily SIGINT)</p>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Cause: Operation registry not cleared  Fix: </p><pre><code>from hother.cancelable import OperationRegistry\n\nregistry = OperationRegistry.get_instance()\nawait registry.clear_all()  # Clear completed operations\n</code></pre><p></p>"},{"location":"troubleshooting/#slow-cancelation-propagation","title":"Slow Cancelation Propagation","text":"<p>Cause: Too many concurrent operations  Fix: Use operation limits and batching </p><pre><code># Limit concurrent operations\nasync with Cancelable(name=\"batch_processor\") as cancel:\n    semaphore = asyncio.Semaphore(10)  # Max 10 concurrent\n    # ... process items with semaphore\n</code></pre><p></p>"},{"location":"troubleshooting/#integration-issues","title":"Integration Issues","text":""},{"location":"troubleshooting/#fastapi-request-cancelation","title":"FastAPI Request Cancelation","text":"<p>Issue: Requests not cancelling properly  Fix: Use the FastAPI integration dependency </p><pre><code>from hother.cancelable.integrations.fastapi import cancelable_dependency\n\n@app.post(\"/process\")\nasync def process_data(cancel: Cancelable = Depends(cancelable_dependency)):\n    async with cancel:\n        return await process_large_dataset()\n</code></pre><p></p>"},{"location":"troubleshooting/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<p>Configure logging in your application to see detailed cancelation flow:</p> <pre><code>import logging\n\n# Configure logging in your application\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\n# Enable debug logs for hother.cancelable\nlogging.getLogger(\"hother.cancelable\").setLevel(logging.DEBUG)\n</code></pre>"},{"location":"troubleshooting/#monitor-active-operations","title":"Monitor Active Operations","text":"<pre><code>from hother.cancelable import OperationRegistry\n\nregistry = OperationRegistry.get_instance()\noperations = await registry.list_operations()\nfor op in operations:\n    print(f\"{op.name}: {op.status.value}\")\n</code></pre>"},{"location":"troubleshooting/#check-cancelation-state","title":"Check Cancelation State","text":"<pre><code># Debug token state\nprint(f\"Token cancelled: {token.is_cancelled}\")\nprint(f\"Reason: {token.reason}\")\nprint(f\"Message: {token.message}\")\n\n# Check operation context\nprint(f\"Operation status: {cancel.context.status}\")\nprint(f\"Duration: {cancel.context.duration}\")\n</code></pre>"},{"location":"troubleshooting/#platform-specific-issues","title":"Platform-Specific Issues","text":""},{"location":"troubleshooting/#windows-signal-handling","title":"Windows Signal Handling","text":"<ul> <li>SIGTERM not available</li> <li>Use SIGINT (Ctrl+C) only</li> <li>Consider using <code>CancelationToken</code> with manual triggers</li> </ul>"},{"location":"troubleshooting/#macos-file-monitoring","title":"macOS File Monitoring","text":"<ul> <li>Some file watching APIs may not work</li> <li>Use polling alternatives for file changes</li> </ul>"},{"location":"troubleshooting/#linux-container-issues","title":"Linux Container Issues","text":"<ul> <li>Signal handling may be limited in containers</li> <li>Ensure proper signal forwarding from host</li> </ul>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<ol> <li>Check the examples in <code>examples/</code> directory</li> <li>Enable debug logging for detailed traces</li> <li>Check GitHub issues for similar problems</li> </ol>"},{"location":"examples/","title":"Overview","text":""},{"location":"examples/#examples","title":"Examples","text":"<p>Complete, runnable examples demonstrating Cancelable in real-world scenarios.</p>"},{"location":"examples/#browse-by-category","title":"Browse by Category","text":"<p>All examples are complete and runnable. You can copy-paste them directly or find the source in the <code>examples/</code> directory.</p>"},{"location":"examples/#basic-patterns","title":"Basic Patterns","text":"<p>Learn fundamental cancelation patterns:</p> <ul> <li>\u23f1\ufe0f Timeout Cancelation - Simple time-based cancelation</li> <li>\u270b Manual Cancelation - User-initiated cancelation with tokens</li> <li>\ud83d\udd14 Signal Handling - OS signal-based graceful shutdown</li> <li>\ud83c\udfaf Condition-Based - Cancel based on custom logic</li> <li>\ud83d\udd17 Combined Sources - Compose multiple cancelation triggers</li> </ul> <p>Best for: Getting started, understanding core concepts</p>"},{"location":"examples/#stream-processing","title":"Stream Processing","text":"<p>Handle async streams with cancelation:</p> <ul> <li>\ud83d\udcca Buffered Streams - Process data with backpressure</li> <li>\u23f8\ufe0f Cancelable Iteration - Stop stream processing cleanly</li> <li>\ud83d\udd04 Transform &amp; Filter - Streaming transformations with cancelation</li> <li>\ud83d\udcc8 Progress Tracking - Report stream processing progress</li> </ul> <p>Best for: Data pipelines, ETL, real-time processing</p>"},{"location":"examples/#web-applications","title":"Web Applications","text":"<p>Integrate with web frameworks:</p> <ul> <li>\ud83d\ude80 FastAPI Request Scoped - Automatic cancelation on disconnect</li> <li>\ud83d\udce1 Background Tasks - Long-running tasks with manual cancel</li> <li>\ud83d\udd0c WebSocket Streams - Real-time data with cancelation</li> <li>\u23f2\ufe0f API Timeouts - Request-level timeout handling</li> </ul> <p>Best for: Web APIs, REST services, real-time applications</p>"},{"location":"examples/#monitoring-dashboard","title":"Monitoring Dashboard","text":"<p>Build observability and monitoring:</p> <ul> <li>\ud83d\udcca Real-time Dashboard - Monitor all active operations</li> <li>\ud83d\udcc8 Progress Visualization - Display operation progress</li> <li>\u26a0\ufe0f Alert System - Detect stuck or failing operations</li> <li>\ud83d\udcc9 Metrics Export - Send to Prometheus, Datadog, etc.</li> </ul> <p>Best for: Production monitoring, debugging, observability</p>"},{"location":"examples/#llm-integration","title":"LLM Integration","text":"<p>Integrate with Large Language Models:</p> <ul> <li>\ud83e\udd16 LLM Streaming - Stream AI responses with cancelation</li> <li>\u23f8\ufe0f User Pause/Resume - Keyboard-based pause control</li> <li>\ud83c\udfaf LLM-Initiated Pause - AI signals when to pause</li> <li>\ud83d\udcdd Context Preservation - Resume from exact position</li> </ul> <p>Best for: AI applications, chatbots, content generation</p>"},{"location":"examples/#quick-start-examples","title":"Quick Start Examples","text":""},{"location":"examples/#simple-timeout","title":"Simple Timeout","text":"<pre><code>from hother.cancelable import Cancelable\nimport anyio\n\nasync def main():\n    async with Cancelable.with_timeout(30.0) as cancel:\n        await long_operation()\n\nanyio.run(main)\n</code></pre>"},{"location":"examples/#manual-cancelation","title":"Manual Cancelation","text":"<pre><code>from hother.cancelable import CancelationToken\n\ntoken = CancelationToken()\n\nasync def worker():\n    async with Cancelable.with_token(token) as cancel:\n        await task()\n\nasync def controller():\n    await anyio.sleep(5)\n    await token.cancel(\"User stopped\")\n\nasync with anyio.create_task_group() as tg:\n    tg.start_soon(worker)\n    tg.start_soon(controller)\n</code></pre>"},{"location":"examples/#combined-cancelation","title":"Combined Cancelation","text":"<pre><code>import signal\nfrom hother.cancelable import TimeoutSource, SignalSource\n\nasync with Cancelable.combine([\n    TimeoutSource(60.0),\n    SignalSource(signal.SIGTERM),\n    manual_token\n]) as cancel:\n    await operation()  # Cancels on FIRST trigger\n</code></pre>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>All examples in the <code>examples/</code> directory can be run directly:</p> <pre><code># Basic examples\npython examples/01_basics/01_basic_cancelation.py\npython examples/01_basics/02_timeout_cancelation.py\n\n# Advanced patterns\npython examples/02_advanced/01_combined_cancelation.py\n\n# Monitoring dashboard\npython examples/05_monitoring/01_monitoring_dashboard.py\n\n# LLM streaming (requires API key)\nGEMINI_API_KEY=\"your-key\" python examples/06_llm/01_llm_streaming.py\n</code></pre>"},{"location":"examples/#example-structure","title":"Example Structure","text":"<p>Each example includes:</p> <ul> <li>Complete, runnable code - Copy-paste ready</li> <li>Clear documentation - Explains what and why</li> <li>Expected output - What you should see</li> <li>Variations - Different approaches to try</li> <li>Best practices - Production-ready patterns</li> </ul>"},{"location":"examples/#by-use-case","title":"By Use Case","text":"<p>Not sure which example to use? Find your scenario:</p> What You're Building Recommended Example Web API endpoint FastAPI Request Scoped Data processing pipeline Stream Processing Background job system Web Background Tasks AI chatbot LLM Streaming Monitoring dashboard Real-time Dashboard CLI tool with Ctrl+C Signal Handling Long-running export Progress Tracking"},{"location":"examples/#contributing-examples","title":"Contributing Examples","text":"<p>Have a useful pattern? Submit an example!</p>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Patterns - Start here if you're new</li> <li>Core Concepts - Understand the fundamentals</li> <li>Integrations - Framework-specific guides</li> <li>Advanced Patterns - Production patterns</li> </ul>"},{"location":"examples/basic/","title":"Basic Patterns","text":""},{"location":"examples/basic/#basic-patterns","title":"Basic Patterns","text":"<p>Fundamental cancelation patterns for getting started.</p> <p>All examples on this page are complete and runnable. Find the source in <code>examples/01_basics/</code>.</p>"},{"location":"examples/basic/#timeout-cancelation","title":"Timeout Cancelation","text":"<p>Cancel operations that exceed a time limit.</p>"},{"location":"examples/basic/#simple-timeout","title":"Simple Timeout","text":"<pre><code>    # Example: Timeout-based cancelation\n    cancel = None\n    try:\n        async with Cancelable.with_timeout(2.0, name=\"timeout_example\") as cancel:\n            cancel.on_progress(lambda op_id, msg, meta: print(f\"  Progress: {msg}\"))\n\n            await cancel.report_progress(\"Starting operation\")\n\n            # This will timeout\n            await anyio.sleep(5.0)\n\n            await cancel.report_progress(\"This won't be reached\")\n\n    except anyio.get_cancelled_exc_class():\n        if cancel:\n            print(\n                f\"  Operation timed out after {(cancel.context.duration.total_seconds() if cancel.context.duration else 0.0):.2f}s\"\n            )\n            print(f\"  Final status: {cancel.context.status.value}\")\n            print(f\"  Cancel reason: {cancel.context.cancel_reason.value if cancel.context.cancel_reason else 'unknown'}\")\n</code></pre> <p>This example shows timeout-based cancelation with error handling.</p> <p>Run it: </p><pre><code>python examples/01_basics/02_timeout_cancelation.py\n</code></pre><p></p>"},{"location":"examples/basic/#timeout-with-cleanup","title":"Timeout with Cleanup","text":"<pre><code>async def with_cleanup():\n    async with Cancelable.with_timeout(10.0) as cancel:\n        try:\n            await process_data()\n        finally:\n            # Shield cleanup from cancelation\n            async with cancel.shield():\n                await cleanup_resources()\n</code></pre>"},{"location":"examples/basic/#manual-cancelation","title":"Manual Cancelation","text":"<p>Cancel operations programmatically using tokens.</p>"},{"location":"examples/basic/#basic-token-usage","title":"Basic Token Usage","text":"<p>Here's a complete example showing manual cancelation with tokens:</p> <pre><code>    # Example: Manual cancelation with token\n\n    # Create a cancelation token\n    token = CancelationToken()\n\n    async def background_task() -&gt; None:\n        \"\"\"Simulate a long-running task.\"\"\"\n        try:\n            async with Cancelable.with_token(token, name=\"background_task\") as cancel:\n                cancel.on_progress(lambda op_id, msg, meta: print(f\"  Progress: {msg}\"))\n                for i in range(10):\n                    await cancel.report_progress(f\"Step {i + 1}/10\")\n                    await anyio.sleep(0.5)\n        except anyio.get_cancelled_exc_class():\n            print(\"  Background task was cancelled!\")\n\n    # Run task and cancel after 2 seconds\n    try:\n        async with anyio.create_task_group() as tg:\n            # Start background task\n            tg.start_soon(background_task)\n\n            # Cancel after 2 seconds\n            await anyio.sleep(2.0)\n            print(\"Cancelling task...\")\n            await token.cancel(message=\"User requested cancelation\")\n    except* anyio.get_cancelled_exc_class():\n        # Handle the cancelation from task group\n        print(\"  Task group cancelled due to operation cancelation\")\n</code></pre> <p>Run it: </p><pre><code>python examples/01_basics/03_manual_cancelation.py\n</code></pre><p></p>"},{"location":"examples/basic/#thread-safe-cancelation","title":"Thread-Safe Cancelation","text":"<p>Cancel from synchronous code or threads:</p> <pre><code>import threading\nimport time\nfrom hother.cancelable import CancelationToken\n\ntoken = CancelationToken()\n\nasync def async_worker():\n    async with Cancelable.with_token(token) as cancel:\n        await long_async_operation()\n\ndef sync_canceller():\n    \"\"\"Runs in a separate thread.\"\"\"\n    time.sleep(5)\n    # Thread-safe cancelation\n    token.cancel_sync(message=\"Cancelled from thread\")\n\n# Start thread\nthread = threading.Thread(target=sync_canceller)\nthread.start()\n\n# Run async work\nawait async_worker()\nthread.join()\n</code></pre>"},{"location":"examples/basic/#signal-handling","title":"Signal Handling","text":"<p>Cancel on OS signals for graceful shutdown.</p>"},{"location":"examples/basic/#graceful-shutdown","title":"Graceful Shutdown","text":"<pre><code>import signal\nfrom hother.cancelable import Cancelable\n\nasync def main():\n    async with Cancelable.with_signal(\n        signal.SIGTERM,  # Graceful shutdown\n        signal.SIGINT,   # Ctrl+C\n        name=\"application\"\n    ) as cancel:\n        try:\n            print(\"Application running... (Ctrl+C to stop)\")\n            await run_server()\n        finally:\n            # Always run cleanup\n            async with cancel.shield():\n                print(\"Shutting down gracefully...\")\n                await save_state()\n                await close_connections()\n                print(\"Shutdown complete\")\n\nanyio.run(main)\n</code></pre> <p>Run it: </p><pre><code>python examples/02_advanced/08_signal_handling.py\n# Press Ctrl+C to trigger graceful shutdown\n</code></pre><p></p> <p>Platform Support</p> <p>Signal handling works on Unix-like systems (Linux, macOS). Windows supports SIGINT (Ctrl+C) only.</p>"},{"location":"examples/basic/#condition-based-cancelation","title":"Condition-Based Cancelation","text":"<p>Cancel when custom conditions are met.</p>"},{"location":"examples/basic/#resource-monitoring","title":"Resource Monitoring","text":"<pre><code>import shutil\nfrom hother.cancelable import ConditionSource, Cancelable\n\ndef disk_full():\n    \"\"\"Check if disk usage exceeds 95%.\"\"\"\n    usage = shutil.disk_usage(\"/\")\n    return (usage.used / usage.total) &gt; 0.95\n\nasync def main():\n    # Check disk every 5 seconds\n    async with Cancelable(\n        sources=[ConditionSource(\n            predicate=disk_full,\n            check_interval=5.0,\n            description=\"Disk space monitor\"\n        )],\n        name=\"file_processor\"\n    ) as cancel:\n        await process_large_files()\n\nanyio.run(main)\n</code></pre>"},{"location":"examples/basic/#custom-business-logic","title":"Custom Business Logic","text":"<pre><code>class JobController:\n    def __init__(self):\n        self.should_stop = False\n\n    def check_stop_flag(self):\n        return self.should_stop\n\ncontroller = JobController()\n\nasync def run_job():\n    async with Cancelable(\n        sources=[ConditionSource(\n            predicate=controller.check_stop_flag,\n            check_interval=1.0\n        )],\n        name=\"background_job\"\n    ) as cancel:\n        await process_job()\n\n# Stop job from API endpoint\n@app.post(\"/jobs/stop\")\nasync def stop_job():\n    controller.should_stop = True\n    return {\"status\": \"stopping\"}\n</code></pre> <p>Run it: </p><pre><code>python examples/02_advanced/07_condition_cancelation.py\n</code></pre><p></p>"},{"location":"examples/basic/#combined-cancelation","title":"Combined Cancelation","text":"<p>Compose multiple sources - cancels on FIRST trigger.</p>"},{"location":"examples/basic/#timeout-manual-signal","title":"Timeout + Manual + Signal","text":"<pre><code>    # Example: Multiple cancelation sources combined\n\n    # Create multiple cancelation sources\n    token = CancelationToken()\n    print(f\"Created manual token: {token.id}\")\n\n    # Create individual cancelables with logging\n    timeout_cancellable = Cancelable.with_timeout(10.0)\n    print(f\"Created timeout cancelable: {timeout_cancellable.context.id} with token {timeout_cancellable.token.id}\")\n\n    token_cancellable = Cancelable.with_token(token)\n    print(f\"Created token cancelable: {token_cancellable.context.id} with token {token_cancellable.token.id}\")\n\n    signal_cancellable = Cancelable.with_signal(signal.SIGINT)\n    print(f\"Created signal cancelable: {signal_cancellable.context.id} with token {signal_cancellable.token.id}\")\n\n    # Combine them step by step with logging\n    print(\"=== COMBINING STEP 1: timeout + token ===\")\n    first_combine = timeout_cancellable.combine(token_cancellable)\n    print(f\"First combine result: {first_combine.context.id} with token {first_combine.token.id}\")\n\n    print(\"=== COMBINING STEP 2: (timeout+token) + signal ===\")\n    final_cancellable = first_combine.combine(signal_cancellable)\n    print(f\"Final combine result: {final_cancellable.context.id} with token {final_cancellable.token.id}\")\n\n    print(f\"Final combined cancelable: {final_cancellable.context.id}\")\n    print(f\"Final combined cancelable token: {final_cancellable.token.id}\")\n\n    final_cancellable.on_cancel(\n        lambda ctx: print(\n            f\"  Cancelled: {ctx.cancel_reason.value if ctx.cancel_reason else 'unknown'} - {ctx.cancel_message or 'no message'}\"\n        )\n    )\n\n    print(\"  Press Ctrl+C to cancel, or wait for timeout/manual cancel...\")\n    try:\n        async with final_cancellable:\n            # Simulate work\n            for i in range(20):\n                await asyncio.sleep(SLEEP_DURATION)\n                print(f\"  Working... {i + 1}/20\")\n\n                # Manual cancel after 3 seconds\n                if i == 6 * SLEEP_DURATION:\n                    print(\"  Triggering manual cancelation...\")\n                    print(f\"About to cancel token: {token.id}\")\n                    await token.cancel(message=\"Demonstration cancel\")\n                    print(\"Token cancel call completed\")\n    except asyncio.CancelledError:\n        print(\"  Operation was cancelled\")\n        print(\n            f\"  Reason: {final_cancellable.context.cancel_reason.value if final_cancellable.context.cancel_reason else 'unknown'}\"\n        )\n        print(f\"  Message: {final_cancellable.context.cancel_message or 'no message'}\")\n</code></pre> <p>Run it: </p><pre><code>python examples/02_advanced/01_combined_cancelation.py\n</code></pre><p></p>"},{"location":"examples/basic/#all-sources-combined","title":"All Sources Combined","text":"<pre><code>from hother.cancelable import TimeoutSource, SignalSource, ConditionSource\n\nasync def comprehensive_example():\n    token = CancelationToken()\n\n    async with Cancelable.combine([\n        TimeoutSource(600.0),                    # 10 min timeout\n        SignalSource(signal.SIGTERM, signal.SIGINT),\n        token,                                    # Manual\n        ConditionSource(disk_full, 5.0)          # Disk space\n    ], name=\"robust_operation\") as cancel:\n        # Cancels on FIRST trigger from ANY source\n        await operation()\n</code></pre>"},{"location":"examples/basic/#hierarchical-operations","title":"Hierarchical Operations","text":"<p>Parent-child relationships with automatic propagation.</p>"},{"location":"examples/basic/#basic-hierarchy","title":"Basic Hierarchy","text":"<pre><code>async def parent_task():\n    async with Cancelable(name=\"parent\") as parent:\n        print(\"Parent started\")\n\n        # Child 1\n        async with Cancelable(name=\"child_1\", parent=parent) as child1:\n            print(\"Child 1 working\")\n            await anyio.sleep(1)\n\n        # Child 2\n        async with Cancelable(name=\"child_2\", parent=parent) as child2:\n            print(\"Child 2 working\")\n            await anyio.sleep(1)\n\n        # If parent cancels, ALL children auto-cancel!\n        print(\"Parent complete\")\n</code></pre>"},{"location":"examples/basic/#timeout-propagation","title":"Timeout Propagation","text":"<pre><code># Parent has 10s timeout\nasync with Cancelable.with_timeout(10.0, name=\"parent\") as parent:\n\n    # Children inherit cancelation (but can have their own)\n    async with Cancelable(name=\"quick_task\", parent=parent) as child1:\n        await quick_operation()  # Must finish before parent timeout\n\n    async with Cancelable(name=\"slow_task\", parent=parent) as child2:\n        await slow_operation()  # Cancelled if parent times out\n</code></pre>"},{"location":"examples/basic/#decorated-functions","title":"Decorated Functions","text":"<p>Apply cancelation to functions with decorators.</p>"},{"location":"examples/basic/#complete-example","title":"Complete Example","text":"<p>The <code>@cancelable</code> decorator makes it easy to add cancelation to any function:</p> <pre><code>    # Example: Using decorators\n\n    try:\n        # This will complete\n        result = await slow_operation(1.5)\n        print(f\"  Result: {result}\")\n\n        # This will timeout\n        result = await slow_operation(3.0)\n        print(f\"  Result: {result}\")\n\n    except anyio.get_cancelled_exc_class():\n        print(\"  Operation was cancelled!\")\n</code></pre> <p>Run it: </p><pre><code>python examples/01_basics/04_decorated_functions.py\n</code></pre><p></p>"},{"location":"examples/basic/#best-practices","title":"Best Practices","text":""},{"location":"examples/basic/#do","title":"\u2705 Do","text":"<ul> <li>Name your operations for better debugging</li> <li>Handle cancelation exceptions gracefully</li> <li>Use shields for critical cleanup</li> <li>Combine sources for robust cancelation</li> <li>Start simple - timeout only, then add more</li> </ul>"},{"location":"examples/basic/#dont","title":"\u274c Don't","text":"<ul> <li>Don't ignore cancelation - it indicates important state</li> <li>Don't shield entire operations - only cleanup sections</li> <li>Don't use very short check intervals (&lt; 0.1s) for ConditionSource</li> <li>Don't forget platform limits for signal handling</li> </ul>"},{"location":"examples/basic/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/basic/#api-call-with-timeout","title":"API Call with Timeout","text":"<pre><code>async def fetch_data(url: str):\n    async with Cancelable.with_timeout(30.0, name=f\"fetch_{url}\") as cancel:\n        response = await http_client.get(url)\n        return response.json()\n</code></pre>"},{"location":"examples/basic/#background-task-with-cancel-button","title":"Background Task with Cancel Button","text":"<pre><code># Global token for UI cancel button\njob_token = CancelationToken()\n\n@app.post(\"/cancel\")\nasync def cancel_job():\n    await job_token.cancel(\"User clicked cancel\")\n\nasync def background_job():\n    async with Cancelable.with_token(job_token) as cancel:\n        await process_job()\n</code></pre>"},{"location":"examples/basic/#cli-tool-with-ctrlc","title":"CLI Tool with Ctrl+C","text":"<pre><code>import signal\n\nasync def cli_tool():\n    async with Cancelable.with_signal(signal.SIGINT) as cancel:\n        try:\n            await process_files()\n        finally:\n            async with cancel.shield():\n                await save_progress()\n</code></pre>"},{"location":"examples/basic/#next-steps","title":"Next Steps","text":"<ul> <li>Explore Stream Processing - Handle async streams</li> <li>Learn Web Applications - FastAPI integration</li> <li>Read Core Concepts - Understand the fundamentals</li> <li>Try Advanced Patterns - Production patterns</li> </ul>"},{"location":"examples/llm/","title":"LLM Integration","text":""},{"location":"examples/llm/#llm-integration-examples","title":"LLM Integration Examples","text":"<p>Integrate Cancelable with Large Language Model streaming operations.</p> <p>Find the complete source in <code>examples/06_llm/</code>.</p>"},{"location":"examples/llm/#llm-streaming-with-pauseresume","title":"LLM Streaming with Pause/Resume","text":"<p>Stream AI responses with user and AI-initiated cancelation.</p>"},{"location":"examples/llm/#features","title":"Features","text":"<ul> <li>Keyboard Control - Press SPACE to pause/resume streaming</li> <li>LLM-Initiated Pause - AI signals when to pause with special markers</li> <li>Context Preservation - Resume from exact position</li> <li>CancelationToken Integration - Clean cancelation handling</li> </ul>"},{"location":"examples/llm/#example","title":"Example","text":"<pre><code>from hother.cancelable import CancelationToken\n\ntoken = CancelationToken()\n\nasync def stream_llm():\n    async with Cancelable.with_token(token) as cancel:\n        async for chunk in llm_client.stream(prompt):\n            # Check for pause markers\n            if '!!CANCEL' in chunk:\n                token.cancel_sync(message=\"LLM initiated pause\")\n                break\n\n            print(chunk, end='', flush=True)\n</code></pre> <p>Run it: </p><pre><code>GEMINI_API_KEY=\"your-key\" python examples/06_llm/01_llm_streaming.py\n</code></pre><p></p>"},{"location":"examples/llm/#use-cases","title":"Use Cases","text":"<ul> <li>Interactive Tutorials - LLM pauses for user to try examples</li> <li>Content Generation - User controls output generation</li> <li>Cost Control - Stop expensive API calls</li> <li>Reasoning Steps - AI pauses between thinking steps</li> </ul>"},{"location":"examples/llm/#requirements","title":"Requirements","text":"uvpip <pre><code>uv add google-genai pynput  # For Google GenAI example\n</code></pre> <pre><code>pip install google-genai pynput  # For Google GenAI example\n</code></pre>"},{"location":"examples/llm/#next-steps","title":"Next Steps","text":"<ul> <li>Review Basic Patterns - Fundamental cancelation</li> <li>Explore Web Applications - API integration</li> <li>See Stream Processing - Async stream handling</li> </ul>"},{"location":"examples/monitoring/","title":"Monitoring Dashboard","text":""},{"location":"examples/monitoring/#monitoring-dashboard-examples","title":"Monitoring Dashboard Examples","text":"<p>Build real-time monitoring and observability.</p> <p>Find the complete source in <code>examples/05_monitoring/</code>.</p>"},{"location":"examples/monitoring/#real-time-dashboard","title":"Real-Time Dashboard","text":"<p>Monitor all active cancelable operations.</p>"},{"location":"examples/monitoring/#basic-dashboard","title":"Basic Dashboard","text":"<pre><code>from hother.cancelable import OperationRegistry\nfrom rich.console import Console\nfrom rich.table import Table\n\nasync def display_dashboard():\n    console = Console()\n    registry = OperationRegistry.get_instance()\n\n    while True:\n        console.clear()\n\n        table = Table(title=\"Active Operations\")\n        table.add_column(\"Operation\")\n        table.add_column(\"Status\")\n        table.add_column(\"Progress\")\n        table.add_column(\"Elapsed\")\n\n        for op in registry.get_active_operations():\n            table.add_row(\n                op.name,\n                op.status.value,\n                f\"{op.progress:.1f}%\",\n                f\"{op.elapsed_time:.1f}s\"\n            )\n\n        console.print(table)\n        await anyio.sleep(1.0)\n</code></pre> <p>Run it: </p><pre><code>python examples/05_monitoring/01_monitoring_dashboard.py\n</code></pre><p></p>"},{"location":"examples/monitoring/#progress-tracking","title":"Progress Tracking","text":"<p>Report and visualize operation progress:</p> <pre><code>async with Cancelable(name=\"processor\") as cancel:\n    cancel.on_progress(\n        lambda op, msg, meta: update_dashboard(op, meta)\n    )\n\n    for i, item in enumerate(items):\n        await process_item(item)\n        await cancel.report_progress(\n            f\"Processed {i}/{len(items)}\",\n            {\"progress\": (i / len(items)) * 100}\n        )\n</code></pre>"},{"location":"examples/monitoring/#alert-system","title":"Alert System","text":"<p>Detect and alert on stuck operations:</p> <pre><code>async def monitor_for_alerts():\n    registry = OperationRegistry.get_instance()\n\n    while True:\n        for op in registry.get_active_operations():\n            if op.elapsed_time &gt; 300:  # 5 minutes\n                await send_alert(f\"Long-running: {op.name}\")\n\n        await anyio.sleep(60)\n</code></pre>"},{"location":"examples/monitoring/#metrics-export","title":"Metrics Export","text":"<p>Export to Prometheus, Datadog, etc:</p> <pre><code>def export_metrics():\n    registry = OperationRegistry.get_instance()\n    active = registry.get_active_operations()\n\n    return {\n        \"active_operations\": len(active),\n        \"longest_running\": max((op.elapsed_time for op in active), default=0)\n    }\n</code></pre>"},{"location":"examples/monitoring/#use-cases","title":"Use Cases","text":"<ul> <li>Production operation monitoring</li> <li>Dashboard visualization</li> <li>Alert systems for stuck operations</li> <li>Metrics export to observability platforms</li> </ul>"},{"location":"examples/monitoring/#next-steps","title":"Next Steps","text":"<ul> <li>Learn Operation Registry - Registry details</li> <li>See Advanced Usage - Progress patterns</li> <li>Read Advanced Patterns - Production monitoring</li> </ul>"},{"location":"examples/setup/","title":"Setup","text":""},{"location":"examples/setup/#setup","title":"Setup","text":"<p>Here we include some examples of how to use Cancelable and what it can do.</p>"},{"location":"examples/setup/#installation","title":"Installation","text":"<p>Install Cancelable with the examples dependencies:</p> uvpip <pre><code>uv add \"hother-cancelable[examples]\"\n</code></pre> <pre><code>pip install \"hother-cancelable[examples]\"\n</code></pre> <p>This installs the core library plus dependencies for running all examples:</p> <ul> <li><code>google-genai</code> - For LLM streaming examples</li> <li><code>pynput</code> - For keyboard input monitoring</li> <li><code>psutil</code> - For system resource monitoring</li> </ul>"},{"location":"examples/setup/#getting-the-examples","title":"Getting the Examples","text":"<p>The examples are available in the GitHub repository.</p> uvpip <pre><code># Clone the repository\ngit clone https://github.com/hotherio/cancelable.git\ncd cancelable\n\n# Install all dependencies\nuv sync\n</code></pre> <pre><code># Clone the repository\ngit clone https://github.com/hotherio/cancelable.git\ncd cancelable\n\n# Create virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install dependencies\npip install -e \".[examples]\"\n</code></pre>"},{"location":"examples/setup/#running-examples","title":"Running Examples","text":"<p>Navigate to the examples directory and run any example:</p> <pre><code>cd examples\n\n# Basic examples\nuv run python 01_basics/01_basic_cancelation.py\n</code></pre>"},{"location":"examples/setup/#optional-dependencies","title":"Optional Dependencies","text":"<p>Different examples require different integration libraries. Install only what you need:</p>"},{"location":"examples/setup/#web-framework-fastapi","title":"Web Framework (FastAPI)","text":"<p>For FastAPI examples:</p> uvpip <pre><code>uv add \"hother-cancelable[fastapi]\"\n</code></pre> <pre><code>pip install \"hother-cancelable[fastapi]\"\n</code></pre> <p>Examples requiring this: - <code>03_integrations/04_fastapi_example.py</code></p>"},{"location":"examples/setup/#all-integrations","title":"All Integrations","text":"<p>Install everything at once:</p> uvpip <pre><code>uv add \"hother-cancelable[fastapi,examples]\"\n</code></pre> <pre><code>pip install \"hother-cancelable[fastapi,examples]\"\n</code></pre>"},{"location":"examples/setup/#environment-variables","title":"Environment Variables","text":"<p>Some examples require API keys or configuration:</p>"},{"location":"examples/setup/#llm-examples","title":"LLM Examples","text":"<p>The LLM streaming example requires a Gemini API key:</p> <pre><code># Get your API key from https://aistudio.google.com/app/apikey\nexport GEMINI_API_KEY=\"your-api-key-here\"\n\n# Run the LLM example\npython 06_llm/01_llm_streaming.py\n</code></pre> <p>API Key Required</p> <p>Without a valid API key, the LLM examples will fail. All other examples work without any API keys.</p>"},{"location":"examples/streams/","title":"Stream Processing","text":""},{"location":"examples/streams/#stream-processing-examples","title":"Stream Processing Examples","text":"<p>Handle async streams with cancelation and backpressure.</p> <p>Find the complete source in <code>examples/04_streams/</code>.</p>"},{"location":"examples/streams/#cancelable-stream-processing","title":"Cancelable Stream Processing","text":"<p>Process async streams with automatic cancelation support.</p>"},{"location":"examples/streams/#basic-stream-processing","title":"Basic Stream Processing","text":"<pre><code>from hother.cancelable import cancelable_stream, Cancelable\n\nasync def process_stream():\n    async with Cancelable.with_timeout(60.0) as cancel:\n        async for item in cancelable_stream(data_stream, cancel):\n            await process_item(item)\n            # Stream automatically stops on cancelation\n</code></pre> <p>Run it: </p><pre><code>python examples/04_streams/01_stream_processing.py\n</code></pre><p></p>"},{"location":"examples/streams/#features","title":"Features","text":"<ul> <li>Backpressure Handling - Buffer management for fast producers</li> <li>Progress Reporting - Track stream processing progress</li> <li>Chunked Processing - Process in batches with cancelation</li> <li>Transform &amp; Filter - Streaming transformations</li> </ul>"},{"location":"examples/streams/#use-cases","title":"Use Cases","text":"<ul> <li>Data pipelines with timeout protection</li> <li>ETL operations with progress tracking</li> <li>Real-time data processing</li> <li>Event stream handling</li> </ul>"},{"location":"examples/streams/#next-steps","title":"Next Steps","text":"<ul> <li>Learn Basic Patterns - Cancelation fundamentals</li> <li>Read Core Concepts - Stream processing details</li> </ul>"},{"location":"examples/web/","title":"Web Applications","text":""},{"location":"examples/web/#web-application-examples","title":"Web Application Examples","text":"<p>Integrate Cancelable with web frameworks like FastAPI.</p> <p>Find the complete source in <code>examples/03_integrations/</code>.</p>"},{"location":"examples/web/#fastapi-request-scoped-cancelation","title":"FastAPI Request-Scoped Cancelation","text":"<p>Automatically cancel operations when clients disconnect.</p>"},{"location":"examples/web/#basic-integration","title":"Basic Integration","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom hother.cancelable.integrations.fastapi import cancelable_dependency\n\napp = FastAPI()\n\n@app.get(\"/process\")\nasync def process_data(cancel: Cancelable = Depends(cancelable_dependency)):\n    async with cancel:\n        # Automatically cancelled on client disconnect\n        result = await heavy_computation()\n        return result\n</code></pre> <p>Run it: </p><pre><code>python examples/03_integrations/04_fastapi_example.py\n</code></pre><p></p>"},{"location":"examples/web/#background-tasks","title":"Background Tasks","text":"<pre><code>from hother.cancelable import CancelationToken\n\njob_tokens = {}\n\n@app.post(\"/jobs\")\nasync def start_job():\n    job_id = str(uuid.uuid4())\n    token = CancelationToken()\n    job_tokens[job_id] = token\n\n    asyncio.create_task(run_job(token))\n    return {\"job_id\": job_id}\n\n@app.delete(\"/jobs/{job_id}\")\nasync def cancel_job(job_id: str):\n    if job_id in job_tokens:\n        await job_tokens[job_id].cancel(\"User cancelled\")\n    return {\"status\": \"cancelled\"}\n</code></pre>"},{"location":"examples/web/#websocket-streaming","title":"WebSocket Streaming","text":"<p>Real-time data streaming with cancelation:</p> <pre><code>@app.websocket(\"/stream\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n\n    async with Cancelable(name=\"websocket_stream\") as cancel:\n        try:\n            async for data in data_stream:\n                await websocket.send_json(data)\n        except WebSocketDisconnect:\n            # Client disconnected\n            pass\n</code></pre>"},{"location":"examples/web/#use-cases","title":"Use Cases","text":"<ul> <li>Long-running API requests with timeouts</li> <li>Background job systems with cancel buttons</li> <li>WebSocket streaming with disconnect handling</li> <li>Request-level timeout protection</li> </ul>"},{"location":"examples/web/#next-steps","title":"Next Steps","text":"<ul> <li>Read FastAPI Guide - Detailed integration</li> </ul>"},{"location":"integrations/","title":"Overview","text":""},{"location":"integrations/#integrations","title":"Integrations","text":"<p>Framework-specific guides for integrating Cancelable.</p>"},{"location":"integrations/#available-integrations","title":"Available Integrations","text":"<p>Cancelable provides first-class integration with popular async frameworks:</p>"},{"location":"integrations/#fastapi","title":"FastAPI","text":"<p>Web framework integration with request-scoped cancelation.</p> <p>Features:</p> <ul> <li>Automatic cancelation on client disconnect</li> <li>Request-scoped operation tracking</li> <li>Dependency injection support</li> <li>Background task management</li> </ul> <p>Quick Example:</p> <pre><code>from fastapi import FastAPI, Depends\nfrom hother.cancelable.integrations.fastapi import cancelable_dependency\n\napp = FastAPI()\n\n@app.get(\"/process\")\nasync def process(cancel: Cancelable = Depends(cancelable_dependency)):\n    async with cancel:\n        return await heavy_computation()\n</code></pre> <p>Read FastAPI Guide \u2192</p>"},{"location":"integrations/#future-integrations","title":"Future Integrations","text":"<p>Planning to add:</p> <ul> <li>Django (async views)</li> <li>Starlette</li> <li>aiohttp</li> <li>Redis (aioredis)</li> <li>Celery</li> </ul> <p>Want to see an integration? Open an issue!</p>"},{"location":"integrations/#next-steps","title":"Next Steps","text":"<ul> <li>Explore FastAPI Integration - Web APIs</li> <li>Browse Examples - Integration examples</li> </ul>"},{"location":"integrations/fastapi/","title":"FastAPI","text":""},{"location":"integrations/fastapi/#fastapi-integration","title":"FastAPI Integration","text":"<p>The cancelable library provides seamless integration with FastAPI for building cancelable endpoints.</p>"},{"location":"integrations/fastapi/#installation","title":"Installation","text":"<p>The FastAPI integration is included when you install cancelable:</p> uvpip <pre><code>uv add hother-cancelable\n</code></pre> <pre><code>pip install hother-cancelable\n</code></pre>"},{"location":"integrations/fastapi/#basic-usage","title":"Basic Usage","text":""},{"location":"integrations/fastapi/#dependency-injection","title":"Dependency Injection","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom hother.cancelable.integrations.fastapi import cancelable_dependency\nfrom hother.cancelable import Cancelable\n\napp = FastAPI()\n\n@app.get(\"/long-operation\")\nasync def long_operation(cancel: Cancelable = Depends(cancelable_dependency)):\n    async with cancel:\n        # Your long-running operation here\n        result = await process_data()\n        return {\"result\": result}\n</code></pre>"},{"location":"integrations/fastapi/#timeout-configuration","title":"Timeout Configuration","text":"<pre><code>from hother.cancelable.integrations.fastapi import cancelable_dependency\n\n# Create a custom dependency with timeout\ndef get_cancelable_30s():\n    return cancelable_dependency(timeout=30.0)\n\n@app.get(\"/timeout-operation\")\nasync def timeout_operation(cancel: Cancelable = Depends(get_cancelable_30s)):\n    async with cancel:\n        # This operation will timeout after 30 seconds\n        return await long_computation()\n</code></pre>"},{"location":"integrations/fastapi/#advanced-usage","title":"Advanced Usage","text":""},{"location":"integrations/fastapi/#background-tasks-with-cancelation","title":"Background Tasks with Cancelation","text":"<pre><code>from fastapi import BackgroundTasks\nfrom hother.cancelable import CancelationToken\n\n# Store tokens for background tasks\nbackground_tokens = {}\n\n@app.post(\"/start-background-task\")\nasync def start_background_task(background_tasks: BackgroundTasks):\n    token = CancelationToken()\n    task_id = str(uuid.uuid4())\n    background_tokens[task_id] = token\n\n    background_tasks.add_task(\n        background_worker,\n        task_id,\n        token\n    )\n\n    return {\"task_id\": task_id}\n\nasync def background_worker(task_id: str, token: CancelationToken):\n    async with Cancelable.with_token(token) as cancel:\n        try:\n            # Long-running background work\n            await process_large_dataset()\n        finally:\n            # Cleanup\n            background_tokens.pop(task_id, None)\n\n@app.post(\"/cancel-task/{task_id}\")\nasync def cancel_task(task_id: str):\n    token = background_tokens.get(task_id)\n    if token:\n        await token.cancel()\n        return {\"status\": \"cancelled\"}\n    return {\"status\": \"not_found\"}\n</code></pre>"},{"location":"integrations/fastapi/#request-cancelation-handling","title":"Request Cancelation Handling","text":"<pre><code>from starlette.requests import Request\n\n@app.get(\"/streaming-response\")\nasync def streaming_response(\n    request: Request,\n    cancel: Cancelable = Depends(cancelable_dependency)\n):\n    async def generate():\n        async with cancel:\n            for i in range(100):\n                # Check if client disconnected\n                if await request.is_disconnected():\n                    await cancel.cancel()\n                    break\n\n                yield f\"data: Item {i}\\n\\n\"\n                await asyncio.sleep(0.1)\n\n    return StreamingResponse(\n        generate(),\n        media_type=\"text/event-stream\"\n    )\n</code></pre>"},{"location":"integrations/fastapi/#best-practices","title":"Best Practices","text":"<ol> <li>Always use async with: Ensure proper cleanup by using the context manager</li> <li>Set appropriate timeouts: Configure timeouts based on expected operation duration</li> <li>Handle cancelation gracefully: Catch CancelledError and perform cleanup</li> <li>Monitor operations: Use the global registry for debugging and monitoring</li> </ol>"},{"location":"integrations/fastapi/#example-file-upload-with-progress","title":"Example: File Upload with Progress","text":"<pre><code>from hother.cancelable import Cancelable\nfrom fastapi import UploadFile, File\n\n@app.post(\"/upload\")\nasync def upload_file(\n    file: UploadFile = File(...),\n    cancel: Cancelable = Depends(cancelable_dependency)\n):\n    async with cancel:\n        cancel.on_progress(\n            lambda op_id, msg, meta: logger.info(f\"Upload progress: {msg}\")\n        )\n\n        total_size = 0\n        chunk_size = 1024 * 1024  # 1MB chunks\n\n        with open(f\"uploads/{file.filename}\", \"wb\") as f:\n            while chunk := await file.read(chunk_size):\n                f.write(chunk)\n                total_size += len(chunk)\n\n                await cancel.report_progress(\n                    f\"Uploaded {total_size} bytes\",\n                    {\"bytes\": total_size, \"filename\": file.filename}\n                )\n\n        return {\n            \"filename\": file.filename,\n            \"size\": total_size,\n            \"status\": \"completed\"\n        }\n</code></pre>"},{"location":"integrations/fastapi/#error-handling","title":"Error Handling","text":"<pre><code>from hother.cancelable import TimeoutCancelation\n\n@app.get(\"/with-error-handling\")\nasync def with_error_handling(cancel: Cancelable = Depends(cancelable_dependency)):\n    try:\n        async with cancel:\n            result = await some_operation()\n            return {\"result\": result}\n    except TimeoutCancelation:\n        return JSONResponse(\n            status_code=408,\n            content={\"error\": \"Operation timed out\"}\n        )\n    except Exception as e:\n        return JSONResponse(\n            status_code=500,\n            content={\"error\": str(e)}\n        )\n</code></pre>"},{"location":"integrations/fastapi/#middleware","title":"Middleware","text":""},{"location":"integrations/fastapi/#requestcancelationmiddleware","title":"RequestCancelationMiddleware","text":"<p>ASGI middleware for automatic request cancelation monitoring:</p> <pre><code>from fastapi import FastAPI\nfrom hother.cancelable.integrations.fastapi import RequestCancelationMiddleware\n\napp = FastAPI()\n\n# Add middleware\napp.add_middleware(RequestCancelationMiddleware)\n\n@app.post(\"/process\")\nasync def process_data(data: dict):\n    # Automatically cancels if client disconnects\n    # No need for manual cancelable_dependency\n    async with Cancelable(name=\"process\") as cancel:\n        result = await long_operation(data)\n        return {\"result\": result}\n</code></pre> <p>Benefits: - Automatic client disconnect detection - Application-wide cancelation monitoring - No per-endpoint setup needed</p>"},{"location":"integrations/fastapi/#websocket-support","title":"WebSocket Support","text":""},{"location":"integrations/fastapi/#cancelablewebsocket","title":"CancelableWebSocket","text":"<p>WebSocket wrapper with built-in cancelation support:</p> <pre><code>from fastapi import WebSocket\nfrom hother.cancelable.integrations.fastapi import CancelableWebSocket\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n\n    async with Cancelable.with_timeout(300.0) as cancel:\n        ws = CancelableWebSocket(websocket, cancel)\n\n        # Send with cancelation checking\n        await ws.send_json({\"status\": \"connected\"})\n\n        # Receive with cancelation checking\n        while True:\n            data = await ws.receive_json()\n\n            # Report progress\n            await cancel.report_progress(f\"Received from {client_id}\")\n\n            response = await process(data)\n            await ws.send_json(response)\n</code></pre> <p>Methods: - <code>send_text(data)</code>, <code>send_json(data)</code> - Send with cancelation check - <code>receive_text()</code>, <code>receive_json()</code> - Receive with cancelation check - Auto-integrates with progress reporting</p>"},{"location":"integrations/fastapi/#sse-streaming","title":"SSE Streaming","text":""},{"location":"integrations/fastapi/#cancelable_streaming_response","title":"cancelable_streaming_response()","text":"<p>Create Server-Sent Events (SSE) streaming responses with cancelation:</p> <pre><code>from hother.cancelable.integrations.fastapi import cancelable_streaming_response\n\n@app.get(\"/stream/progress/{job_id}\")\nasync def stream_progress(job_id: str):\n    async def generate():\n        async with Cancelable(name=f\"stream_{job_id}\") as cancel:\n            for i in range(100):\n                # Checks cancelation before each event\n                yield f\"data: Processing {i}/100\\n\\n\"\n                await anyio.sleep(0.5)\n\n    return cancelable_streaming_response(generate())\n</code></pre> <p>Features: - SSE format support - Automatic cancelation checking - Graceful stream termination - Client disconnect handling</p>"},{"location":"integrations/fastapi/#exception-handling","title":"Exception Handling","text":""},{"location":"integrations/fastapi/#with_cancelation-decorator","title":"with_cancelation Decorator","text":"<p>Automatic exception handling for FastAPI endpoints:</p> <pre><code>from hother.cancelable.integrations.fastapi import with_cancelation\n\n@app.post(\"/process\")\n@with_cancelation  # Converts cancelation to proper HTTP status\nasync def process_data(data: dict):\n    async with Cancelable.with_timeout(30.0) as cancel:\n        result = await long_operation(data)\n        return {\"result\": result}\n\n# If cancelled: automatically returns HTTP 499 (Client Closed Request)\n# If timeout: automatically returns HTTP 504 (Gateway Timeout)\n</code></pre> <p>HTTP status codes: - <code>CancelationReason.TIMEOUT</code> \u2192 504 Gateway Timeout - <code>CancelationReason.MANUAL</code> \u2192 499 Client Closed Request - <code>CancelationReason.SIGNAL</code> \u2192 503 Service Unavailable - Other \u2192 500 Internal Server Error</p>"},{"location":"integrations/tenacity/","title":"Tenacity (Retry)","text":""},{"location":"integrations/tenacity/#tenacity-integration","title":"Tenacity Integration","text":"<p>Integrate Tenacity, the powerful retry library for Python, with Cancelable to add cancelation-aware retry logic to your applications.</p>"},{"location":"integrations/tenacity/#why-use-cancelable-with-tenacity","title":"Why Use Cancelable with Tenacity?","text":"<p>Tenacity provides excellent retry logic (exponential backoff, wait strategies, retry predicates), but it can't cancel retries from outside the retry loop.</p> <p>Consider these scenarios that Tenacity alone can't handle:</p> <ul> <li>User logs out \u2192 Cancel their background retry operations</li> <li>Client disconnects (FastAPI) \u2192 Stop retrying API call</li> <li>SIGTERM received \u2192 Gracefully stop all retry loops</li> <li>Circuit breaker opens \u2192 Stop retries based on external state</li> <li>GUI \"Cancel\" button clicked \u2192 Stop retry from different thread</li> <li>Parent operation cancelled \u2192 Cancel all child retry operations</li> </ul> <p>Use Tenacity for retry logic. Use Cancelable for cancelation logic.</p>"},{"location":"integrations/tenacity/#installation","title":"Installation","text":"<p>Install Tenacity alongside Cancelable:</p> uvpip <pre><code>uv add tenacity\nuv add hother-cancelable\n</code></pre> <pre><code>pip install tenacity\npip install hother-cancelable\n</code></pre>"},{"location":"integrations/tenacity/#quick-start","title":"Quick Start","text":""},{"location":"integrations/tenacity/#multiple-cancelation-sources","title":"Multiple Cancelation Sources","text":"<p>Here's what makes the integration powerful - combining sources Tenacity doesn't support:</p> <pre><code>import signal\nfrom tenacity import AsyncRetrying, stop_after_attempt, wait_exponential\nfrom hother.cancelable import Cancelable, CancelationToken\n\n# Create cancelation token for manual control\ntoken = CancelationToken()\n\nasync def fetch_data_with_retry(url: str):\n    # Combine multiple cancelation sources\n    cancel = Cancelable.with_timeout(60)  # Overall 60s timeout\n    cancel = cancel.combine(\n        Cancelable.with_token(token),          # Manual cancel (user action)\n        Cancelable.with_signal(signal.SIGINT) # Graceful shutdown (Ctrl+C)\n    )\n\n    async with cancel:\n        wrapped_fetch = cancel.wrap(fetch_data)\n\n        # Tenacity handles retry logic\n        async for attempt in AsyncRetrying(\n            stop=stop_after_attempt(5),\n            wait=wait_exponential(min=2, max=30)\n        ):\n            with attempt:\n                # Checks ALL cancelation sources before each attempt\n                result = await wrapped_fetch(url)\n                return result\n\n# Later: cancel from another task or thread\nawait token.cancel(\"User clicked cancel button\")\n# Or from sync context: token.cancel_sync(\"User logged out\")\n</code></pre> <p>This gives you:</p> <ul> <li>\u23f1\ufe0f Timeout protection (60s max)</li> <li>\ud83d\uded1 Manual cancelation (user control)</li> <li>\ud83d\udce1 Signal handling (graceful shutdown)</li> <li>\ud83d\udd04 Smart retries (Tenacity's exponential backoff)</li> </ul>"},{"location":"integrations/tenacity/#use-cases","title":"Use Cases","text":""},{"location":"integrations/tenacity/#1-fastapi-client-disconnect","title":"1. FastAPI: Client Disconnect","text":"<p>Problem: Client closes browser while retry loop is running. Continue retrying?</p> <p>Solution: Bind retry loop to request lifecycle:</p> <pre><code>from fastapi import FastAPI, Request, Depends\nfrom hother.cancelable.integrations.fastapi import cancelable_dependency\nfrom tenacity import AsyncRetrying, stop_after_attempt, wait_fixed\n\napp = FastAPI()\n\n@app.post(\"/process\")\nasync def process_data(\n    request: Request,\n    cancel: Cancelable = Depends(cancelable_dependency)  # (1)!\n):\n    \"\"\"Retries automatically stop when client disconnects.\"\"\"\n    async with cancel:  # (2)!\n        wrapped_process = cancel.wrap(expensive_operation)\n\n        async for attempt in AsyncRetrying(\n            stop=stop_after_attempt(10),\n            wait=wait_fixed(2)\n        ):\n            with attempt:\n                await cancel.report_progress(\n                    f\"Attempt {attempt.retry_state.attempt_number}/10\"\n                )\n                result = await wrapped_process(request.data)\n                return {\"result\": result}\n</code></pre> <ol> <li>FastAPI dependency provides cancelable that watches client disconnect</li> <li>Retries stop immediately when client closes connection</li> </ol> <p>Why this matters: Saves compute resources on abandoned requests</p>"},{"location":"integrations/tenacity/#2-signal-handling-graceful-shutdown","title":"2. Signal Handling: Graceful Shutdown","text":"<p>Problem: SIGTERM received, need to stop all retry loops gracefully</p> <p>Solution: Bind retry loops to signal handler:</p> <pre><code>import signal\nfrom tenacity import AsyncRetrying, stop_after_attempt\nfrom hother.cancelable import Cancelable\n\nasync def background_worker():\n    \"\"\"Worker that stops gracefully on SIGTERM.\"\"\"\n    cancel = Cancelable.with_signal(signal.SIGTERM, signal.SIGINT)\n\n    async with cancel:\n        wrapped_task = cancel.wrap(process_task)\n\n        while True:  # (1)!\n            async for attempt in AsyncRetrying(stop=stop_after_attempt(3)):\n                with attempt:\n                    await wrapped_task()\n\n            await anyio.sleep(1)\n\n# Kubernetes sends SIGTERM \u2192 all retry loops stop \u2192 pod terminates gracefully\n</code></pre> <ol> <li>Outer loop continues until signal received, inner loop retries failed tasks</li> </ol> <p>Why this matters: Clean shutdown in containerized environments</p>"},{"location":"integrations/tenacity/#3-user-initiated-cancelation","title":"3. User-Initiated Cancelation","text":"<p>Problem: User starts long-running retry operation, then wants to cancel it</p> <p>Solution: Provide cancel button/API using token:</p> <pre><code>from tenacity import AsyncRetrying, stop_after_attempt\nfrom hother.cancelable import Cancelable, CancelationToken\n\n# Store tokens by user\nuser_operations: dict[str, CancelationToken] = {}\n\nasync def start_user_operation(user_id: str, data: list):\n    \"\"\"User starts a retrying background operation.\"\"\"\n    token = CancelationToken()\n    user_operations[user_id] = token  # Store for later cancel\n\n    async with Cancelable.with_token(token, name=f\"user_{user_id}\") as cancel:\n        wrapped_op = cancel.wrap(expensive_operation)\n\n        for item in data:\n            async for attempt in AsyncRetrying(stop=stop_after_attempt(5)):\n                with attempt:\n                    await wrapped_op(item)\n\nasync def cancel_user_operation(user_id: str):\n    \"\"\"User clicks 'Cancel' button.\"\"\"\n    if token := user_operations.get(user_id):\n        await token.cancel(f\"Cancelled by user {user_id}\")\n        del user_operations[user_id]\n</code></pre> <p>Why this matters: User control over long-running operations</p>"},{"location":"integrations/tenacity/#4-circuit-breaker-condition-based-cancelation","title":"4. Circuit Breaker: Condition-Based Cancelation","text":"<p>Problem: External service degraded, stop wasting retries</p> <p>Solution: Use condition source to monitor circuit breaker:</p> <pre><code>from tenacity import AsyncRetrying, stop_after_attempt, wait_exponential\nfrom hother.cancelable import Cancelable\n\nclass CircuitBreaker:\n    def __init__(self):\n        self.is_open = False\n        self.failure_count = 0\n\n    def record_failure(self):\n        self.failure_count += 1\n        if self.failure_count &gt;= 5:\n            self.is_open = True\n\n    def record_success(self):\n        self.failure_count = 0\n        self.is_open = False\n\nbreaker = CircuitBreaker()\n\nasync def api_call_with_circuit_breaker():\n    \"\"\"Stops retrying when circuit opens.\"\"\"\n    cancel = Cancelable.with_timeout(60)\n    cancel = cancel.combine(\n        Cancelable.with_condition(\n            lambda: breaker.is_open,  # (1)!\n            check_interval=0.5,\n            condition_name=\"circuit_open\"\n        )\n    )\n\n    async with cancel:\n        wrapped_call = cancel.wrap(external_api_call)\n\n        async for attempt in AsyncRetrying(\n            stop=stop_after_attempt(10),\n            wait=wait_exponential(min=1, max=30)\n        ):\n            with attempt:\n                try:\n                    result = await wrapped_call()\n                    breaker.record_success()\n                    return result\n                except Exception:\n                    breaker.record_failure()\n                    raise\n</code></pre> <ol> <li>Check condition every 500ms - cancel all retries if circuit opens</li> </ol> <p>Why this matters: Prevents retry storms when service is down</p>"},{"location":"integrations/tenacity/#5-thread-safe-cancelation","title":"5. Thread-Safe Cancelation","text":"<p>Problem: Need to cancel async retry loop from GUI thread or signal handler</p> <p>Solution: Use <code>cancel_sync()</code> for thread-safe cancelation:</p> <pre><code>import threading\nfrom tenacity import AsyncRetrying, stop_after_attempt\nfrom hother.cancelable import Cancelable, CancelationToken\n\ntoken = CancelationToken()\n\n# Async retry loop\nasync def retry_operation():\n    async with Cancelable.with_token(token) as cancel:\n        wrapped_op = cancel.wrap(long_operation)\n\n        async for attempt in AsyncRetrying(stop=stop_after_attempt(10)):\n            with attempt:\n                result = await wrapped_op()\n                return result\n\n# GUI button handler (different thread)\ndef on_cancel_button_clicked():\n    \"\"\"Called from GUI thread.\"\"\"\n    token.cancel_sync(\"User clicked cancel\")  # (1)!\n\n# Or signal handler (different context)\ndef signal_handler(signum, frame):\n    \"\"\"Called from signal handler.\"\"\"\n    token.cancel_sync(f\"Received signal {signum}\")\n\nsignal.signal(signal.SIGINT, signal_handler)\n</code></pre> <ol> <li>Thread-safe cancelation from any context</li> </ol> <p>Why this matters: Enables cross-thread coordination</p>"},{"location":"integrations/tenacity/#integration-patterns","title":"Integration Patterns","text":""},{"location":"integrations/tenacity/#the-core-pattern","title":"The Core Pattern","text":"<pre><code># 1. Create cancelable with sources\ncancel = Cancelable.with_timeout(60)\ncancel = cancel.combine(\n    Cancelable.with_token(token),\n    Cancelable.with_signal(signal.SIGTERM)\n)\n\n# 2. Wrap operation once\nasync with cancel:\n    wrapped = cancel.wrap(operation)\n\n    # 3. Tenacity handles retry logic\n    async for attempt in AsyncRetrying(...):\n        with attempt:\n            result = await wrapped()  # Checks cancelation sources\n</code></pre>"},{"location":"integrations/tenacity/#pre-wrap-operations-recommended","title":"Pre-wrap Operations (Recommended)","text":"<p>Wrap once before the retry loop for efficiency:</p> <pre><code>async with Cancelable.with_timeout(60) as cancel:\n    wrapped_op = cancel.wrap(operation)  # (1)!\n\n    async for attempt in AsyncRetrying(stop=stop_after_attempt(3)):\n        with attempt:\n            result = await wrapped_op()  # (2)!\n</code></pre> <ol> <li>Wrap once for efficiency</li> <li>Call many times - cancelation checked before each attempt</li> </ol>"},{"location":"integrations/tenacity/#scoped-wrapping-alternative","title":"Scoped Wrapping (Alternative)","text":"<p>Use <code>wrapping()</code> context manager for scoped wrapping:</p> <pre><code>async with Cancelable.with_timeout(30) as cancel:\n    async for attempt in AsyncRetrying(stop=stop_after_attempt(3)):\n        with attempt:\n            async with cancel.wrapping() as wrap:\n                result = await wrap(operation)\n</code></pre>"},{"location":"integrations/tenacity/#tenacity-features","title":"Tenacity Features","text":""},{"location":"integrations/tenacity/#wait-strategies-with-jitter","title":"Wait Strategies with Jitter","text":"<p>Prevent thundering herd with jitter:</p> <pre><code>from tenacity import wait_exponential, wait_random\n\nasync with Cancelable.with_token(token) as cancel:\n    wrapped = cancel.wrap(api_call)\n\n    async for attempt in AsyncRetrying(\n        stop=stop_after_attempt(8),\n        wait=wait_exponential(min=2, max=30) + wait_random(0, 2)  # (1)!\n    ):\n        with attempt:\n            result = await wrapped()\n</code></pre> <ol> <li>Exponential backoff + random 0-2s jitter</li> </ol>"},{"location":"integrations/tenacity/#retry-predicates","title":"Retry Predicates","text":"<p>Only retry specific errors:</p> <pre><code>import httpx\nfrom tenacity import retry_if_exception_type\n\nasync with Cancelable.with_timeout(60) as cancel:\n    wrapped = cancel.wrap(fetch)\n\n    async for attempt in AsyncRetrying(\n        stop=stop_after_attempt(5),\n        retry=retry_if_exception_type((  # (1)!\n            httpx.ConnectError,\n            httpx.TimeoutException\n        ))\n    ):\n        with attempt:\n            result = await wrapped()\n</code></pre> <ol> <li>Only retry network errors, not client errors (4xx)</li> </ol>"},{"location":"integrations/tenacity/#complete-examples","title":"Complete Examples","text":""},{"location":"integrations/tenacity/#example-multi-user-background-jobs","title":"Example: Multi-User Background Jobs","text":"<pre><code>import signal\nfrom tenacity import AsyncRetrying, stop_after_attempt, wait_fixed\nfrom hother.cancelable import Cancelable, CancelationToken, OperationRegistry\n\nuser_tokens: dict[str, CancelationToken] = {}\n\nasync def process_user_data(user_id: str, items: list):\n    \"\"\"Process data with retry, cancelable by user or signal.\"\"\"\n    token = CancelationToken()\n    user_tokens[user_id] = token\n\n    cancel = Cancelable.with_timeout(300, name=f\"user_{user_id}_job\")\n    cancel = cancel.combine(\n        Cancelable.with_token(token),\n        Cancelable.with_signal(signal.SIGTERM)\n    )\n\n    async with cancel:\n        wrapped_process = cancel.wrap(process_item)\n\n        for item in items:\n            async for attempt in AsyncRetrying(\n                stop=stop_after_attempt(3),\n                wait=wait_fixed(2)\n            ):\n                with attempt:\n                    await cancel.report_progress(\n                        f\"Processing {item}\",\n                        {\"user\": user_id, \"item\": item}\n                    )\n                    await wrapped_process(user_id, item)\n\n# Cancel specific user\nasync def cancel_user_job(user_id: str):\n    if token := user_tokens.get(user_id):\n        await token.cancel(f\"User {user_id} requested cancel\")\n\n# Cancel all users\nasync def cancel_all_jobs():\n    registry = OperationRegistry.get_instance()\n    await registry.cancel_all(\n        name_pattern=\"user_*\",\n        reason=CancelationReason.MANUAL\n    )\n</code></pre>"},{"location":"integrations/tenacity/#example-streaming-with-retry","title":"Example: Streaming with Retry","text":"<pre><code>from tenacity import AsyncRetrying, stop_after_attempt, wait_fixed\nfrom hother.cancelable import Cancelable\n\nasync def process_stream_with_retry(stream_source, request: Request):\n    \"\"\"Process stream with retry, stops on client disconnect.\"\"\"\n    cancel = Cancelable.with_timeout(300)\n    # Assuming FastAPI passes request that can be checked for disconnect\n\n    async with cancel:\n        async for attempt in AsyncRetrying(\n            stop=stop_after_attempt(3),\n            wait=wait_fixed(5)\n        ):\n            with attempt:\n                # Each retry gets fresh stream\n                stream = cancel.wrap(stream_source)\n\n                async for item in await stream():\n                    yield item\n</code></pre>"},{"location":"integrations/tenacity/#best-practices","title":"Best Practices","text":""},{"location":"integrations/tenacity/#1-combine-multiple-sources","title":"1. Combine Multiple Sources","text":"<p>Don't just use timeout - that's what Tenacity already does:</p> <pre><code># \u274c Weak - just timeout (Tenacity can do this)\nasync with Cancelable.with_timeout(60) as cancel:\n    async for attempt in AsyncRetrying(...):\n        ...\n\n# \u2705 Strong - multiple sources (Tenacity can't do this)\ncancel = Cancelable.with_timeout(60)\ncancel = cancel.combine(\n    Cancelable.with_token(user_token),\n    Cancelable.with_signal(signal.SIGTERM)\n)\n</code></pre>"},{"location":"integrations/tenacity/#2-report-progress","title":"2. Report Progress","text":"<p>Track retry attempts for observability:</p> <pre><code>async with Cancelable(name=\"fetch\") as cancel:\n    cancel.on_progress(lambda op_id, msg, meta: logger.info(msg))\n\n    wrapped = cancel.wrap(operation)\n    async for attempt in AsyncRetrying(stop=stop_after_attempt(5)):\n        with attempt:\n            await cancel.report_progress(\n                f\"Attempt {attempt.retry_state.attempt_number}/5\",\n                {\"attempt\": attempt.retry_state.attempt_number}\n            )\n            result = await wrapped()\n</code></pre>"},{"location":"integrations/tenacity/#3-handle-exception-types-correctly","title":"3. Handle Exception Types Correctly","text":"<p>Distinguish between cancelation and retry exhaustion:</p> <pre><code>from tenacity import RetryError\nimport anyio\n\ntry:\n    async with cancel:\n        async for attempt in AsyncRetrying(...):\n            with attempt:\n                result = await wrapped()\nexcept anyio.get_cancelled_exc_class():\n    logger.warning(\"Operation cancelled\")  # (1)!\nexcept RetryError as e:\n    logger.error(f\"All retries exhausted: {e}\")  # (2)!\n</code></pre> <ol> <li>Canceled by timeout, token, signal, or condition</li> <li>Tenacity gave up after all retry attempts</li> </ol>"},{"location":"integrations/tenacity/#4-use-thread-safe-methods","title":"4. Use Thread-Safe Methods","text":"<p>When canceling from different threads:</p> <pre><code># \u2705 Correct - thread-safe\ntoken.cancel_sync(\"From GUI thread\")\n\n# \u274c Wrong - not thread-safe\nawait token.cancel(\"From GUI thread\")  # Can't await in sync context!\n</code></pre>"},{"location":"integrations/tenacity/#5-add-jitter","title":"5. Add Jitter","text":"<p>Prevent thundering herd in distributed systems:</p> <pre><code>from tenacity import wait_exponential, wait_random\n\nasync for attempt in AsyncRetrying(\n    wait=wait_exponential(min=1, max=30) + wait_random(0, 2)\n):\n    ...\n</code></pre>"},{"location":"integrations/tenacity/#troubleshooting","title":"Troubleshooting","text":""},{"location":"integrations/tenacity/#issue-retries-not-stopping-on-cancelation","title":"Issue: Retries Not Stopping on Cancelation","text":"<p>Problem: Wrapped operation ignores cancelation.</p> <p>Solution: Ensure you're inside the cancelable context:</p> <pre><code># \u274c Wrong - not in context\ncancel = Cancelable.with_timeout(30)\nwrapped = cancel.wrap(operation)\nasync for attempt in AsyncRetrying(...):\n    await wrapped()  # Won't check cancelation!\n\n# \u2705 Correct - inside context\nasync with cancel:\n    wrapped = cancel.wrap(operation)\n    async for attempt in AsyncRetrying(...):\n        await wrapped()  # Checks cancelation!\n</code></pre>"},{"location":"integrations/tenacity/#issue-why-not-just-use-tenacitys-stop_after_delay","title":"Issue: \"Why not just use Tenacity's stop_after_delay?\"","text":"<p>Answer: If you only need timeout, use Tenacity alone! But if you need: - Manual cancelation (user action) - Signal handling (graceful shutdown) - Client disconnect detection - Cross-thread cancelation - Condition-based cancelation</p> <p>Then you need Cancelable + Tenacity.</p>"},{"location":"integrations/tenacity/#issue-too-many-nested-context-managers","title":"Issue: Too Many Nested Context Managers","text":"<p>Solution: Use <code>wrap()</code> instead of <code>wrapping()</code>:</p> <pre><code># \u274c Complex\nasync with cancel:\n    async for attempt in AsyncRetrying(...):\n        with attempt:\n            async with cancel.wrapping() as wrap:\n                result = await wrap(operation)\n\n# \u2705 Simple\nasync with cancel:\n    wrapped = cancel.wrap(operation)\n    async for attempt in AsyncRetrying(...):\n        with attempt:\n            result = await wrapped()\n</code></pre>"},{"location":"integrations/tenacity/#api-reference","title":"API Reference","text":""},{"location":"integrations/tenacity/#wrap-method","title":"<code>wrap()</code> Method","text":"<pre><code>def wrap(self, operation: Callable[..., Awaitable[R]]) -&gt; Callable[..., Awaitable[R]]\n</code></pre> <p>Wrap an async operation to check cancelation before each call.</p> <p>Example: </p><pre><code>async with Cancelable.with_timeout(30) as cancel:\n    wrapped = cancel.wrap(operation)\n    result = await wrapped()  # Checks cancelation first\n</code></pre><p></p>"},{"location":"integrations/tenacity/#wrapping-context-manager","title":"<code>wrapping()</code> Context Manager","text":"<pre><code>@asynccontextmanager\nasync def wrapping(self) -&gt; AsyncIterator[Callable]\n</code></pre> <p>Async context manager for scoped wrapping.</p> <p>Example: </p><pre><code>async with Cancelable.with_timeout(30) as cancel:\n    async with cancel.wrapping() as wrap:\n        result = await wrap(operation)\n</code></pre><p></p>"},{"location":"integrations/tenacity/#see-also","title":"See Also","text":"<ul> <li>Tenacity Documentation - Full Tenacity library docs</li> <li>Core Concepts - Understanding Cancelable</li> <li>FastAPI Integration - Request lifecycle binding</li> <li>Advanced Patterns - Production patterns</li> </ul>"},{"location":"reference/","title":"Overview","text":""},{"location":"reference/#api-reference","title":"API Reference","text":"<p>Welcome to the complete API reference for the Cancelable library. All documentation is automatically generated from code docstrings.</p>"},{"location":"reference/#navigation","title":"Navigation","text":"<p>The API reference is organized into the following sections:</p>"},{"location":"reference/#core-components","title":"Core Components","text":"<p>The fundamental building blocks for async cancelation:</p> <ul> <li>Cancelable - Main context manager for cancellable operations</li> <li>CancelationToken - Thread-safe token for manual cancelation</li> <li>LinkedCancelationToken - Combine multiple cancelation tokens</li> <li>OperationContext - Track operation state and metadata</li> <li>OperationStatus - Operation state enumeration</li> <li>OperationRegistry - Global operation tracking</li> <li>Exceptions - All cancelation-related exceptions</li> </ul>"},{"location":"reference/#cancelation-sources","title":"Cancelation Sources","text":"<p>Different ways to trigger cancelation:</p> <ul> <li>CancelationSource - Base class for all sources</li> <li>TimeoutSource - Time-based cancelation</li> <li>SignalSource - Unix signal-based cancelation (SIGTERM, SIGINT, etc.)</li> <li>ConditionSource - Predicate-based cancelation</li> <li>TokenSource - Token-based cancelation</li> <li>CompositeCancelationSource - Combine multiple sources</li> </ul>"},{"location":"reference/#integrations","title":"Integrations","text":"<p>Framework and library integrations:</p> <ul> <li>FastAPI - Middleware and utilities for FastAPI applications</li> </ul>"},{"location":"reference/#utilities","title":"Utilities","text":"<p>Helper functions, decorators, bridges, and testing tools:</p> <ul> <li>Decorators - <code>@cancelable</code> decorator for easy cancelation</li> <li>Bridges - AnyIO, threading, and context bridges</li> <li>Streams - Cancellable async stream processing</li> <li>Streaming Simulator - Testing and demonstration tools</li> <li>Logging - Structured logging utilities</li> <li>Testing - Test utilities and fixtures</li> </ul>"},{"location":"reference/#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started Guide</li> <li>Usage Patterns</li> <li>Examples</li> </ul>"},{"location":"reference/core/","title":"Core Components","text":""},{"location":"reference/core/#core-components","title":"Core Components","text":"<p>The core components provide the fundamental building blocks for async cancelation in Python.</p>"},{"location":"reference/core/#cancelable","title":"Cancelable","text":"<p>The main context manager for cancelable operations.</p>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable","title":"hother.cancelable.core.cancelable.Cancelable","text":"<p>Main cancelation helper with composable cancelation sources.</p> <p>Provides a unified interface for handling cancelation from multiple sources including timeouts, tokens, signals, and conditions.</p> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>class Cancelable:\n    \"\"\"Main cancelation helper with composable cancelation sources.\n\n    Provides a unified interface for handling cancelation from multiple sources\n    including timeouts, tokens, signals, and conditions.\n    \"\"\"\n\n    def __init__(\n        self,\n        operation_id: str | None = None,\n        name: str | None = None,\n        parent: Cancelable | None = None,\n        metadata: dict[str, Any] | None = None,\n        register_globally: bool = False,\n    ):\n        \"\"\"Initialize a new cancelable operation.\n\n        Args:\n            operation_id: Unique operation identifier (auto-generated if not provided)\n            name: Human-readable operation name\n            parent: Parent cancelable for hierarchical cancelation\n            metadata: Additional operation metadata\n            register_globally: Whether to register with global registry\n        \"\"\"\n        # Create context with conditional ID\n        context_kwargs = {\n            \"name\": name,\n            \"metadata\": metadata or {},\n        }\n        if operation_id is not None:\n            context_kwargs[\"id\"] = operation_id\n\n        self.context = OperationContext(**context_kwargs)  # type: ignore[arg-type]\n\n        # Set parent relationship after context creation\n        if parent:\n            self.context.parent_id = parent.context.id\n\n        self._scope: anyio.CancelScope | None = None\n        self._token = LinkedCancelationToken()\n\n        # Use weak references to break circular reference cycles\n        self._parent_ref = weakref.ref(parent) if parent else None\n        self._children: weakref.WeakSet[Cancelable] = weakref.WeakSet()\n\n        # Register with parent if provided (parent holds strong refs to children)\n        if parent:\n            parent._children.add(self)\n        self._sources: list[CancelationSource] = []\n        self._shields: list[anyio.CancelScope] = []\n        self._cancellables_to_link: list[Cancelable] | None = None\n        self._register_globally = register_globally\n\n        # Token linking state management\n        self._link_state = LinkState.NOT_LINKED\n        self._link_lock = anyio.Lock()\n\n        # Callbacks\n        self._progress_callbacks: list[ProgressCallbackType] = []\n        self._status_callbacks: dict[str, list[StatusCallbackType | ErrorCallbackType]] = {\n            \"start\": [],\n            \"complete\": [],\n            \"cancel\": [],\n            \"error\": [],\n        }\n\n        # Register with parent\n        if parent:\n            parent._children.add(self)\n\n        logger.info(\n            \"Cancelable created\",\n            extra=self.context.log_context(),\n        )\n\n    @property\n    def token(self) -&gt; LinkedCancelationToken:\n        \"\"\"Get the cancellation token for this operation.\n\n        Returns:\n            The LinkedCancelationToken managing this operation's cancellation state.\n        \"\"\"\n        return self._token\n\n    def add_source(self, source: CancelationSource) -&gt; Cancelable:\n        \"\"\"Add a cancelation source to this operation.\n\n        This allows adding custom or composite sources (like AllOfSource) to an existing\n        Cancelable instance.\n\n        Args:\n            source: The cancelation source to add\n\n        Returns:\n            Self for method chaining\n\n        Example:\n            ```python\n            from hother.cancelable.sources.composite import AllOfSource\n\n            cancelable = Cancelable(name=\"my_op\")\n            all_of = AllOfSource([timeout_source, condition_source])\n            cancelable.add_source(all_of)\n            ```\n        \"\"\"\n        self._sources.append(source)\n        return self\n\n    # Factory methods\n    @classmethod\n    def with_timeout(\n        cls, timeout: float | timedelta, operation_id: str | None = None, name: str | None = None, **kwargs: Any\n    ) -&gt; Cancelable:\n        \"\"\"Create cancelable with timeout.\n\n        Args:\n            timeout: Timeout duration in seconds or timedelta\n            operation_id: Optional operation ID\n            name: Optional operation name\n            **kwargs: Additional arguments for Cancelable\n\n        Returns:\n            Configured Cancelable instance\n        \"\"\"\n        from hother.cancelable.sources.timeout import TimeoutSource\n\n        if isinstance(timeout, timedelta):\n            timeout = timeout.total_seconds()\n\n        instance = cls(operation_id=operation_id, name=name or f\"timeout_{timeout}s\", **kwargs)\n        instance._sources.append(TimeoutSource(timeout))\n        return instance\n\n    @classmethod\n    def with_token(\n        cls, token: CancelationToken, operation_id: str | None = None, name: str | None = None, **kwargs: Any\n    ) -&gt; Cancelable:\n        \"\"\"Create a Cancelable operation using an existing cancellation token.\n\n        This factory method allows you to create a cancellable operation that shares\n        a cancellation token with other operations, enabling coordinated cancellation.\n\n        Args:\n            token: The CancelationToken to use for this operation\n            operation_id: Optional custom operation identifier\n            name: Optional operation name (defaults to \"token_based\")\n            **kwargs: Additional arguments passed to Cancelable constructor\n\n        Returns:\n            A configured Cancelable instance using the provided token\n\n        Example:\n            ```python\n            # Share a token between multiple operations\n            shared_token = CancelationToken()\n\n            async with Cancelable.with_token(shared_token, name=\"task1\") as cancel1:\n                # ... operation 1 ...\n\n            async with Cancelable.with_token(shared_token, name=\"task2\") as cancel2:\n                # ... operation 2 ...\n\n            # Cancel both operations via the shared token\n            await shared_token.cancel()\n            ```\n        \"\"\"\n        instance = cls(operation_id=operation_id, name=name or \"token_based\", **kwargs)\n        # Replace default token with provided one\n        logger.debug(f\"with_token: Replacing default token {instance._token.id} with user token {token.id}\")\n        instance._token = token\n        logger.debug(f\"with_token: Created cancelable {instance.context.id} with user token {token.id}\")\n        return instance\n\n    @classmethod\n    def with_signal(cls, *signals: int, operation_id: str | None = None, name: str | None = None, **kwargs: Any) -&gt; Cancelable:\n        \"\"\"Create cancelable with signal handling.\n\n        Args:\n            *signals: Signal numbers to handle\n            operation_id: Optional operation ID\n            name: Optional operation name\n            **kwargs: Additional arguments for Cancelable\n\n        Returns:\n            Configured Cancelable instance\n        \"\"\"\n        from hother.cancelable.sources.signal import SignalSource\n\n        instance = cls(operation_id=operation_id, name=name or \"signal_based\", **kwargs)\n        instance._sources.append(SignalSource(*signals))\n        return instance\n\n    @classmethod\n    def with_condition(\n        cls,\n        condition: Callable[[], bool | Awaitable[bool]],\n        check_interval: float = 0.1,\n        condition_name: str | None = None,\n        operation_id: str | None = None,\n        name: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Cancelable:\n        \"\"\"Create cancelable with condition checking.\n\n        Args:\n            condition: Callable that returns True when cancelation should occur\n            check_interval: How often to check the condition (seconds)\n            condition_name: Name for the condition (for logging)\n            operation_id: Optional operation ID\n            name: Optional operation name\n            **kwargs: Additional arguments for Cancelable\n\n        Returns:\n            Configured Cancelable instance\n        \"\"\"\n        from hother.cancelable.sources.condition import ConditionSource\n\n        instance = cls(operation_id=operation_id, name=name or \"condition_based\", **kwargs)\n        instance._sources.append(ConditionSource(condition, check_interval, condition_name))\n        return instance\n\n    # Composition\n    def combine(self, *others: Cancelable) -&gt; Cancelable:\n        \"\"\"Combine multiple Cancelable operations into a single coordinated operation.\n\n        Creates a new Cancelable that will be cancelled if ANY of the combined\n        operations is cancelled. All cancellation sources from the combined\n        operations are merged together.\n\n        Args:\n            *others: One or more Cancelable instances to combine with this one\n\n        Returns:\n            A new Cancelable instance that coordinates cancellation across all\n            combined operations. When entered, all operations' tokens are linked.\n\n        Example:\n            ```python\n            # Combine timeout and signal handling\n            timeout_cancel = Cancelable.with_timeout(30.0)\n            signal_cancel = Cancelable.with_signal(signal.SIGTERM)\n\n            async with timeout_cancel.combine(signal_cancel) as cancel:\n                # Operation will cancel on either timeout OR signal\n                await long_running_operation()\n            ```\n\n        Note:\n            The combined Cancelable preserves the cancellation reason from\n            whichever source triggers first.\n        \"\"\"\n        logger.debug(\"=== COMBINE CALLED ===\")\n        logger.debug(f\"Self: {self.context.id} ({self.context.name}) with token {self._token.id}\")\n        for i, other in enumerate(others):\n            logger.debug(f\"Other {i}: {other.context.id} ({other.context.name}) with token {other._token.id}\")\n\n        combined = Cancelable(\n            name=f\"combined_{self.context.name}\",\n            metadata={\n                \"sources\": [self.context.id] + [o.context.id for o in others],\n                \"combined\": True,\n                \"preserve_reason\": True,  # Add this flag\n            },\n        )\n\n        logger.debug(f\"Created combined cancelable: {combined.context.id} with default token {combined._token.id}\")\n\n        # Store the actual cancelables to link their tokens later\n        combined._cancellables_to_link = [self] + list(others)\n        logger.debug(f\"Will link to {len(combined._cancellables_to_link)} cancelables:\")\n        for i, c in enumerate(combined._cancellables_to_link):\n            logger.debug(f\"  {i}: {c.context.id} with token {c._token.id}\")\n\n        # Combine all sources\n        combined._sources.extend(self._sources)\n        for other in others:\n            combined._sources.extend(other._sources)\n\n        logger.debug(\n            \"Created combined cancelable\",\n            extra={\n                \"operation_id\": combined.context.id,\n                \"source_count\": len(combined._sources),\n            },\n        )\n\n        return combined\n\n    # Callback registration\n    def on_progress(\n        self,\n        callback: ProgressCallbackType,\n    ) -&gt; Cancelable:\n        \"\"\"Register a callback to be invoked when progress is reported.\n\n        The callback will be called whenever `report_progress()` is invoked\n        on this operation. Both sync and async callbacks are supported.\n\n        Args:\n            callback: Function to call on progress updates. Receives:\n                - operation_id (str): The ID of the operation\n                - message (Any): The progress message\n                - metadata (dict[str, Any] | None): Optional metadata\n\n        Returns:\n            Self for method chaining\n\n        Example:\n            ```python\n            async with Cancelable(name=\"download\") as cancel:\n                cancel.on_progress(lambda id, msg, meta: print(f\"Progress: {msg}\"))\n\n                for i in range(100):\n                    await cancel.report_progress(f\"{i}% complete\")\n                    await asyncio.sleep(0.1)\n            ```\n        \"\"\"\n        self._progress_callbacks.append(callback)\n        return self\n\n    def on_start(self, callback: StatusCallbackType) -&gt; Cancelable:\n        \"\"\"Register a callback to be invoked when the operation starts.\n\n        The callback is triggered when entering the async context (on `__aenter__`).\n\n        Args:\n            callback: Function receiving the OperationContext. Can be sync or async.\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        self._status_callbacks[\"start\"].append(callback)\n        return self\n\n    def on_complete(self, callback: StatusCallbackType) -&gt; Cancelable:\n        \"\"\"Register a callback to be invoked when the operation completes successfully.\n\n        The callback is triggered when exiting the context without cancellation or error.\n\n        Args:\n            callback: Function receiving the OperationContext. Can be sync or async.\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        self._status_callbacks[\"complete\"].append(callback)\n        return self\n\n    def on_cancel(self, callback: StatusCallbackType) -&gt; Cancelable:\n        \"\"\"Register a callback to be invoked when the operation is cancelled.\n\n        The callback is triggered when the operation is cancelled by any source\n        (timeout, signal, token, condition, or parent cancellation).\n\n        Args:\n            callback: Function receiving the OperationContext. Can be sync or async.\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        self._status_callbacks[\"cancel\"].append(callback)\n        return self\n\n    def on_error(\n        self,\n        callback: ErrorCallbackType,\n    ) -&gt; Cancelable:\n        \"\"\"Register a callback to be invoked when the operation encounters an error.\n\n        The callback is triggered when an exception (other than CancelledError)\n        is raised within the operation context.\n\n        Args:\n            callback: Function receiving the OperationContext and Exception.\n                Can be sync or async.\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        self._status_callbacks[\"error\"].append(callback)\n        return self\n\n    # Progress reporting\n    async def report_progress(self, message: Any, metadata: dict[str, Any] | None = None) -&gt; None:\n        \"\"\"Report progress to all registered callbacks.\n\n        Args:\n            message: Progress message\n            metadata: Optional metadata dict\n        \"\"\"\n        for callback in self._progress_callbacks:\n            try:\n                result = callback(self.context.id, message, metadata)\n                if inspect.iscoroutine(result):\n                    await result\n            except Exception as e:\n                logger.error(\n                    \"Progress callback error for operation %s: %s\",\n                    self.context.id,\n                    str(e),\n                    exc_info=True,\n                )\n\n    async def check_cancelation(self) -&gt; None:\n        \"\"\"Check if operation is cancelled and raise if so.\n\n        This is a public API for checking cancellation state.\n        Use this instead of accessing `_token` directly.\n\n        Raises:\n            anyio.CancelledError: If operation is cancelled\n        \"\"\"\n        await self._token.check_async()  # pragma: no cover\n\n    # Context manager\n    async def __aenter__(self) -&gt; Cancelable:\n        \"\"\"Enter cancelation context.\"\"\"\n        logger.debug(f\"=== ENTERING cancelation context for {self.context.id} ({self.context.name}) ===\")\n\n        # Set as current operation\n        self._context_token = _current_operation.set(self)\n\n        # Safely link all required tokens with race condition protection\n        await self._safe_link_tokens()\n\n        # Update status\n        self.context.update_status(OperationStatus.RUNNING)\n\n        # Register with global registry if requested\n        if self._register_globally:\n            from .registry import OperationRegistry\n\n            registry = OperationRegistry.get_instance()\n            await registry.register(self)\n\n        # Create cancel scope\n        self._scope = anyio.CancelScope()\n\n        # Set up simple token monitoring via callback\n        async def on_token_cancel(token: CancelationToken) -&gt; None:\n            \"\"\"Callback when token is cancelled.\"\"\"\n            logger.error(f\"\ud83d\udea8 TOKEN CALLBACK TRIGGERED! Token {token.id} cancelled, cancelling scope for {self.context.id}\")\n            if self._scope and not self._scope.cancel_called:\n                logger.error(f\"\ud83d\udea8 CANCELLING SCOPE for {self.context.id}\")\n                self._scope.cancel()\n            else:\n                scope_info = f\"scope={self._scope}, cancel_called={self._scope.cancel_called if self._scope else 'N/A'}\"\n                logger.error(f\"\ud83d\udea8 SCOPE ALREADY CANCELLED OR NONE for {self.context.id} ({scope_info})\")\n\n        logger.debug(f\"Registering token callback for token {self._token.id}\")\n        await self._token.register_callback(on_token_cancel)\n        logger.debug(\"Token callback registered successfully\")\n\n        # Start monitoring\n        await self._setup_monitoring()\n\n        # Trigger start callbacks\n        await self._trigger_callbacks(\"start\")\n\n        # Enter scope - sync operation\n        self._scope_exit = self._scope.__enter__()\n\n        logger.debug(f\"=== COMPLETED ENTER for {self.context.id} ===\")\n        return self\n\n    @property\n    def parent(self) -&gt; Cancelable | None:\n        \"\"\"Get parent cancelable, returning None if garbage collected.\"\"\"\n        return self._parent_ref() if self._parent_ref else None\n\n    async def run_in_thread(self, func: Callable[..., T], *args: Any, **kwargs: Any) -&gt; T:\n        \"\"\"Run function in thread with proper context propagation.\n\n        This method solves the context variable thread safety issue by ensuring\n        that context variables (including _current_operation) are properly\n        propagated to OS threads.\n\n        Args:\n            func: Function to run in thread\n            *args: Positional arguments for func\n            **kwargs: Keyword arguments for func\n\n        Returns:\n            Result of func execution\n\n        Example:\n            ```python\n            async with Cancelable(name=\"main\") as cancel:\n                # Context is propagated to thread\n                result = await cancel.run_in_thread(expensive_computation, data)\n            ```\n        \"\"\"\n        # Store current context for thread propagation\n        ctx = ContextBridge.copy_context()\n\n        def thread_func():\n            # Restore context in thread\n            ContextBridge.restore_context(ctx)\n            # Set current operation in thread\n            _current_operation.set(self)\n            return func(*args, **kwargs)\n\n        # Run in thread with context\n        return await ContextBridge.run_in_thread_with_context(thread_func)\n\n    def __del__(self):\n        \"\"\"Cleanup when cancelable is garbage collected.\"\"\"\n        # Remove from parent's children set (if parent still exists)\n        if self._parent_ref:\n            parent = self._parent_ref()\n            if parent and self in parent._children:\n                parent._children.remove(self)\n\n        # Clear references to help GC\n        self._parent_ref = None\n        self._children.clear()\n\n    def _handle_scope_exit(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: Any | None,\n    ) -&gt; bool:\n        \"\"\"Handle anyio scope exit.\n\n        Returns:\n            True if scope handled the exception, False otherwise.\n        \"\"\"\n        _scope_handled = False\n        if self._scope:\n            try:\n                # scope.__exit__ returns True if it handled the exception\n                _scope_handled = self._scope.__exit__(exc_type, exc_val, exc_tb)\n            except Exception as e:\n                logger.debug(f\"Scope exit raised: {e}\")\n                # Re-raise the exception from scope exit\n                raise\n        return _scope_handled\n\n    async def _determine_final_status(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n    ) -&gt; None:\n        \"\"\"Determine final operation status based on exception.\"\"\"\n        # Determine final status based on the exception\n        # We need to update status even if scope handled it, because the exception might still propagate\n        if exc_type is not None:\n            logger.debug(f\"Exception type: {exc_type}\")\n            if issubclass(exc_type, anyio.get_cancelled_exc_class()):\n                logger.debug(\"Handling CancelledError\")\n                # Handle cancelation\n                # First check if we already have a cancel reason set by a source\n                if self.context.cancel_reason:\n                    # A source already set the reason (like condition, timeout, etc.)\n                    logger.debug(f\"Cancel reason already set: {self.context.cancel_reason}\")\n                elif self._token.is_cancelled:\n                    # Token was cancelled\n                    self.context.cancel_reason = self._token.reason\n                    self.context.cancel_message = self._token.message\n                    logger.debug(f\"Cancel reason from token: {self._token.reason}\")\n                elif self._scope and self._scope.cancel_called:\n                    # Scope was cancelled - check why\n                    # Check if deadline was exceeded (timeout)\n                    # Note: anyio CancelScope always has deadline attribute (defaults to inf)\n                    if anyio.current_time() &gt;= self._scope.deadline:\n                        self.context.cancel_reason = CancelationReason.TIMEOUT\n                        self.context.cancel_message = \"Operation timed out\"\n                        logger.debug(\"Detected timeout from deadline\")\n                    else:\n                        # Check sources\n                        for source in self._sources:\n                            if hasattr(source, \"triggered\") and source.triggered:\n                                self.context.cancel_reason = source.reason\n                                break\n\n                    if not self.context.cancel_reason:\n                        self.context.cancel_reason = CancelationReason.MANUAL\n                else:\n                    self.context.cancel_reason = CancelationReason.MANUAL\n\n                # Always update status to CANCELLED for any CancelledError\n                logger.debug(f\"Updating status to CANCELLED (was {self.context.status})\")\n                self.context.update_status(OperationStatus.CANCELLED)\n                logger.debug(f\"Status after update: {self.context.status}\")\n                await self._trigger_callbacks(\"cancel\")\n\n            elif issubclass(exc_type, CancelationError) and isinstance(exc_val, CancelationError):\n                # Our custom cancelation errors\n                self.context.cancel_reason = exc_val.reason\n                self.context.cancel_message = exc_val.message\n                self.context.update_status(OperationStatus.CANCELLED)\n                await self._trigger_callbacks(\"cancel\")\n            else:\n                # Other errors\n                self.context.error = str(exc_val)\n                self.context.update_status(OperationStatus.FAILED)\n\n                # Only trigger error callbacks for Exception instances, not BaseException\n                # (e.g., skip KeyboardInterrupt, SystemExit, GeneratorExit)\n                if isinstance(exc_val, Exception):\n                    await self._trigger_error_callbacks(exc_val)\n        else:\n            # Successful completion\n            self.context.update_status(OperationStatus.COMPLETED)\n            await self._trigger_callbacks(\"complete\")\n\n    async def _cleanup_context(self) -&gt; None:\n        \"\"\"Cleanup monitoring, shields, registry, and context vars.\"\"\"\n        logger.debug(f\"=== __aexit__ finally block for {self.context.id} ===\")\n\n        # Stop monitoring\n        await self._stop_monitoring()\n\n        # Cleanup shields\n        for shield in self._shields:\n            shield.cancel()\n\n        # Unregister from global registry\n        if self._register_globally:\n            from .registry import OperationRegistry\n\n            registry = OperationRegistry.get_instance()\n            await registry.unregister(self.context.id)\n\n        # Reset context variable\n        if hasattr(self, \"_context_token\"):\n            _current_operation.reset(self._context_token)\n\n        logger.debug(\n            f\"Exited cancelation context - final status: {self.context.status}\",\n            extra=self.context.log_context(),\n        )\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: Any | None,\n    ) -&gt; bool:\n        \"\"\"Exit cancelation context.\"\"\"\n        logger.debug(f\"=== ENTERING __aexit__ for {self.context.id} ===\")\n        logger.debug(f\"exc_type: {exc_type}, exc_val: {exc_val}\")\n        logger.debug(f\"Current status: {self.context.status}\")\n        logger.debug(f\"Current cancel_reason: {self.context.cancel_reason}\")\n\n        try:\n            # Handle scope exit\n            _scope_handled = self._handle_scope_exit(exc_type, exc_val, exc_tb)\n            # Determine final status based on exception\n            await self._determine_final_status(exc_type, exc_val)\n        except Exception as e:\n            logger.error(f\"Error in __aexit__ status handling: {e}\", exc_info=True)\n        finally:\n            # Cleanup context resources\n            await self._cleanup_context()\n\n        # Always propagate exceptions - cancelation context should not suppress them\n        # The anyio.CancelScope handles cancelation propagation appropriately\n        return False\n\n    async def _collect_all_tokens(self, cancelables: list[Cancelable], result: list[CancelationToken]) -&gt; None:\n        \"\"\"Recursively collect all tokens from cancelables and their children.\"\"\"\n        for cancelable in cancelables:\n            # Add this cancelable's token\n            if cancelable._token not in result:\n                result.append(cancelable._token)\n\n            # Recursively add tokens from nested cancelables\n            if cancelable._cancellables_to_link is not None:\n                await self._collect_all_tokens(cancelable._cancellables_to_link, result)\n\n    async def _setup_monitoring(self) -&gt; None:\n        \"\"\"Setup all cancelation sources.\"\"\"\n        # Setup source monitoring\n        for source in self._sources:\n            source.set_cancel_callback(self._on_source_cancelled)\n            await source.start_monitoring(cast(anyio.CancelScope, self._scope))\n\n    async def _stop_monitoring(self) -&gt; None:\n        \"\"\"Stop all monitoring tasks.\"\"\"\n        # Stop source monitoring\n        for source in self._sources:\n            try:\n                await source.stop_monitoring()\n            except Exception as e:\n                logger.error(\n                    \"Error stopping source monitoring for %s: %s\",\n                    str(source),\n                    str(e),\n                    exc_info=True,\n                )\n\n    async def _safe_link_tokens(self) -&gt; None:\n        \"\"\"Safely link all required tokens with race condition protection.\"\"\"\n        async with self._link_lock:\n            if self._link_state != LinkState.NOT_LINKED:\n                return  # Already processed\n\n            self._link_state = LinkState.LINKING\n\n            try:\n                # Check if token supports linking (only LinkedCancelationToken has link method)\n                if not hasattr(self._token, \"link\"):\n                    # Log warnings for test expectations\n                    parent = self.parent\n                    if parent:\n                        logger.warning(\n                            f\"Cannot link to parent: token {type(self._token).__name__} \"\n                            \"does not support linking (not a LinkedCancelationToken)\"\n                        )\n                    if self._cancellables_to_link is not None:\n                        logger.warning(\n                            f\"Cannot link to combined sources: token {type(self._token).__name__} \"\n                            \"does not support linking (not a LinkedCancelationToken)\"\n                        )\n                    self._link_state = LinkState.CANCELLED\n                    return\n\n                # Link to parent token if we have a parent\n                parent = self.parent\n                if parent:\n                    logger.debug(f\"Linking to parent token: {parent._token.id}\")\n                    await self._token.link(parent._token)\n\n                # Recursively link to ALL underlying tokens from combined cancelables\n                if self._cancellables_to_link is not None:\n                    logger.debug(f\"Linking to {len(self._cancellables_to_link)} combined cancelables\")\n                    all_tokens: list[CancelationToken] = []\n                    await self._collect_all_tokens(self._cancellables_to_link, all_tokens)\n\n                    # Check if we should preserve cancelation reasons\n                    preserve_reason = self.context.metadata.get(\"preserve_reason\", False)\n\n                    logger.debug(f\"Found {len(all_tokens)} total tokens to link:\")\n                    for i, token in enumerate(all_tokens):\n                        logger.debug(f\"  Token {i}: {token.id}\")\n                        await self._token.link(token, preserve_reason=preserve_reason)\n\n                self._link_state = LinkState.LINKED\n\n            except Exception as e:\n                self._link_state = LinkState.CANCELLED\n                logger.error(f\"Token linking failed: {e}\")\n                raise\n\n    async def _on_source_cancelled(self, reason: CancelationReason, message: str) -&gt; None:\n        \"\"\"Handle cancelation from a source.\"\"\"\n        self.context.cancel_reason = reason\n        self.context.cancel_message = message\n        # Also update the status immediately when a source cancels\n        self.context.update_status(OperationStatus.CANCELLED)\n\n    # Stream wrapper\n    async def stream(\n        self,\n        async_iter: AsyncIterator[T],\n        report_interval: int | None = None,\n        buffer_partial: bool = True,\n    ) -&gt; AsyncIterator[T]:\n        \"\"\"Wrap async iterator with cancelation support.\n\n        Args:\n            async_iter: Async iterator to wrap\n            report_interval: Report progress every N items\n            buffer_partial: Whether to buffer items for partial results\n\n        Yields:\n            Items from the wrapped iterator\n        \"\"\"\n        count = 0\n        buffer: list[T] = []\n\n        try:\n            async for item in async_iter:\n                # Check cancelation\n                await self._token.check_async()\n\n                yield item\n                count += 1\n\n                if buffer_partial:\n                    buffer.append(item)\n                    # Limit buffer size\n                    if len(buffer) &gt; _MAX_BUFFER_SIZE:\n                        buffer = buffer[-_MAX_BUFFER_SIZE:]\n\n                if report_interval and count % report_interval == 0:\n                    await self.report_progress(f\"Processed {count} items\", {\"count\": count, \"latest_item\": item})\n\n        except anyio.get_cancelled_exc_class():\n            # Save partial results\n            self.context.partial_result = {\n                \"count\": count,\n                \"buffer\": buffer if buffer_partial else None,\n            }\n            raise\n        except Exception:  # Intentionally broad to save partial results on any error\n            # Also save partial results on other exceptions\n            self.context.partial_result = {\n                \"count\": count,\n                \"buffer\": buffer if buffer_partial else None,\n                \"completed\": False,\n            }\n            raise\n        else:\n            # Save final results if completed normally\n            if buffer_partial or count &gt; 0:\n                self.context.partial_result = {\n                    \"count\": count,\n                    \"buffer\": buffer if buffer_partial else None,\n                    \"completed\": True,\n                }\n        finally:\n            logger.debug(\n                \"Stream processing completed for operation %s with %d items\",\n                self.context.id,\n                count,\n            )\n\n    # Function wrapper\n    def wrap(self, operation: Callable[..., Awaitable[R]]) -&gt; Callable[..., Awaitable[R]]:\n        \"\"\"Wrap an async operation to automatically check for cancelation before execution.\n\n        This is useful for retry loops and other patterns where you want automatic\n        cancelation checking without manually accessing the token.\n\n        Note: This assumes the cancelable context is already active (you're inside\n        an `async with` block). It does NOT create a new context.\n\n        Args:\n            operation: Async callable to wrap\n\n        Returns:\n            Wrapped callable that checks cancelation before executing\n\n        Example:\n            ```python\n            async with Cancelable.with_timeout(30) as cancel:\n                wrapped_fetch = cancel.wrap(fetch_data)\n\n                # In a retry loop\n                for attempt in range(3):\n                    try:\n                        result = await wrapped_fetch(url)\n                        break\n                    except Exception:\n                        await anyio.sleep(1)\n            ```\n        \"\"\"\n\n        @wraps(operation)\n        async def wrapped(*args: Any, **kwargs: Any) -&gt; R:\n            # Check cancelation before executing\n            await self._token.check_async()\n            return await operation(*args, **kwargs)\n\n        return wrapped\n\n    @asynccontextmanager\n    async def wrapping(self) -&gt; AsyncIterator[Callable[..., Awaitable[R]]]:\n        \"\"\"Async context manager that yields a wrap function for scoped operation wrapping.\n\n        The yielded wrap function checks cancelation before executing any operation.\n        This is useful for retry loops where you want all operations in a scope to\n        be automatically wrapped with cancelation checking.\n\n        Yields:\n            A wrap function that checks cancelation before executing operations\n\n        Example:\n            ```python\n            from tenacity import AsyncRetrying, stop_after_attempt\n\n            async with Cancelable.with_timeout(30) as cancel:\n                async for attempt in AsyncRetrying(stop=stop_after_attempt(3)):\n                    with attempt:\n                        async with cancel.wrapping() as wrap:\n                            result = await wrap(fetch_data, url)\n            ```\n        \"\"\"\n\n        async def wrap_fn(fn: Callable[..., Awaitable[R]], *args: Any, **kwargs: Any) -&gt; R:\n            await self._token.check_async()\n            return await fn(*args, **kwargs)\n\n        yield wrap_fn\n\n    # Shielding\n    @asynccontextmanager\n    async def shield(self) -&gt; AsyncIterator[Cancelable]:\n        \"\"\"Shield a section from cancelation.\n\n        Creates a child operation that is protected from cancelation but still\n        participates in the operation hierarchy for monitoring and tracking.\n\n        Yields:\n            A new Cancelable for the shielded section\n        \"\"\"\n        # Create properly integrated child cancelable\n        shielded = Cancelable(name=f\"{self.context.name}_shielded\", metadata={\"shielded\": True})\n        # Manually set parent relationship for hierarchy tracking but don't add to _children\n        # to prevent automatic cancelation propagation\n        shielded.context.parent_id = self.context.id\n\n        # Override token linking to prevent cancelation propagation\n        # The shielded operation should not be cancelled by parent token\n        shielded._token = LinkedCancelationToken()  # Fresh token, no parent linking\n\n        # Use anyio's CancelScope with shield=True\n        with anyio.CancelScope(shield=True) as shield_scope:\n            self._shields.append(shield_scope)\n            try:\n                shielded.context.update_status(OperationStatus.SHIELDED)\n                yield shielded\n            finally:\n                # Shield is always in list at this point (added at line 783)\n                self._shields.remove(shield_scope)\n\n        # Force a checkpoint after shield to allow cancelation to propagate\n        # We need to be in an async context for this to work properly\n        try:\n            await anyio.lowlevel.checkpoint()  # type: ignore[attr-defined]\n        except:\n            # Re-raise any exception including CancelledError\n            raise\n\n    # Cancelation\n    async def cancel(\n        self,\n        reason: CancelationReason = CancelationReason.MANUAL,\n        message: str | None = None,\n        propagate_to_children: bool = True,\n    ) -&gt; None:\n        \"\"\"Cancel the operation.\n\n        Args:\n            reason: Reason for cancelation\n            message: Optional cancelation message\n            propagate_to_children: Whether to cancel child operations\n        \"\"\"\n        # Cancel our token\n        await self._token.cancel(reason, message)\n\n        # Cancel children if requested\n        if propagate_to_children:\n            children_to_cancel = list(self._children)  # Snapshot to avoid modification during iteration\n            for child in children_to_cancel:\n                if child and not child.is_cancelled:\n                    await child.cancel(\n                        CancelationReason.PARENT,\n                        f\"Parent operation {self.context.id[:8]} cancelled\",\n                        propagate_to_children=True,\n                    )\n\n        # Clear references to help GC after cancelation\n        self._children.clear()\n        self._parent_ref = None\n\n        # Log without duplicating cancel_reason\n        log_ctx = self.context.log_context()\n        # Remove cancel_reason from log_context if it exists to avoid duplication\n        log_ctx.pop(\"cancel_reason\", None)\n\n        logger.info(\n            \"Operation cancelled\",\n            extra={\n                **log_ctx,\n                \"cancel_reason\": reason.value,\n                \"cancel_message\": message,\n            },\n        )\n\n    # Status helpers\n    @property\n    def is_cancelled(self) -&gt; bool:\n        \"\"\"Check if operation is cancelled.\"\"\"\n        return self.context.is_cancelled\n\n    @property\n    def is_running(self) -&gt; bool:\n        \"\"\"Check if operation is running.\"\"\"\n        return self.context.status == OperationStatus.RUNNING\n\n    @property\n    def is_completed(self) -&gt; bool:\n        \"\"\"Check if operation completed successfully.\"\"\"\n        return self.context.is_success\n\n    @property\n    def operation_id(self) -&gt; str:\n        \"\"\"Get operation ID.\"\"\"\n        return self.context.id\n\n    # Callback helpers\n    async def _trigger_callbacks(self, callback_type: str) -&gt; None:\n        \"\"\"Trigger callbacks of a specific type.\"\"\"\n        callbacks = self._status_callbacks.get(callback_type, [])\n        for callback in callbacks:\n            try:\n                result = callback(self.context)  # type: ignore[misc]\n                if inspect.iscoroutine(result):  # type: ignore[arg-type]\n                    await result\n            except Exception as e:\n                logger.error(\n                    \"%s callback error for operation %s: %s\",\n                    callback_type.capitalize(),\n                    self.context.id,\n                    str(e),\n                    exc_info=True,\n                )\n\n    async def _trigger_error_callbacks(self, error: Exception) -&gt; None:\n        \"\"\"Trigger error callbacks.\"\"\"\n        callbacks = self._status_callbacks.get(\"error\", [])\n        for callback in callbacks:\n            try:\n                result = callback(self.context, error)  # type: ignore[misc]\n                if inspect.iscoroutine(result):  # type: ignore[arg-type]\n                    await result\n            except Exception as e:\n                logger.error(\n                    \"Error callback error for operation %s: %s\",\n                    self.context.id,\n                    str(e),\n                    exc_info=True,\n                )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context = OperationContext(**context_kwargs)\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.token","title":"token  <code>property</code>","text":"<pre><code>token: LinkedCancelationToken\n</code></pre> <p>Get the cancellation token for this operation.</p> <p>Returns:</p> Type Description <code>LinkedCancelationToken</code> <p>The LinkedCancelationToken managing this operation's cancellation state.</p>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Cancelable | None\n</code></pre> <p>Get parent cancelable, returning None if garbage collected.</p>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.is_cancelled","title":"is_cancelled  <code>property</code>","text":"<pre><code>is_cancelled: bool\n</code></pre> <p>Check if operation is cancelled.</p>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Check if operation is running.</p>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.is_completed","title":"is_completed  <code>property</code>","text":"<pre><code>is_completed: bool\n</code></pre> <p>Check if operation completed successfully.</p>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.operation_id","title":"operation_id  <code>property</code>","text":"<pre><code>operation_id: str\n</code></pre> <p>Get operation ID.</p>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.add_source","title":"add_source","text":"<pre><code>add_source(source: CancelationSource) -&gt; Cancelable\n</code></pre> <p>Add a cancelation source to this operation.</p> <p>This allows adding custom or composite sources (like AllOfSource) to an existing Cancelable instance.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>CancelationSource</code> <p>The cancelation source to add</p> required <p>Returns:</p> Type Description <code>Cancelable</code> <p>Self for method chaining</p> Example <pre><code>from hother.cancelable.sources.composite import AllOfSource\n\ncancelable = Cancelable(name=\"my_op\")\nall_of = AllOfSource([timeout_source, condition_source])\ncancelable.add_source(all_of)\n</code></pre> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>def add_source(self, source: CancelationSource) -&gt; Cancelable:\n    \"\"\"Add a cancelation source to this operation.\n\n    This allows adding custom or composite sources (like AllOfSource) to an existing\n    Cancelable instance.\n\n    Args:\n        source: The cancelation source to add\n\n    Returns:\n        Self for method chaining\n\n    Example:\n        ```python\n        from hother.cancelable.sources.composite import AllOfSource\n\n        cancelable = Cancelable(name=\"my_op\")\n        all_of = AllOfSource([timeout_source, condition_source])\n        cancelable.add_source(all_of)\n        ```\n    \"\"\"\n    self._sources.append(source)\n    return self\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.with_timeout","title":"with_timeout  <code>classmethod</code>","text":"<pre><code>with_timeout(\n    timeout: float | timedelta,\n    operation_id: str | None = None,\n    name: str | None = None,\n    **kwargs: Any,\n) -&gt; Cancelable\n</code></pre> <p>Create cancelable with timeout.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | timedelta</code> <p>Timeout duration in seconds or timedelta</p> required <code>operation_id</code> <code>str | None</code> <p>Optional operation ID</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional operation name</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for Cancelable</p> <code>{}</code> <p>Returns:</p> Type Description <code>Cancelable</code> <p>Configured Cancelable instance</p> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>@classmethod\ndef with_timeout(\n    cls, timeout: float | timedelta, operation_id: str | None = None, name: str | None = None, **kwargs: Any\n) -&gt; Cancelable:\n    \"\"\"Create cancelable with timeout.\n\n    Args:\n        timeout: Timeout duration in seconds or timedelta\n        operation_id: Optional operation ID\n        name: Optional operation name\n        **kwargs: Additional arguments for Cancelable\n\n    Returns:\n        Configured Cancelable instance\n    \"\"\"\n    from hother.cancelable.sources.timeout import TimeoutSource\n\n    if isinstance(timeout, timedelta):\n        timeout = timeout.total_seconds()\n\n    instance = cls(operation_id=operation_id, name=name or f\"timeout_{timeout}s\", **kwargs)\n    instance._sources.append(TimeoutSource(timeout))\n    return instance\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.with_token","title":"with_token  <code>classmethod</code>","text":"<pre><code>with_token(\n    token: CancelationToken,\n    operation_id: str | None = None,\n    name: str | None = None,\n    **kwargs: Any,\n) -&gt; Cancelable\n</code></pre> <p>Create a Cancelable operation using an existing cancellation token.</p> <p>This factory method allows you to create a cancellable operation that shares a cancellation token with other operations, enabling coordinated cancellation.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>CancelationToken</code> <p>The CancelationToken to use for this operation</p> required <code>operation_id</code> <code>str | None</code> <p>Optional custom operation identifier</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional operation name (defaults to \"token_based\")</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to Cancelable constructor</p> <code>{}</code> <p>Returns:</p> Type Description <code>Cancelable</code> <p>A configured Cancelable instance using the provided token</p> Example <pre><code># Share a token between multiple operations\nshared_token = CancelationToken()\n\nasync with Cancelable.with_token(shared_token, name=\"task1\") as cancel1:\n    # ... operation 1 ...\n\nasync with Cancelable.with_token(shared_token, name=\"task2\") as cancel2:\n    # ... operation 2 ...\n\n# Cancel both operations via the shared token\nawait shared_token.cancel()\n</code></pre> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>@classmethod\ndef with_token(\n    cls, token: CancelationToken, operation_id: str | None = None, name: str | None = None, **kwargs: Any\n) -&gt; Cancelable:\n    \"\"\"Create a Cancelable operation using an existing cancellation token.\n\n    This factory method allows you to create a cancellable operation that shares\n    a cancellation token with other operations, enabling coordinated cancellation.\n\n    Args:\n        token: The CancelationToken to use for this operation\n        operation_id: Optional custom operation identifier\n        name: Optional operation name (defaults to \"token_based\")\n        **kwargs: Additional arguments passed to Cancelable constructor\n\n    Returns:\n        A configured Cancelable instance using the provided token\n\n    Example:\n        ```python\n        # Share a token between multiple operations\n        shared_token = CancelationToken()\n\n        async with Cancelable.with_token(shared_token, name=\"task1\") as cancel1:\n            # ... operation 1 ...\n\n        async with Cancelable.with_token(shared_token, name=\"task2\") as cancel2:\n            # ... operation 2 ...\n\n        # Cancel both operations via the shared token\n        await shared_token.cancel()\n        ```\n    \"\"\"\n    instance = cls(operation_id=operation_id, name=name or \"token_based\", **kwargs)\n    # Replace default token with provided one\n    logger.debug(f\"with_token: Replacing default token {instance._token.id} with user token {token.id}\")\n    instance._token = token\n    logger.debug(f\"with_token: Created cancelable {instance.context.id} with user token {token.id}\")\n    return instance\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.with_signal","title":"with_signal  <code>classmethod</code>","text":"<pre><code>with_signal(\n    *signals: int,\n    operation_id: str | None = None,\n    name: str | None = None,\n    **kwargs: Any,\n) -&gt; Cancelable\n</code></pre> <p>Create cancelable with signal handling.</p> <p>Parameters:</p> Name Type Description Default <code>*signals</code> <code>int</code> <p>Signal numbers to handle</p> <code>()</code> <code>operation_id</code> <code>str | None</code> <p>Optional operation ID</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional operation name</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for Cancelable</p> <code>{}</code> <p>Returns:</p> Type Description <code>Cancelable</code> <p>Configured Cancelable instance</p> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>@classmethod\ndef with_signal(cls, *signals: int, operation_id: str | None = None, name: str | None = None, **kwargs: Any) -&gt; Cancelable:\n    \"\"\"Create cancelable with signal handling.\n\n    Args:\n        *signals: Signal numbers to handle\n        operation_id: Optional operation ID\n        name: Optional operation name\n        **kwargs: Additional arguments for Cancelable\n\n    Returns:\n        Configured Cancelable instance\n    \"\"\"\n    from hother.cancelable.sources.signal import SignalSource\n\n    instance = cls(operation_id=operation_id, name=name or \"signal_based\", **kwargs)\n    instance._sources.append(SignalSource(*signals))\n    return instance\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.with_condition","title":"with_condition  <code>classmethod</code>","text":"<pre><code>with_condition(\n    condition: Callable[[], bool | Awaitable[bool]],\n    check_interval: float = 0.1,\n    condition_name: str | None = None,\n    operation_id: str | None = None,\n    name: str | None = None,\n    **kwargs: Any,\n) -&gt; Cancelable\n</code></pre> <p>Create cancelable with condition checking.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Callable[[], bool | Awaitable[bool]]</code> <p>Callable that returns True when cancelation should occur</p> required <code>check_interval</code> <code>float</code> <p>How often to check the condition (seconds)</p> <code>0.1</code> <code>condition_name</code> <code>str | None</code> <p>Name for the condition (for logging)</p> <code>None</code> <code>operation_id</code> <code>str | None</code> <p>Optional operation ID</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional operation name</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for Cancelable</p> <code>{}</code> <p>Returns:</p> Type Description <code>Cancelable</code> <p>Configured Cancelable instance</p> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>@classmethod\ndef with_condition(\n    cls,\n    condition: Callable[[], bool | Awaitable[bool]],\n    check_interval: float = 0.1,\n    condition_name: str | None = None,\n    operation_id: str | None = None,\n    name: str | None = None,\n    **kwargs: Any,\n) -&gt; Cancelable:\n    \"\"\"Create cancelable with condition checking.\n\n    Args:\n        condition: Callable that returns True when cancelation should occur\n        check_interval: How often to check the condition (seconds)\n        condition_name: Name for the condition (for logging)\n        operation_id: Optional operation ID\n        name: Optional operation name\n        **kwargs: Additional arguments for Cancelable\n\n    Returns:\n        Configured Cancelable instance\n    \"\"\"\n    from hother.cancelable.sources.condition import ConditionSource\n\n    instance = cls(operation_id=operation_id, name=name or \"condition_based\", **kwargs)\n    instance._sources.append(ConditionSource(condition, check_interval, condition_name))\n    return instance\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.combine","title":"combine","text":"<pre><code>combine(*others: Cancelable) -&gt; Cancelable\n</code></pre> <p>Combine multiple Cancelable operations into a single coordinated operation.</p> <p>Creates a new Cancelable that will be cancelled if ANY of the combined operations is cancelled. All cancellation sources from the combined operations are merged together.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Cancelable</code> <p>One or more Cancelable instances to combine with this one</p> <code>()</code> <p>Returns:</p> Type Description <code>Cancelable</code> <p>A new Cancelable instance that coordinates cancellation across all</p> <code>Cancelable</code> <p>combined operations. When entered, all operations' tokens are linked.</p> Example <pre><code># Combine timeout and signal handling\ntimeout_cancel = Cancelable.with_timeout(30.0)\nsignal_cancel = Cancelable.with_signal(signal.SIGTERM)\n\nasync with timeout_cancel.combine(signal_cancel) as cancel:\n    # Operation will cancel on either timeout OR signal\n    await long_running_operation()\n</code></pre> Note <p>The combined Cancelable preserves the cancellation reason from whichever source triggers first.</p> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>def combine(self, *others: Cancelable) -&gt; Cancelable:\n    \"\"\"Combine multiple Cancelable operations into a single coordinated operation.\n\n    Creates a new Cancelable that will be cancelled if ANY of the combined\n    operations is cancelled. All cancellation sources from the combined\n    operations are merged together.\n\n    Args:\n        *others: One or more Cancelable instances to combine with this one\n\n    Returns:\n        A new Cancelable instance that coordinates cancellation across all\n        combined operations. When entered, all operations' tokens are linked.\n\n    Example:\n        ```python\n        # Combine timeout and signal handling\n        timeout_cancel = Cancelable.with_timeout(30.0)\n        signal_cancel = Cancelable.with_signal(signal.SIGTERM)\n\n        async with timeout_cancel.combine(signal_cancel) as cancel:\n            # Operation will cancel on either timeout OR signal\n            await long_running_operation()\n        ```\n\n    Note:\n        The combined Cancelable preserves the cancellation reason from\n        whichever source triggers first.\n    \"\"\"\n    logger.debug(\"=== COMBINE CALLED ===\")\n    logger.debug(f\"Self: {self.context.id} ({self.context.name}) with token {self._token.id}\")\n    for i, other in enumerate(others):\n        logger.debug(f\"Other {i}: {other.context.id} ({other.context.name}) with token {other._token.id}\")\n\n    combined = Cancelable(\n        name=f\"combined_{self.context.name}\",\n        metadata={\n            \"sources\": [self.context.id] + [o.context.id for o in others],\n            \"combined\": True,\n            \"preserve_reason\": True,  # Add this flag\n        },\n    )\n\n    logger.debug(f\"Created combined cancelable: {combined.context.id} with default token {combined._token.id}\")\n\n    # Store the actual cancelables to link their tokens later\n    combined._cancellables_to_link = [self] + list(others)\n    logger.debug(f\"Will link to {len(combined._cancellables_to_link)} cancelables:\")\n    for i, c in enumerate(combined._cancellables_to_link):\n        logger.debug(f\"  {i}: {c.context.id} with token {c._token.id}\")\n\n    # Combine all sources\n    combined._sources.extend(self._sources)\n    for other in others:\n        combined._sources.extend(other._sources)\n\n    logger.debug(\n        \"Created combined cancelable\",\n        extra={\n            \"operation_id\": combined.context.id,\n            \"source_count\": len(combined._sources),\n        },\n    )\n\n    return combined\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.on_progress","title":"on_progress","text":"<pre><code>on_progress(callback: ProgressCallbackType) -&gt; Cancelable\n</code></pre> <p>Register a callback to be invoked when progress is reported.</p> <p>The callback will be called whenever <code>report_progress()</code> is invoked on this operation. Both sync and async callbacks are supported.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>ProgressCallbackType</code> <p>Function to call on progress updates. Receives: - operation_id (str): The ID of the operation - message (Any): The progress message - metadata (dict[str, Any] | None): Optional metadata</p> required <p>Returns:</p> Type Description <code>Cancelable</code> <p>Self for method chaining</p> Example <pre><code>async with Cancelable(name=\"download\") as cancel:\n    cancel.on_progress(lambda id, msg, meta: print(f\"Progress: {msg}\"))\n\n    for i in range(100):\n        await cancel.report_progress(f\"{i}% complete\")\n        await asyncio.sleep(0.1)\n</code></pre> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>def on_progress(\n    self,\n    callback: ProgressCallbackType,\n) -&gt; Cancelable:\n    \"\"\"Register a callback to be invoked when progress is reported.\n\n    The callback will be called whenever `report_progress()` is invoked\n    on this operation. Both sync and async callbacks are supported.\n\n    Args:\n        callback: Function to call on progress updates. Receives:\n            - operation_id (str): The ID of the operation\n            - message (Any): The progress message\n            - metadata (dict[str, Any] | None): Optional metadata\n\n    Returns:\n        Self for method chaining\n\n    Example:\n        ```python\n        async with Cancelable(name=\"download\") as cancel:\n            cancel.on_progress(lambda id, msg, meta: print(f\"Progress: {msg}\"))\n\n            for i in range(100):\n                await cancel.report_progress(f\"{i}% complete\")\n                await asyncio.sleep(0.1)\n        ```\n    \"\"\"\n    self._progress_callbacks.append(callback)\n    return self\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.on_start","title":"on_start","text":"<pre><code>on_start(callback: StatusCallbackType) -&gt; Cancelable\n</code></pre> <p>Register a callback to be invoked when the operation starts.</p> <p>The callback is triggered when entering the async context (on <code>__aenter__</code>).</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>StatusCallbackType</code> <p>Function receiving the OperationContext. Can be sync or async.</p> required <p>Returns:</p> Type Description <code>Cancelable</code> <p>Self for method chaining</p> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>def on_start(self, callback: StatusCallbackType) -&gt; Cancelable:\n    \"\"\"Register a callback to be invoked when the operation starts.\n\n    The callback is triggered when entering the async context (on `__aenter__`).\n\n    Args:\n        callback: Function receiving the OperationContext. Can be sync or async.\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self._status_callbacks[\"start\"].append(callback)\n    return self\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.on_complete","title":"on_complete","text":"<pre><code>on_complete(callback: StatusCallbackType) -&gt; Cancelable\n</code></pre> <p>Register a callback to be invoked when the operation completes successfully.</p> <p>The callback is triggered when exiting the context without cancellation or error.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>StatusCallbackType</code> <p>Function receiving the OperationContext. Can be sync or async.</p> required <p>Returns:</p> Type Description <code>Cancelable</code> <p>Self for method chaining</p> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>def on_complete(self, callback: StatusCallbackType) -&gt; Cancelable:\n    \"\"\"Register a callback to be invoked when the operation completes successfully.\n\n    The callback is triggered when exiting the context without cancellation or error.\n\n    Args:\n        callback: Function receiving the OperationContext. Can be sync or async.\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self._status_callbacks[\"complete\"].append(callback)\n    return self\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.on_cancel","title":"on_cancel","text":"<pre><code>on_cancel(callback: StatusCallbackType) -&gt; Cancelable\n</code></pre> <p>Register a callback to be invoked when the operation is cancelled.</p> <p>The callback is triggered when the operation is cancelled by any source (timeout, signal, token, condition, or parent cancellation).</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>StatusCallbackType</code> <p>Function receiving the OperationContext. Can be sync or async.</p> required <p>Returns:</p> Type Description <code>Cancelable</code> <p>Self for method chaining</p> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>def on_cancel(self, callback: StatusCallbackType) -&gt; Cancelable:\n    \"\"\"Register a callback to be invoked when the operation is cancelled.\n\n    The callback is triggered when the operation is cancelled by any source\n    (timeout, signal, token, condition, or parent cancellation).\n\n    Args:\n        callback: Function receiving the OperationContext. Can be sync or async.\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self._status_callbacks[\"cancel\"].append(callback)\n    return self\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.on_error","title":"on_error","text":"<pre><code>on_error(callback: ErrorCallbackType) -&gt; Cancelable\n</code></pre> <p>Register a callback to be invoked when the operation encounters an error.</p> <p>The callback is triggered when an exception (other than CancelledError) is raised within the operation context.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>ErrorCallbackType</code> <p>Function receiving the OperationContext and Exception. Can be sync or async.</p> required <p>Returns:</p> Type Description <code>Cancelable</code> <p>Self for method chaining</p> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>def on_error(\n    self,\n    callback: ErrorCallbackType,\n) -&gt; Cancelable:\n    \"\"\"Register a callback to be invoked when the operation encounters an error.\n\n    The callback is triggered when an exception (other than CancelledError)\n    is raised within the operation context.\n\n    Args:\n        callback: Function receiving the OperationContext and Exception.\n            Can be sync or async.\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self._status_callbacks[\"error\"].append(callback)\n    return self\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.report_progress","title":"report_progress  <code>async</code>","text":"<pre><code>report_progress(\n    message: Any, metadata: dict[str, Any] | None = None\n) -&gt; None\n</code></pre> <p>Report progress to all registered callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Any</code> <p>Progress message</p> required <code>metadata</code> <code>dict[str, Any] | None</code> <p>Optional metadata dict</p> <code>None</code> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>async def report_progress(self, message: Any, metadata: dict[str, Any] | None = None) -&gt; None:\n    \"\"\"Report progress to all registered callbacks.\n\n    Args:\n        message: Progress message\n        metadata: Optional metadata dict\n    \"\"\"\n    for callback in self._progress_callbacks:\n        try:\n            result = callback(self.context.id, message, metadata)\n            if inspect.iscoroutine(result):\n                await result\n        except Exception as e:\n            logger.error(\n                \"Progress callback error for operation %s: %s\",\n                self.context.id,\n                str(e),\n                exc_info=True,\n            )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.check_cancelation","title":"check_cancelation  <code>async</code>","text":"<pre><code>check_cancelation() -&gt; None\n</code></pre> <p>Check if operation is cancelled and raise if so.</p> <p>This is a public API for checking cancellation state. Use this instead of accessing <code>_token</code> directly.</p> <p>Raises:</p> Type Description <code>CancelledError</code> <p>If operation is cancelled</p> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>async def check_cancelation(self) -&gt; None:\n    \"\"\"Check if operation is cancelled and raise if so.\n\n    This is a public API for checking cancellation state.\n    Use this instead of accessing `_token` directly.\n\n    Raises:\n        anyio.CancelledError: If operation is cancelled\n    \"\"\"\n    await self._token.check_async()  # pragma: no cover\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.run_in_thread","title":"run_in_thread  <code>async</code>","text":"<pre><code>run_in_thread(\n    func: Callable[..., T], *args: Any, **kwargs: Any\n) -&gt; T\n</code></pre> <p>Run function in thread with proper context propagation.</p> <p>This method solves the context variable thread safety issue by ensuring that context variables (including _current_operation) are properly propagated to OS threads.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., T]</code> <p>Function to run in thread</p> required <code>*args</code> <code>Any</code> <p>Positional arguments for func</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for func</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>Result of func execution</p> Example <pre><code>async with Cancelable(name=\"main\") as cancel:\n    # Context is propagated to thread\n    result = await cancel.run_in_thread(expensive_computation, data)\n</code></pre> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>async def run_in_thread(self, func: Callable[..., T], *args: Any, **kwargs: Any) -&gt; T:\n    \"\"\"Run function in thread with proper context propagation.\n\n    This method solves the context variable thread safety issue by ensuring\n    that context variables (including _current_operation) are properly\n    propagated to OS threads.\n\n    Args:\n        func: Function to run in thread\n        *args: Positional arguments for func\n        **kwargs: Keyword arguments for func\n\n    Returns:\n        Result of func execution\n\n    Example:\n        ```python\n        async with Cancelable(name=\"main\") as cancel:\n            # Context is propagated to thread\n            result = await cancel.run_in_thread(expensive_computation, data)\n        ```\n    \"\"\"\n    # Store current context for thread propagation\n    ctx = ContextBridge.copy_context()\n\n    def thread_func():\n        # Restore context in thread\n        ContextBridge.restore_context(ctx)\n        # Set current operation in thread\n        _current_operation.set(self)\n        return func(*args, **kwargs)\n\n    # Run in thread with context\n    return await ContextBridge.run_in_thread_with_context(thread_func)\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.stream","title":"stream  <code>async</code>","text":"<pre><code>stream(\n    async_iter: AsyncIterator[T],\n    report_interval: int | None = None,\n    buffer_partial: bool = True,\n) -&gt; AsyncIterator[T]\n</code></pre> <p>Wrap async iterator with cancelation support.</p> <p>Parameters:</p> Name Type Description Default <code>async_iter</code> <code>AsyncIterator[T]</code> <p>Async iterator to wrap</p> required <code>report_interval</code> <code>int | None</code> <p>Report progress every N items</p> <code>None</code> <code>buffer_partial</code> <code>bool</code> <p>Whether to buffer items for partial results</p> <code>True</code> <p>Yields:</p> Type Description <code>AsyncIterator[T]</code> <p>Items from the wrapped iterator</p> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>async def stream(\n    self,\n    async_iter: AsyncIterator[T],\n    report_interval: int | None = None,\n    buffer_partial: bool = True,\n) -&gt; AsyncIterator[T]:\n    \"\"\"Wrap async iterator with cancelation support.\n\n    Args:\n        async_iter: Async iterator to wrap\n        report_interval: Report progress every N items\n        buffer_partial: Whether to buffer items for partial results\n\n    Yields:\n        Items from the wrapped iterator\n    \"\"\"\n    count = 0\n    buffer: list[T] = []\n\n    try:\n        async for item in async_iter:\n            # Check cancelation\n            await self._token.check_async()\n\n            yield item\n            count += 1\n\n            if buffer_partial:\n                buffer.append(item)\n                # Limit buffer size\n                if len(buffer) &gt; _MAX_BUFFER_SIZE:\n                    buffer = buffer[-_MAX_BUFFER_SIZE:]\n\n            if report_interval and count % report_interval == 0:\n                await self.report_progress(f\"Processed {count} items\", {\"count\": count, \"latest_item\": item})\n\n    except anyio.get_cancelled_exc_class():\n        # Save partial results\n        self.context.partial_result = {\n            \"count\": count,\n            \"buffer\": buffer if buffer_partial else None,\n        }\n        raise\n    except Exception:  # Intentionally broad to save partial results on any error\n        # Also save partial results on other exceptions\n        self.context.partial_result = {\n            \"count\": count,\n            \"buffer\": buffer if buffer_partial else None,\n            \"completed\": False,\n        }\n        raise\n    else:\n        # Save final results if completed normally\n        if buffer_partial or count &gt; 0:\n            self.context.partial_result = {\n                \"count\": count,\n                \"buffer\": buffer if buffer_partial else None,\n                \"completed\": True,\n            }\n    finally:\n        logger.debug(\n            \"Stream processing completed for operation %s with %d items\",\n            self.context.id,\n            count,\n        )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.wrap","title":"wrap","text":"<pre><code>wrap(\n    operation: Callable[..., Awaitable[R]],\n) -&gt; Callable[..., Awaitable[R]]\n</code></pre> <p>Wrap an async operation to automatically check for cancelation before execution.</p> <p>This is useful for retry loops and other patterns where you want automatic cancelation checking without manually accessing the token.</p> <p>Note: This assumes the cancelable context is already active (you're inside an <code>async with</code> block). It does NOT create a new context.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>Callable[..., Awaitable[R]]</code> <p>Async callable to wrap</p> required <p>Returns:</p> Type Description <code>Callable[..., Awaitable[R]]</code> <p>Wrapped callable that checks cancelation before executing</p> Example <pre><code>async with Cancelable.with_timeout(30) as cancel:\n    wrapped_fetch = cancel.wrap(fetch_data)\n\n    # In a retry loop\n    for attempt in range(3):\n        try:\n            result = await wrapped_fetch(url)\n            break\n        except Exception:\n            await anyio.sleep(1)\n</code></pre> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>def wrap(self, operation: Callable[..., Awaitable[R]]) -&gt; Callable[..., Awaitable[R]]:\n    \"\"\"Wrap an async operation to automatically check for cancelation before execution.\n\n    This is useful for retry loops and other patterns where you want automatic\n    cancelation checking without manually accessing the token.\n\n    Note: This assumes the cancelable context is already active (you're inside\n    an `async with` block). It does NOT create a new context.\n\n    Args:\n        operation: Async callable to wrap\n\n    Returns:\n        Wrapped callable that checks cancelation before executing\n\n    Example:\n        ```python\n        async with Cancelable.with_timeout(30) as cancel:\n            wrapped_fetch = cancel.wrap(fetch_data)\n\n            # In a retry loop\n            for attempt in range(3):\n                try:\n                    result = await wrapped_fetch(url)\n                    break\n                except Exception:\n                    await anyio.sleep(1)\n        ```\n    \"\"\"\n\n    @wraps(operation)\n    async def wrapped(*args: Any, **kwargs: Any) -&gt; R:\n        # Check cancelation before executing\n        await self._token.check_async()\n        return await operation(*args, **kwargs)\n\n    return wrapped\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.wrapping","title":"wrapping  <code>async</code>","text":"<pre><code>wrapping() -&gt; AsyncIterator[Callable[..., Awaitable[R]]]\n</code></pre> <p>Async context manager that yields a wrap function for scoped operation wrapping.</p> <p>The yielded wrap function checks cancelation before executing any operation. This is useful for retry loops where you want all operations in a scope to be automatically wrapped with cancelation checking.</p> <p>Yields:</p> Type Description <code>AsyncIterator[Callable[..., Awaitable[R]]]</code> <p>A wrap function that checks cancelation before executing operations</p> Example <pre><code>from tenacity import AsyncRetrying, stop_after_attempt\n\nasync with Cancelable.with_timeout(30) as cancel:\n    async for attempt in AsyncRetrying(stop=stop_after_attempt(3)):\n        with attempt:\n            async with cancel.wrapping() as wrap:\n                result = await wrap(fetch_data, url)\n</code></pre> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>@asynccontextmanager\nasync def wrapping(self) -&gt; AsyncIterator[Callable[..., Awaitable[R]]]:\n    \"\"\"Async context manager that yields a wrap function for scoped operation wrapping.\n\n    The yielded wrap function checks cancelation before executing any operation.\n    This is useful for retry loops where you want all operations in a scope to\n    be automatically wrapped with cancelation checking.\n\n    Yields:\n        A wrap function that checks cancelation before executing operations\n\n    Example:\n        ```python\n        from tenacity import AsyncRetrying, stop_after_attempt\n\n        async with Cancelable.with_timeout(30) as cancel:\n            async for attempt in AsyncRetrying(stop=stop_after_attempt(3)):\n                with attempt:\n                    async with cancel.wrapping() as wrap:\n                        result = await wrap(fetch_data, url)\n        ```\n    \"\"\"\n\n    async def wrap_fn(fn: Callable[..., Awaitable[R]], *args: Any, **kwargs: Any) -&gt; R:\n        await self._token.check_async()\n        return await fn(*args, **kwargs)\n\n    yield wrap_fn\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.shield","title":"shield  <code>async</code>","text":"<pre><code>shield() -&gt; AsyncIterator[Cancelable]\n</code></pre> <p>Shield a section from cancelation.</p> <p>Creates a child operation that is protected from cancelation but still participates in the operation hierarchy for monitoring and tracking.</p> <p>Yields:</p> Type Description <code>AsyncIterator[Cancelable]</code> <p>A new Cancelable for the shielded section</p> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>@asynccontextmanager\nasync def shield(self) -&gt; AsyncIterator[Cancelable]:\n    \"\"\"Shield a section from cancelation.\n\n    Creates a child operation that is protected from cancelation but still\n    participates in the operation hierarchy for monitoring and tracking.\n\n    Yields:\n        A new Cancelable for the shielded section\n    \"\"\"\n    # Create properly integrated child cancelable\n    shielded = Cancelable(name=f\"{self.context.name}_shielded\", metadata={\"shielded\": True})\n    # Manually set parent relationship for hierarchy tracking but don't add to _children\n    # to prevent automatic cancelation propagation\n    shielded.context.parent_id = self.context.id\n\n    # Override token linking to prevent cancelation propagation\n    # The shielded operation should not be cancelled by parent token\n    shielded._token = LinkedCancelationToken()  # Fresh token, no parent linking\n\n    # Use anyio's CancelScope with shield=True\n    with anyio.CancelScope(shield=True) as shield_scope:\n        self._shields.append(shield_scope)\n        try:\n            shielded.context.update_status(OperationStatus.SHIELDED)\n            yield shielded\n        finally:\n            # Shield is always in list at this point (added at line 783)\n            self._shields.remove(shield_scope)\n\n    # Force a checkpoint after shield to allow cancelation to propagate\n    # We need to be in an async context for this to work properly\n    try:\n        await anyio.lowlevel.checkpoint()  # type: ignore[attr-defined]\n    except:\n        # Re-raise any exception including CancelledError\n        raise\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.cancelable.Cancelable.cancel","title":"cancel  <code>async</code>","text":"<pre><code>cancel(\n    reason: CancelationReason = MANUAL,\n    message: str | None = None,\n    propagate_to_children: bool = True,\n) -&gt; None\n</code></pre> <p>Cancel the operation.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>CancelationReason</code> <p>Reason for cancelation</p> <code>MANUAL</code> <code>message</code> <code>str | None</code> <p>Optional cancelation message</p> <code>None</code> <code>propagate_to_children</code> <code>bool</code> <p>Whether to cancel child operations</p> <code>True</code> Source code in <code>src/hother/cancelable/core/cancelable.py</code> <pre><code>async def cancel(\n    self,\n    reason: CancelationReason = CancelationReason.MANUAL,\n    message: str | None = None,\n    propagate_to_children: bool = True,\n) -&gt; None:\n    \"\"\"Cancel the operation.\n\n    Args:\n        reason: Reason for cancelation\n        message: Optional cancelation message\n        propagate_to_children: Whether to cancel child operations\n    \"\"\"\n    # Cancel our token\n    await self._token.cancel(reason, message)\n\n    # Cancel children if requested\n    if propagate_to_children:\n        children_to_cancel = list(self._children)  # Snapshot to avoid modification during iteration\n        for child in children_to_cancel:\n            if child and not child.is_cancelled:\n                await child.cancel(\n                    CancelationReason.PARENT,\n                    f\"Parent operation {self.context.id[:8]} cancelled\",\n                    propagate_to_children=True,\n                )\n\n    # Clear references to help GC after cancelation\n    self._children.clear()\n    self._parent_ref = None\n\n    # Log without duplicating cancel_reason\n    log_ctx = self.context.log_context()\n    # Remove cancel_reason from log_context if it exists to avoid duplication\n    log_ctx.pop(\"cancel_reason\", None)\n\n    logger.info(\n        \"Operation cancelled\",\n        extra={\n            **log_ctx,\n            \"cancel_reason\": reason.value,\n            \"cancel_message\": message,\n        },\n    )\n</code></pre>"},{"location":"reference/core/#cancelation-tokens","title":"Cancelation Tokens","text":""},{"location":"reference/core/#cancelationtoken","title":"CancelationToken","text":"<p>Thread-safe token for manual cancelation.</p>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken","title":"hother.cancelable.core.token.CancelationToken","text":"<p>               Bases: <code>BaseModel</code></p> <p>Thread-safe cancelation token that can be shared across tasks.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique token identifier</p> <code>is_cancelled</code> <code>bool</code> <p>Whether the token has been cancelled</p> <code>reason</code> <code>CancelationReason | None</code> <p>Reason for cancelation</p> <code>message</code> <code>str | None</code> <p>Optional cancelation message</p> <code>cancelled_at</code> <code>datetime | None</code> <p>When the token was cancelled</p> Source code in <code>src/hother/cancelable/core/token.py</code> <pre><code>class CancelationToken(BaseModel):\n    \"\"\"Thread-safe cancelation token that can be shared across tasks.\n\n    Attributes:\n        id: Unique token identifier\n        is_cancelled: Whether the token has been cancelled\n        reason: Reason for cancelation\n        message: Optional cancelation message\n        cancelled_at: When the token was cancelled\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    is_cancelled: bool = False\n    reason: CancelationReason | None = None\n    message: str | None = None\n    cancelled_at: datetime | None = None\n\n    # Private fields using PrivateAttr\n    _event: Any = PrivateAttr(default=None)\n    _lock: Any = PrivateAttr(default=None)\n    _state_lock: Any = PrivateAttr(default=None)  # Thread-safe lock for state updates\n    _callbacks: Any = PrivateAttr(default=None)\n\n    def __init__(self, **data: Any) -&gt; None:\n        super().__init__(**data)\n        self._event = anyio.Event()\n        self._lock = anyio.Lock()\n        self._state_lock = threading.Lock()  # Thread-safe lock for state updates\n        self._callbacks = []\n\n        logger.debug(f\"Created cancelation token {self.id}\")\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Make token hashable based on ID.\"\"\"\n        return hash(self.id)\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality based on ID.\"\"\"\n        if not isinstance(other, CancelationToken):\n            return False\n        return self.id == other.id\n\n    async def cancel(\n        self,\n        reason: CancelationReason = CancelationReason.MANUAL,\n        message: str | None = None,\n    ) -&gt; bool:\n        \"\"\"Cancel the token.\n\n        Args:\n            reason: Reason for cancelation\n            message: Optional cancelation message\n\n        Returns:\n            True if token was cancelled, False if already cancelled\n        \"\"\"\n        logger.info(f\"=== CANCEL CALLED on token {self.id} ===\")\n        async with self._lock:\n            if self.is_cancelled:\n                logger.debug(\n                    \"Token already cancelled\",\n                    extra={\n                        \"token_id\": self.id,\n                        \"original_reason\": self.reason.value if self.reason else None,\n                    },\n                )\n                return False\n\n            self.is_cancelled = True\n            self.reason = reason\n            self.message = message\n            self.cancelled_at = datetime.now(UTC)\n            self._event.set()\n\n            logger.info(\n                f\"Token {self.id} cancelled - calling {len(self._callbacks)} callbacks\",\n                extra={\n                    \"token_id\": self.id,\n                    \"reason\": reason.value,\n                    \"cancel_message\": message,\n                    \"callback_count\": len(self._callbacks),\n                },\n            )\n\n            # Notify callbacks\n            for i, callback in enumerate(list(self._callbacks)):\n                try:\n                    logger.debug(f\"Calling callback {i} for token {self.id}\")\n                    await callback(self)\n                    logger.debug(f\"Callback {i} completed successfully\")\n                except Exception as e:\n                    logger.error(\n                        \"Error in cancelation callback\",\n                        extra={\n                            \"token_id\": self.id,\n                            \"callback_index\": i,\n                            \"error\": str(e),\n                        },\n                        exc_info=True,\n                    )\n\n            logger.info(f\"=== CANCEL COMPLETED for token {self.id} ===\")\n            return True\n\n    def cancel_sync(\n        self,\n        reason: CancelationReason = CancelationReason.MANUAL,\n        message: str | None = None,\n    ) -&gt; bool:\n        \"\"\"Thread-safe synchronous cancelation from any thread.\n\n        This method can be called from regular Python threads (pynput, signal handlers, etc.)\n        and will safely cancel the token and notify async waiters via the anyio bridge.\n\n        Args:\n            reason: Reason for cancelation\n            message: Optional cancelation message\n\n        Returns:\n            True if token was cancelled, False if already cancelled\n\n        Example:\n            ```python\n            def on_signal(signum):\n                # Called from signal handler thread\n                token.cancel_sync(CancelationReason.SIGNAL)\n            ```\n        \"\"\"\n        logger.info(f\"=== CANCEL_SYNC CALLED on token {self.id} from thread ===\")\n\n        # Update state with thread-safe lock\n        with self._state_lock:\n            if self.is_cancelled:\n                logger.debug(\n                    \"Token already cancelled\",\n                    extra={\n                        \"token_id\": self.id,\n                        \"original_reason\": self.reason.value if self.reason else None,\n                    },\n                )\n                return False\n\n            self.is_cancelled = True\n            self.reason = reason\n            self.message = message\n            self.cancelled_at = datetime.now(UTC)\n\n        logger.debug(\n            f\"Token {self.id} cancelled (sync) - notifying async waiters\",\n            extra={\n                \"token_id\": self.id,\n                \"reason\": reason.value,\n                \"cancel_message\": message,\n            },\n        )\n\n        # Notify async waiters (thread-safe)\n        self._notify_async_waiters()\n\n        # Schedule callbacks (thread-safe)\n        self._schedule_callbacks()\n\n        logger.debug(f\"=== CANCEL_SYNC COMPLETED for token {self.id} ===\")\n        return True\n\n    def _notify_async_waiters(self) -&gt; None:\n        \"\"\"Set the anyio event from a thread.\n\n        Uses the anyio bridge to safely set the event in the anyio context.\n        \"\"\"\n\n        def set_event() -&gt; None:\n            self._event.set()\n\n        call_soon_threadsafe(set_event)\n\n    def _schedule_callbacks(self) -&gt; None:\n        \"\"\"Schedule callbacks to run in the anyio context.\n\n        Uses the anyio bridge to safely execute callbacks from a thread.\n        \"\"\"\n        # Take snapshot of callbacks with thread-safe lock\n        with self._state_lock:\n            callbacks_to_call = list(self._callbacks)\n\n        logger.debug(\n            f\"Scheduling {len(callbacks_to_call)} callbacks for token {self.id}\",\n            extra={\n                \"token_id\": self.id,\n                \"callback_count\": len(callbacks_to_call),\n            },\n        )\n\n        # Schedule each callback via bridge\n        for i, callback in enumerate(callbacks_to_call):\n\n            async def run_callback(idx: int = i, cb: Any = callback) -&gt; None:  # Capture loop variables\n                try:\n                    logger.debug(f\"Calling callback {idx} for token {self.id}\")\n                    await cb(self)\n                    logger.debug(f\"Callback {idx} completed successfully\")\n                except Exception as e:\n                    logger.error(\n                        \"Error in cancelation callback\",\n                        exc_info=True,\n                        extra={\"token_id\": self.id, \"callback_index\": idx, \"error\": str(e)},\n                    )\n\n            call_soon_threadsafe(run_callback)\n\n    async def wait_for_cancel(self) -&gt; None:\n        \"\"\"Wait until token is cancelled.\"\"\"\n        await self._event.wait()\n\n    def check(self) -&gt; None:\n        \"\"\"Check if cancelled and raise exception if so.\n\n        Raises:\n            ManualCancelation: If token is cancelled\n        \"\"\"\n        if self.is_cancelled:\n            logger.debug(\"Token check triggered cancelation\", extra={\"token_id\": self.id})\n            raise ManualCancelation(\n                message=self.message or \"Operation cancelled via token\",\n            )\n\n    async def check_async(self) -&gt; None:\n        \"\"\"Async version of check that allows for proper async cancelation.\n\n        Raises:\n            anyio.CancelledError: If token is cancelled\n        \"\"\"\n        if self.is_cancelled:\n            logger.debug(\"Token async check triggered cancelation\", extra={\"token_id\": self.id})\n            raise anyio.get_cancelled_exc_class()(self.message or \"Operation cancelled via token\")\n\n    def is_cancelation_requested(self) -&gt; bool:\n        \"\"\"Non-throwing check for cancelation.\n\n        Returns:\n            True if cancelation has been requested\n        \"\"\"\n        return self.is_cancelled\n\n    async def register_callback(self, callback: Callable[[CancelationToken], Awaitable[None]]) -&gt; None:\n        \"\"\"Register a callback to be called on cancelation.\n\n        The callback should accept the token as its only argument.\n\n        Args:\n            callback: Async callable that accepts the token\n        \"\"\"\n        logger.info(f\"Registering callback for token {self.id} (currently {len(self._callbacks)} callbacks)\")\n        async with self._lock:\n            self._callbacks.append(callback)\n            logger.info(f\"Callback registered. Now {len(self._callbacks)} callbacks for token {self.id}\")\n\n            # If already cancelled, call immediately\n            if self.is_cancelled:\n                logger.info(f\"Token {self.id} already cancelled, calling callback immediately\")\n                try:\n                    await callback(self)\n                except Exception as e:\n                    logger.error(\n                        \"Error in immediate cancelation callback\",\n                        extra={\n                            \"token_id\": self.id,\n                            \"error\": str(e),\n                        },\n                        exc_info=True,\n                    )\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation of token.\"\"\"\n        if self.is_cancelled:\n            return f\"CancelationToken(id={self.id[:8]}, cancelled={self.reason.value if self.reason else 'unknown'})\"\n        return f\"CancelationToken(id={self.id[:8]}, active)\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed representation of token.\"\"\"\n        return (\n            f\"CancelationToken(id='{self.id}', is_cancelled={self.is_cancelled}, \"\n            f\"reason={self.reason}, message='{self.message}')\"\n        )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(default_factory=lambda: str(uuid4()))\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken.is_cancelled","title":"is_cancelled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_cancelled: bool = False\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken.reason","title":"reason  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reason: CancelationReason | None = None\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str | None = None\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken.cancelled_at","title":"cancelled_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cancelled_at: datetime | None = None\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken.cancel","title":"cancel  <code>async</code>","text":"<pre><code>cancel(\n    reason: CancelationReason = MANUAL,\n    message: str | None = None,\n) -&gt; bool\n</code></pre> <p>Cancel the token.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>CancelationReason</code> <p>Reason for cancelation</p> <code>MANUAL</code> <code>message</code> <code>str | None</code> <p>Optional cancelation message</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if token was cancelled, False if already cancelled</p> Source code in <code>src/hother/cancelable/core/token.py</code> <pre><code>async def cancel(\n    self,\n    reason: CancelationReason = CancelationReason.MANUAL,\n    message: str | None = None,\n) -&gt; bool:\n    \"\"\"Cancel the token.\n\n    Args:\n        reason: Reason for cancelation\n        message: Optional cancelation message\n\n    Returns:\n        True if token was cancelled, False if already cancelled\n    \"\"\"\n    logger.info(f\"=== CANCEL CALLED on token {self.id} ===\")\n    async with self._lock:\n        if self.is_cancelled:\n            logger.debug(\n                \"Token already cancelled\",\n                extra={\n                    \"token_id\": self.id,\n                    \"original_reason\": self.reason.value if self.reason else None,\n                },\n            )\n            return False\n\n        self.is_cancelled = True\n        self.reason = reason\n        self.message = message\n        self.cancelled_at = datetime.now(UTC)\n        self._event.set()\n\n        logger.info(\n            f\"Token {self.id} cancelled - calling {len(self._callbacks)} callbacks\",\n            extra={\n                \"token_id\": self.id,\n                \"reason\": reason.value,\n                \"cancel_message\": message,\n                \"callback_count\": len(self._callbacks),\n            },\n        )\n\n        # Notify callbacks\n        for i, callback in enumerate(list(self._callbacks)):\n            try:\n                logger.debug(f\"Calling callback {i} for token {self.id}\")\n                await callback(self)\n                logger.debug(f\"Callback {i} completed successfully\")\n            except Exception as e:\n                logger.error(\n                    \"Error in cancelation callback\",\n                    extra={\n                        \"token_id\": self.id,\n                        \"callback_index\": i,\n                        \"error\": str(e),\n                    },\n                    exc_info=True,\n                )\n\n        logger.info(f\"=== CANCEL COMPLETED for token {self.id} ===\")\n        return True\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken.cancel_sync","title":"cancel_sync","text":"<pre><code>cancel_sync(\n    reason: CancelationReason = MANUAL,\n    message: str | None = None,\n) -&gt; bool\n</code></pre> <p>Thread-safe synchronous cancelation from any thread.</p> <p>This method can be called from regular Python threads (pynput, signal handlers, etc.) and will safely cancel the token and notify async waiters via the anyio bridge.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>CancelationReason</code> <p>Reason for cancelation</p> <code>MANUAL</code> <code>message</code> <code>str | None</code> <p>Optional cancelation message</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if token was cancelled, False if already cancelled</p> Example <pre><code>def on_signal(signum):\n    # Called from signal handler thread\n    token.cancel_sync(CancelationReason.SIGNAL)\n</code></pre> Source code in <code>src/hother/cancelable/core/token.py</code> <pre><code>def cancel_sync(\n    self,\n    reason: CancelationReason = CancelationReason.MANUAL,\n    message: str | None = None,\n) -&gt; bool:\n    \"\"\"Thread-safe synchronous cancelation from any thread.\n\n    This method can be called from regular Python threads (pynput, signal handlers, etc.)\n    and will safely cancel the token and notify async waiters via the anyio bridge.\n\n    Args:\n        reason: Reason for cancelation\n        message: Optional cancelation message\n\n    Returns:\n        True if token was cancelled, False if already cancelled\n\n    Example:\n        ```python\n        def on_signal(signum):\n            # Called from signal handler thread\n            token.cancel_sync(CancelationReason.SIGNAL)\n        ```\n    \"\"\"\n    logger.info(f\"=== CANCEL_SYNC CALLED on token {self.id} from thread ===\")\n\n    # Update state with thread-safe lock\n    with self._state_lock:\n        if self.is_cancelled:\n            logger.debug(\n                \"Token already cancelled\",\n                extra={\n                    \"token_id\": self.id,\n                    \"original_reason\": self.reason.value if self.reason else None,\n                },\n            )\n            return False\n\n        self.is_cancelled = True\n        self.reason = reason\n        self.message = message\n        self.cancelled_at = datetime.now(UTC)\n\n    logger.debug(\n        f\"Token {self.id} cancelled (sync) - notifying async waiters\",\n        extra={\n            \"token_id\": self.id,\n            \"reason\": reason.value,\n            \"cancel_message\": message,\n        },\n    )\n\n    # Notify async waiters (thread-safe)\n    self._notify_async_waiters()\n\n    # Schedule callbacks (thread-safe)\n    self._schedule_callbacks()\n\n    logger.debug(f\"=== CANCEL_SYNC COMPLETED for token {self.id} ===\")\n    return True\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken.wait_for_cancel","title":"wait_for_cancel  <code>async</code>","text":"<pre><code>wait_for_cancel() -&gt; None\n</code></pre> <p>Wait until token is cancelled.</p> Source code in <code>src/hother/cancelable/core/token.py</code> <pre><code>async def wait_for_cancel(self) -&gt; None:\n    \"\"\"Wait until token is cancelled.\"\"\"\n    await self._event.wait()\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken.check","title":"check","text":"<pre><code>check() -&gt; None\n</code></pre> <p>Check if cancelled and raise exception if so.</p> <p>Raises:</p> Type Description <code>ManualCancelation</code> <p>If token is cancelled</p> Source code in <code>src/hother/cancelable/core/token.py</code> <pre><code>def check(self) -&gt; None:\n    \"\"\"Check if cancelled and raise exception if so.\n\n    Raises:\n        ManualCancelation: If token is cancelled\n    \"\"\"\n    if self.is_cancelled:\n        logger.debug(\"Token check triggered cancelation\", extra={\"token_id\": self.id})\n        raise ManualCancelation(\n            message=self.message or \"Operation cancelled via token\",\n        )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken.check_async","title":"check_async  <code>async</code>","text":"<pre><code>check_async() -&gt; None\n</code></pre> <p>Async version of check that allows for proper async cancelation.</p> <p>Raises:</p> Type Description <code>CancelledError</code> <p>If token is cancelled</p> Source code in <code>src/hother/cancelable/core/token.py</code> <pre><code>async def check_async(self) -&gt; None:\n    \"\"\"Async version of check that allows for proper async cancelation.\n\n    Raises:\n        anyio.CancelledError: If token is cancelled\n    \"\"\"\n    if self.is_cancelled:\n        logger.debug(\"Token async check triggered cancelation\", extra={\"token_id\": self.id})\n        raise anyio.get_cancelled_exc_class()(self.message or \"Operation cancelled via token\")\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken.is_cancelation_requested","title":"is_cancelation_requested","text":"<pre><code>is_cancelation_requested() -&gt; bool\n</code></pre> <p>Non-throwing check for cancelation.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if cancelation has been requested</p> Source code in <code>src/hother/cancelable/core/token.py</code> <pre><code>def is_cancelation_requested(self) -&gt; bool:\n    \"\"\"Non-throwing check for cancelation.\n\n    Returns:\n        True if cancelation has been requested\n    \"\"\"\n    return self.is_cancelled\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.CancelationToken.register_callback","title":"register_callback  <code>async</code>","text":"<pre><code>register_callback(\n    callback: Callable[[CancelationToken], Awaitable[None]],\n) -&gt; None\n</code></pre> <p>Register a callback to be called on cancelation.</p> <p>The callback should accept the token as its only argument.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[CancelationToken], Awaitable[None]]</code> <p>Async callable that accepts the token</p> required Source code in <code>src/hother/cancelable/core/token.py</code> <pre><code>async def register_callback(self, callback: Callable[[CancelationToken], Awaitable[None]]) -&gt; None:\n    \"\"\"Register a callback to be called on cancelation.\n\n    The callback should accept the token as its only argument.\n\n    Args:\n        callback: Async callable that accepts the token\n    \"\"\"\n    logger.info(f\"Registering callback for token {self.id} (currently {len(self._callbacks)} callbacks)\")\n    async with self._lock:\n        self._callbacks.append(callback)\n        logger.info(f\"Callback registered. Now {len(self._callbacks)} callbacks for token {self.id}\")\n\n        # If already cancelled, call immediately\n        if self.is_cancelled:\n            logger.info(f\"Token {self.id} already cancelled, calling callback immediately\")\n            try:\n                await callback(self)\n            except Exception as e:\n                logger.error(\n                    \"Error in immediate cancelation callback\",\n                    extra={\n                        \"token_id\": self.id,\n                        \"error\": str(e),\n                    },\n                    exc_info=True,\n                )\n</code></pre>"},{"location":"reference/core/#linkedcancelationtoken","title":"LinkedCancelationToken","text":"<p>Token that combines multiple cancelation tokens.</p>"},{"location":"reference/core/#hother.cancelable.core.token.LinkedCancelationToken","title":"hother.cancelable.core.token.LinkedCancelationToken","text":"<p>               Bases: <code>CancelationToken</code></p> <p>Cancelation token that can be linked to other tokens.</p> <p>When any linked token is cancelled, this token is also cancelled.</p> Source code in <code>src/hother/cancelable/core/token.py</code> <pre><code>class LinkedCancelationToken(CancelationToken):\n    \"\"\"Cancelation token that can be linked to other tokens.\n\n    When any linked token is cancelled, this token is also cancelled.\n    \"\"\"\n\n    def __init__(self, **data: Any) -&gt; None:\n        super().__init__(**data)\n        self._linked_tokens: list[CancelationToken] = []  # Use regular list instead of WeakSet for now\n\n    async def link(self, token: CancelationToken, preserve_reason: bool = False) -&gt; None:\n        \"\"\"Link this token to another token.\n\n        When the linked token is cancelled, this token will also be cancelled.\n\n        Args:\n            token: Token to link to\n            preserve_reason: Whether to preserve the original cancelation reason\n        \"\"\"\n\n        async def on_linked_cancel(linked_token: CancelationToken):\n            if preserve_reason and linked_token.reason:\n                # Preserve the original reason for combined cancelables\n                await self.cancel(\n                    reason=linked_token.reason,\n                    message=linked_token.message or f\"Linked token {linked_token.id[:8]} was cancelled\",\n                )\n            else:\n                # Use PARENT for true parent-child relationships\n                await self.cancel(\n                    reason=CancelationReason.PARENT,\n                    message=f\"Linked token {linked_token.id[:8]} was cancelled\",\n                )\n\n        await token.register_callback(on_linked_cancel)\n        self._linked_tokens.append(token)\n\n        logger.debug(\n            \"Linked cancelation tokens\",\n            extra={\"token_id\": self.id, \"linked_token_id\": token.id, \"preserve_reason\": preserve_reason},\n        )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.token.LinkedCancelationToken.link","title":"link  <code>async</code>","text":"<pre><code>link(\n    token: CancelationToken, preserve_reason: bool = False\n) -&gt; None\n</code></pre> <p>Link this token to another token.</p> <p>When the linked token is cancelled, this token will also be cancelled.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>CancelationToken</code> <p>Token to link to</p> required <code>preserve_reason</code> <code>bool</code> <p>Whether to preserve the original cancelation reason</p> <code>False</code> Source code in <code>src/hother/cancelable/core/token.py</code> <pre><code>async def link(self, token: CancelationToken, preserve_reason: bool = False) -&gt; None:\n    \"\"\"Link this token to another token.\n\n    When the linked token is cancelled, this token will also be cancelled.\n\n    Args:\n        token: Token to link to\n        preserve_reason: Whether to preserve the original cancelation reason\n    \"\"\"\n\n    async def on_linked_cancel(linked_token: CancelationToken):\n        if preserve_reason and linked_token.reason:\n            # Preserve the original reason for combined cancelables\n            await self.cancel(\n                reason=linked_token.reason,\n                message=linked_token.message or f\"Linked token {linked_token.id[:8]} was cancelled\",\n            )\n        else:\n            # Use PARENT for true parent-child relationships\n            await self.cancel(\n                reason=CancelationReason.PARENT,\n                message=f\"Linked token {linked_token.id[:8]} was cancelled\",\n            )\n\n    await token.register_callback(on_linked_cancel)\n    self._linked_tokens.append(token)\n\n    logger.debug(\n        \"Linked cancelation tokens\",\n        extra={\"token_id\": self.id, \"linked_token_id\": token.id, \"preserve_reason\": preserve_reason},\n    )\n</code></pre>"},{"location":"reference/core/#models-and-status","title":"Models and Status","text":""},{"location":"reference/core/#operationcontext","title":"OperationContext","text":"<p>Tracks the state and metadata of a cancelable operation.</p>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext","title":"hother.cancelable.core.models.OperationContext","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete operation context with metadata and status tracking.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique operation identifier</p> <code>name</code> <code>str | None</code> <p>Human-readable operation name</p> <code>status</code> <code>OperationStatus</code> <p>Current operation status</p> <code>start_time</code> <code>datetime</code> <p>When the operation started</p> <code>end_time</code> <code>datetime | None</code> <p>When the operation ended (if applicable)</p> <code>cancel_reason</code> <code>CancelationReason | None</code> <p>Reason for cancelation (if cancelled)</p> <code>cancel_message</code> <code>str | None</code> <p>Additional cancelation message</p> <code>error</code> <code>str | None</code> <p>Error message (if failed)</p> <code>partial_result</code> <code>Any | None</code> <p>Any partial results before cancelation</p> <code>metadata</code> <code>dict[str, Any]</code> <p>Additional operation metadata</p> <code>parent_id</code> <code>str | None</code> <p>Parent operation ID (for nested operations)</p> <code>child_ids</code> <code>set[str]</code> <p>Set of child operation IDs</p> Source code in <code>src/hother/cancelable/core/models.py</code> <pre><code>class OperationContext(BaseModel):\n    \"\"\"Complete operation context with metadata and status tracking.\n\n    Attributes:\n        id: Unique operation identifier\n        name: Human-readable operation name\n        status: Current operation status\n        start_time: When the operation started\n        end_time: When the operation ended (if applicable)\n        cancel_reason: Reason for cancelation (if cancelled)\n        cancel_message: Additional cancelation message\n        error: Error message (if failed)\n        partial_result: Any partial results before cancelation\n        metadata: Additional operation metadata\n        parent_id: Parent operation ID (for nested operations)\n        child_ids: Set of child operation IDs\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    name: str | None = None\n    status: OperationStatus = OperationStatus.PENDING\n    start_time: datetime = Field(default_factory=lambda: datetime.now(UTC))\n    end_time: datetime | None = None\n    cancel_reason: CancelationReason | None = None\n    cancel_message: str | None = None\n    error: str | None = None\n    partial_result: Any | None = None\n    metadata: dict[str, Any] = Field(default_factory=dict)\n    parent_id: str | None = None\n    child_ids: set[str] = Field(default_factory=set)\n\n    @property\n    def duration(self) -&gt; timedelta | None:\n        \"\"\"Calculate operation duration.\"\"\"\n        if self.end_time:\n            return self.end_time - self.start_time\n        if self.status == OperationStatus.RUNNING:\n            return datetime.now(UTC) - self.start_time\n        return None\n\n    @property\n    def duration_seconds(self) -&gt; float | None:\n        \"\"\"Get duration in seconds.\"\"\"\n        duration = self.duration\n        return duration.total_seconds() if duration else None\n\n    @property\n    def is_terminal(self) -&gt; bool:\n        \"\"\"Check if operation is in terminal state.\"\"\"\n        return self.status in {\n            OperationStatus.COMPLETED,\n            OperationStatus.CANCELLED,\n            OperationStatus.FAILED,\n            OperationStatus.TIMEOUT,\n        }\n\n    @property\n    def is_success(self) -&gt; bool:\n        \"\"\"Check if operation completed successfully.\"\"\"\n        return self.status == OperationStatus.COMPLETED\n\n    @property\n    def is_cancelled(self) -&gt; bool:\n        \"\"\"Check if operation was cancelled.\"\"\"\n        return self.status in {\n            OperationStatus.CANCELLED,\n            OperationStatus.TIMEOUT,\n        }\n\n    def log_context(self) -&gt; dict[str, Any]:\n        \"\"\"Get context dict for structured logging.\"\"\"\n        return {\n            \"operation_id\": self.id,\n            \"operation_name\": self.name,\n            \"status\": self.status.value,\n            \"duration_seconds\": self.duration_seconds,\n            \"parent_id\": self.parent_id,\n            \"child_count\": len(self.child_ids),\n            \"has_error\": bool(self.error),\n            \"cancel_reason\": self.cancel_reason.value if self.cancel_reason else None,\n        }\n\n    def update_status(self, status: OperationStatus) -&gt; None:\n        \"\"\"Update operation status with appropriate logging.\n\n        Args:\n            status: New operation status\n        \"\"\"\n        old_status = self.status\n        self.status = status\n\n        if status in {OperationStatus.COMPLETED, OperationStatus.CANCELLED, OperationStatus.FAILED, OperationStatus.TIMEOUT}:\n            self.end_time = datetime.now(UTC)\n\n        logger.info(\n            \"Operation status changed\",\n            extra={\n                \"old_status\": old_status.value,\n                \"new_status\": status.value,\n                **self.log_context(),\n            },\n        )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(default_factory=lambda: str(uuid4()))\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = None\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: OperationStatus = PENDING\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.start_time","title":"start_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_time: datetime = Field(\n    default_factory=lambda: now(UTC)\n)\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.end_time","title":"end_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_time: datetime | None = None\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.cancel_reason","title":"cancel_reason  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cancel_reason: CancelationReason | None = None\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.cancel_message","title":"cancel_message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cancel_message: str | None = None\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.error","title":"error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>error: str | None = None\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.partial_result","title":"partial_result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>partial_result: Any | None = None\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, Any] = Field(default_factory=dict)\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: str | None = None\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.child_ids","title":"child_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>child_ids: set[str] = Field(default_factory=set)\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.duration","title":"duration  <code>property</code>","text":"<pre><code>duration: timedelta | None\n</code></pre> <p>Calculate operation duration.</p>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.duration_seconds","title":"duration_seconds  <code>property</code>","text":"<pre><code>duration_seconds: float | None\n</code></pre> <p>Get duration in seconds.</p>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.is_terminal","title":"is_terminal  <code>property</code>","text":"<pre><code>is_terminal: bool\n</code></pre> <p>Check if operation is in terminal state.</p>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.is_success","title":"is_success  <code>property</code>","text":"<pre><code>is_success: bool\n</code></pre> <p>Check if operation completed successfully.</p>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.is_cancelled","title":"is_cancelled  <code>property</code>","text":"<pre><code>is_cancelled: bool\n</code></pre> <p>Check if operation was cancelled.</p>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.log_context","title":"log_context","text":"<pre><code>log_context() -&gt; dict[str, Any]\n</code></pre> <p>Get context dict for structured logging.</p> Source code in <code>src/hother/cancelable/core/models.py</code> <pre><code>def log_context(self) -&gt; dict[str, Any]:\n    \"\"\"Get context dict for structured logging.\"\"\"\n    return {\n        \"operation_id\": self.id,\n        \"operation_name\": self.name,\n        \"status\": self.status.value,\n        \"duration_seconds\": self.duration_seconds,\n        \"parent_id\": self.parent_id,\n        \"child_count\": len(self.child_ids),\n        \"has_error\": bool(self.error),\n        \"cancel_reason\": self.cancel_reason.value if self.cancel_reason else None,\n    }\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationContext.update_status","title":"update_status","text":"<pre><code>update_status(status: OperationStatus) -&gt; None\n</code></pre> <p>Update operation status with appropriate logging.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>OperationStatus</code> <p>New operation status</p> required Source code in <code>src/hother/cancelable/core/models.py</code> <pre><code>def update_status(self, status: OperationStatus) -&gt; None:\n    \"\"\"Update operation status with appropriate logging.\n\n    Args:\n        status: New operation status\n    \"\"\"\n    old_status = self.status\n    self.status = status\n\n    if status in {OperationStatus.COMPLETED, OperationStatus.CANCELLED, OperationStatus.FAILED, OperationStatus.TIMEOUT}:\n        self.end_time = datetime.now(UTC)\n\n    logger.info(\n        \"Operation status changed\",\n        extra={\n            \"old_status\": old_status.value,\n            \"new_status\": status.value,\n            **self.log_context(),\n        },\n    )\n</code></pre>"},{"location":"reference/core/#operationstatus","title":"OperationStatus","text":"<p>Enumeration of possible operation states.</p>"},{"location":"reference/core/#hother.cancelable.core.models.OperationStatus","title":"hother.cancelable.core.models.OperationStatus","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Operation lifecycle status.</p> Source code in <code>src/hother/cancelable/core/models.py</code> <pre><code>class OperationStatus(str, Enum):\n    \"\"\"Operation lifecycle status.\"\"\"\n\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"\n    FAILED = \"failed\"\n    TIMEOUT = \"timeout\"\n    SHIELDED = \"shielded\"\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationStatus.PENDING","title":"PENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PENDING = 'pending'\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationStatus.RUNNING","title":"RUNNING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RUNNING = 'running'\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationStatus.COMPLETED","title":"COMPLETED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COMPLETED = 'completed'\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationStatus.CANCELLED","title":"CANCELLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCELLED = 'cancelled'\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationStatus.FAILED","title":"FAILED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAILED = 'failed'\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationStatus.TIMEOUT","title":"TIMEOUT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TIMEOUT = 'timeout'\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.OperationStatus.SHIELDED","title":"SHIELDED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SHIELDED = 'shielded'\n</code></pre>"},{"location":"reference/core/#cancelationreason","title":"CancelationReason","text":"<p>Enumeration of cancelation reason categories.</p>"},{"location":"reference/core/#hother.cancelable.core.models.CancelationReason","title":"hother.cancelable.core.models.CancelationReason","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Reason for cancelation.</p> Source code in <code>src/hother/cancelable/core/models.py</code> <pre><code>class CancelationReason(str, Enum):\n    \"\"\"Reason for cancelation.\"\"\"\n\n    TIMEOUT = \"timeout\"\n    MANUAL = \"manual\"\n    SIGNAL = \"signal\"\n    CONDITION = \"condition\"\n    PARENT = \"parent\"\n    ERROR = \"error\"\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.CancelationReason.TIMEOUT","title":"TIMEOUT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TIMEOUT = 'timeout'\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.CancelationReason.MANUAL","title":"MANUAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MANUAL = 'manual'\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.CancelationReason.SIGNAL","title":"SIGNAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SIGNAL = 'signal'\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.CancelationReason.CONDITION","title":"CONDITION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONDITION = 'condition'\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.CancelationReason.PARENT","title":"PARENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PARENT = 'parent'\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.models.CancelationReason.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = 'error'\n</code></pre>"},{"location":"reference/core/#registry","title":"Registry","text":""},{"location":"reference/core/#operationregistry","title":"OperationRegistry","text":"<p>Global registry for tracking active cancelable operations.</p>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry","title":"hother.cancelable.core.registry.OperationRegistry","text":"<p>Singleton registry for tracking all cancelable operations.</p> <p>Provides centralized management and monitoring of operations across the application.</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>class OperationRegistry:\n    \"\"\"Singleton registry for tracking all cancelable operations.\n\n    Provides centralized management and monitoring of operations across\n    the application.\n    \"\"\"\n\n    _instance: Optional[\"OperationRegistry\"] = None\n\n    def __new__(cls) -&gt; \"OperationRegistry\":\n        \"\"\"Ensure singleton instance.\"\"\"\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self):\n        \"\"\"Initialize registry (only once).\"\"\"\n        if self._initialized:\n            return\n\n        self._operations: dict[str, Cancelable] = {}\n        self._history: list[OperationContext] = []\n        self._history_limit = 1000\n        self._lock: anyio.Lock = anyio.Lock()\n        self._data_lock = threading.Lock()  # Thread-safe lock for data access\n        self._initialized = True\n\n        logger.info(\"Operation registry initialized\")\n\n    @classmethod\n    def get_instance(cls) -&gt; \"OperationRegistry\":\n        \"\"\"Get singleton instance of the registry.\n\n        Returns:\n            The global OperationRegistry instance\n        \"\"\"\n        if cls._instance is None:\n            cls._instance = cls()\n        return cls._instance\n\n    async def register(self, operation: \"Cancelable\") -&gt; None:\n        \"\"\"Register an operation with the registry.\n\n        Args:\n            operation: Cancelable operation to register\n        \"\"\"\n        async with self._lock:\n            with self._data_lock:\n                self._operations[operation.context.id] = operation\n                total = len(self._operations)\n\n            logger.info(\n                \"Operation registered\",\n                extra={\n                    \"operation_id\": operation.context.id,\n                    \"operation_name\": operation.context.name,\n                    \"total_operations\": total,\n                },\n            )\n\n    async def unregister(self, operation_id: str) -&gt; None:\n        \"\"\"Unregister an operation and add to history.\n\n        Args:\n            operation_id: ID of operation to unregister\n        \"\"\"\n        async with self._lock:\n            with self._data_lock:\n                operation = self._operations.pop(operation_id, None)\n                if operation:\n                    # Add to history\n                    self._history.append(operation.context.model_copy(deep=True))\n\n                    # Maintain history limit\n                    if len(self._history) &gt; self._history_limit:\n                        self._history = self._history[-self._history_limit :]\n\n            if operation:\n                logger.debug(\n                    \"Operation unregistered\",\n                    extra={\n                        \"operation_id\": operation_id,\n                        \"final_status\": operation.context.status.value,\n                        \"duration\": operation.context.duration_seconds,\n                    },\n                )\n\n    async def get_operation(self, operation_id: str) -&gt; Optional[\"Cancelable\"]:\n        \"\"\"Get operation by ID.\n\n        Args:\n            operation_id: Operation ID to look up\n\n        Returns:\n            Cancelable operation or None if not found\n        \"\"\"\n        async with self._lock:\n            with self._data_lock:\n                return self._operations.get(operation_id)\n\n    async def list_operations(\n        self,\n        status: OperationStatus | None = None,\n        parent_id: str | None = None,\n        name_pattern: str | None = None,\n    ) -&gt; list[OperationContext]:\n        \"\"\"List operations with optional filtering.\n\n        Args:\n            status: Filter by operation status\n            parent_id: Filter by parent operation ID\n            name_pattern: Filter by name (substring match)\n\n        Returns:\n            List of matching operation contexts\n        \"\"\"\n        async with self._lock:\n            with self._data_lock:\n                operations = [op.context for op in self._operations.values()]\n\n            # Apply filters (outside lock - operating on copied list)\n            if status:\n                operations = [op for op in operations if op.status == status]\n\n            if parent_id:\n                operations = [op for op in operations if op.parent_id == parent_id]\n\n            if name_pattern:\n                operations = [op for op in operations if op.name and name_pattern.lower() in op.name.lower()]\n\n            return operations\n\n    async def cancel_operation(\n        self,\n        operation_id: str,\n        reason: CancelationReason = CancelationReason.MANUAL,\n        message: str | None = None,\n    ) -&gt; bool:\n        \"\"\"Cancel a specific operation.\n\n        Args:\n            operation_id: ID of operation to cancel\n            reason: Reason for cancelation\n            message: Optional cancelation message\n\n        Returns:\n            True if operation was cancelled, False if not found\n        \"\"\"\n        if operation := await self.get_operation(operation_id):\n            await operation.cancel(reason, message)\n            return True\n\n        logger.warning(\n            \"Attempted to cancel non-existent operation\",\n            extra={\"operation_id\": operation_id},\n        )\n        return False\n\n    async def cancel_all(\n        self,\n        status: OperationStatus | None = None,\n        reason: CancelationReason = CancelationReason.MANUAL,\n        message: str | None = None,\n    ) -&gt; int:\n        \"\"\"Cancel all operations with optional status filter.\n\n        Args:\n            status: Only cancel operations with this status\n            reason: Reason for cancelation\n            message: Optional cancelation message\n\n        Returns:\n            Number of operations cancelled\n        \"\"\"\n        async with self._lock:\n            with self._data_lock:\n                to_cancel = list(self._operations.values())\n\n            if status:\n                to_cancel = [op for op in to_cancel if op.context.status == status]\n\n        # Cancel outside lock to avoid deadlock\n        count = 0\n        for operation in to_cancel:\n            try:\n                await operation.cancel(reason, message or \"Bulk cancelation\")\n                count += 1\n            except Exception as e:\n                logger.error(\n                    \"Error cancelling operation\",\n                    extra={\n                        \"operation_id\": operation.context.id,\n                        \"error\": str(e),\n                    },\n                    exc_info=True,\n                )\n\n        logger.info(\n            \"Bulk cancelation completed\",\n            extra={\n                \"cancelled_count\": count,\n                \"filter_status\": status.value if status else None,\n            },\n        )\n\n        return count\n\n    async def get_history(\n        self,\n        limit: int | None = None,\n        status: OperationStatus | None = None,\n        since: datetime | None = None,\n    ) -&gt; list[OperationContext]:\n        \"\"\"Get operation history.\n\n        Args:\n            limit: Maximum number of operations to return\n            status: Filter by final status\n            since: Only return operations completed after this time\n\n        Returns:\n            List of historical operation contexts\n        \"\"\"\n        async with self._lock:\n            with self._data_lock:\n                history = self._history.copy()\n\n            # Apply filters (outside lock - operating on copied list)\n            if status:\n                history = [op for op in history if op.status == status]\n\n            if since:\n                history = [op for op in history if op.end_time and op.end_time &gt;= since]\n\n            # Apply limit\n            if limit:\n                history = history[-limit:]\n\n            return history\n\n    async def cleanup_completed(\n        self,\n        older_than: timedelta | None = None,\n        keep_failed: bool = True,\n    ) -&gt; int:\n        \"\"\"Clean up completed operations from active tracking.\n\n        Args:\n            older_than: Only cleanup operations older than this\n            keep_failed: Whether to keep failed operations\n\n        Returns:\n            Number of operations cleaned up\n        \"\"\"\n        async with self._lock:\n            with self._data_lock:\n                now = datetime.now(UTC)\n                to_remove: list[str] = []\n\n                for op_id, operation in self._operations.items():\n                    context = operation.context\n\n                    # Skip non-terminal operations\n                    if not context.is_terminal:\n                        continue\n\n                    # Skip failed operations if requested\n                    if keep_failed and context.status == OperationStatus.FAILED:\n                        continue\n\n                    # Check age if specified\n                    if older_than and context.end_time:\n                        age = now - context.end_time\n                        if age &lt; older_than:\n                            continue\n\n                    to_remove.append(op_id)\n\n                # Remove operations\n                for op_id in to_remove:\n                    if operation := self._operations.pop(op_id, None):\n                        self._history.append(operation.context.model_copy(deep=True))\n\n                # Maintain history limit\n                if len(self._history) &gt; self._history_limit:\n                    self._history = self._history[-self._history_limit :]\n\n        logger.info(\n            \"Cleaned up completed operations\",\n            extra={\n                \"cleaned_count\": len(to_remove),\n                \"older_than_seconds\": older_than.total_seconds() if older_than else None,\n            },\n        )\n\n        return len(to_remove)\n\n    async def get_statistics(self) -&gt; dict[str, Any]:\n        \"\"\"Get registry statistics.\n\n        Returns:\n            Dictionary with operation statistics\n        \"\"\"\n        async with self._lock:\n            with self._data_lock:\n                active_by_status = {}\n                for operation in self._operations.values():\n                    status = operation.context.status.value\n                    active_by_status[status] = active_by_status.get(status, 0) + 1  # type: ignore[attr-defined]\n\n                history_by_status = {}\n                total_duration = 0.0\n                completed_count = 0\n\n                for context in self._history:\n                    status = context.status.value\n                    history_by_status[status] = history_by_status.get(status, 0) + 1  # type: ignore[attr-defined]\n\n                    if context.duration_seconds and context.is_success:\n                        total_duration += context.duration_seconds\n                        completed_count += 1\n\n                avg_duration = total_duration / completed_count if completed_count &gt; 0 else 0\n\n                return {\n                    \"active_operations\": len(self._operations),\n                    \"active_by_status\": active_by_status,\n                    \"history_size\": len(self._history),\n                    \"history_by_status\": history_by_status,\n                    \"average_duration_seconds\": avg_duration,\n                    \"total_completed\": completed_count,\n                }\n\n    async def clear_all(self) -&gt; None:\n        \"\"\"Clear all operations and history (for testing).\"\"\"\n        async with self._lock:\n            with self._data_lock:\n                self._operations.clear()\n                self._history.clear()\n            logger.warning(\"Registry cleared - all operations removed\")\n\n    # Thread-safe synchronous methods\n\n    def get_operation_sync(self, operation_id: str) -&gt; Optional[\"Cancelable\"]:\n        \"\"\"Get operation by ID (thread-safe, synchronous).\n\n        This method can be called from any thread.\n\n        Args:\n            operation_id: Operation ID to look up\n\n        Returns:\n            Cancelable operation or None if not found\n        \"\"\"\n        with self._data_lock:\n            return self._operations.get(operation_id)\n\n    def list_operations_sync(\n        self,\n        status: OperationStatus | None = None,\n        parent_id: str | None = None,\n        name_pattern: str | None = None,\n    ) -&gt; list[OperationContext]:\n        \"\"\"List operations with optional filtering (thread-safe, synchronous).\n\n        This method can be called from any thread.\n\n        Args:\n            status: Filter by operation status\n            parent_id: Filter by parent operation ID\n            name_pattern: Filter by name (substring match)\n\n        Returns:\n            List of matching operation contexts\n        \"\"\"\n        with self._data_lock:\n            # Create copies to avoid holding lock during filtering\n            operations = [op.context.model_copy() for op in self._operations.values()]\n\n        # Apply filters outside lock\n        if status:\n            operations = [op for op in operations if op.status == status]\n\n        if parent_id:\n            operations = [op for op in operations if op.parent_id == parent_id]\n\n        if name_pattern:\n            operations = [op for op in operations if op.name and name_pattern.lower() in op.name.lower()]\n\n        return operations\n\n    def get_statistics_sync(self) -&gt; dict[str, Any]:\n        \"\"\"Get registry statistics (thread-safe, synchronous).\n\n        This method can be called from any thread.\n\n        Returns:\n            Dictionary with operation statistics\n        \"\"\"\n        with self._data_lock:\n            active_by_status = {}\n            for operation in self._operations.values():\n                status = operation.context.status.value\n                active_by_status[status] = active_by_status.get(status, 0) + 1  # type: ignore[attr-defined]\n\n            history_by_status = {}\n            total_duration = 0.0\n            completed_count = 0\n\n            for context in self._history:\n                status = context.status.value\n                history_by_status[status] = history_by_status.get(status, 0) + 1  # type: ignore[attr-defined]\n\n                if context.duration_seconds and context.is_success:\n                    total_duration += context.duration_seconds\n                    completed_count += 1\n\n            avg_duration = total_duration / completed_count if completed_count &gt; 0 else 0\n\n            return {\n                \"active_operations\": len(self._operations),\n                \"active_by_status\": active_by_status,\n                \"history_size\": len(self._history),\n                \"history_by_status\": history_by_status,\n                \"average_duration_seconds\": avg_duration,\n                \"total_completed\": completed_count,\n            }\n\n    def get_history_sync(\n        self,\n        limit: int | None = None,\n        status: OperationStatus | None = None,\n        since: datetime | None = None,\n    ) -&gt; list[OperationContext]:\n        \"\"\"Get operation history (thread-safe, synchronous).\n\n        This method can be called from any thread.\n\n        Args:\n            limit: Maximum number of operations to return\n            status: Filter by final status\n            since: Only return operations completed after this time\n\n        Returns:\n            List of historical operation contexts\n        \"\"\"\n        with self._data_lock:\n            history = self._history.copy()\n\n        # Apply filters outside lock\n        if status:\n            history = [op for op in history if op.status == status]\n\n        if since:\n            history = [op for op in history if op.end_time and op.end_time &gt;= since]\n\n        # Apply limit\n        if limit:\n            history = history[-limit:]\n\n        return history\n\n    def cancel_operation_sync(\n        self,\n        operation_id: str,\n        reason: CancelationReason = CancelationReason.MANUAL,\n        message: str | None = None,\n    ) -&gt; None:\n        \"\"\"Cancel a specific operation (thread-safe, asynchronous execution).\n\n        This method can be called from any thread. It schedules the cancelation\n        to be executed asynchronously and returns immediately.\n\n        Args:\n            operation_id: ID of operation to cancel\n            reason: Reason for cancelation\n            message: Optional cancelation message\n\n        Note:\n            The cancelation is scheduled via AnyioBridge and executes asynchronously.\n            This method returns immediately without waiting for completion.\n        \"\"\"\n        from hother.cancelable.utils.anyio_bridge import call_soon_threadsafe\n\n        async def do_cancel():\n            await self.cancel_operation(operation_id, reason, message)\n\n        call_soon_threadsafe(do_cancel)\n\n    def cancel_all_sync(\n        self,\n        status: OperationStatus | None = None,\n        reason: CancelationReason = CancelationReason.MANUAL,\n        message: str | None = None,\n    ) -&gt; None:\n        \"\"\"Cancel all operations (thread-safe, asynchronous execution).\n\n        This method can be called from any thread. It schedules the cancelation\n        to be executed asynchronously and returns immediately.\n\n        Args:\n            status: Only cancel operations with this status\n            reason: Reason for cancelation\n            message: Optional cancelation message\n\n        Note:\n            The cancelation is scheduled via AnyioBridge and executes asynchronously.\n            This method returns immediately without waiting for completion.\n        \"\"\"\n        from hother.cancelable.utils.anyio_bridge import call_soon_threadsafe\n\n        async def do_cancel():\n            await self.cancel_all(status, reason, message)\n\n        call_soon_threadsafe(do_cancel)\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.get_instance","title":"get_instance  <code>classmethod</code>","text":"<pre><code>get_instance() -&gt; OperationRegistry\n</code></pre> <p>Get singleton instance of the registry.</p> <p>Returns:</p> Type Description <code>OperationRegistry</code> <p>The global OperationRegistry instance</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>@classmethod\ndef get_instance(cls) -&gt; \"OperationRegistry\":\n    \"\"\"Get singleton instance of the registry.\n\n    Returns:\n        The global OperationRegistry instance\n    \"\"\"\n    if cls._instance is None:\n        cls._instance = cls()\n    return cls._instance\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.register","title":"register  <code>async</code>","text":"<pre><code>register(operation: Cancelable) -&gt; None\n</code></pre> <p>Register an operation with the registry.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>Cancelable</code> <p>Cancelable operation to register</p> required Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>async def register(self, operation: \"Cancelable\") -&gt; None:\n    \"\"\"Register an operation with the registry.\n\n    Args:\n        operation: Cancelable operation to register\n    \"\"\"\n    async with self._lock:\n        with self._data_lock:\n            self._operations[operation.context.id] = operation\n            total = len(self._operations)\n\n        logger.info(\n            \"Operation registered\",\n            extra={\n                \"operation_id\": operation.context.id,\n                \"operation_name\": operation.context.name,\n                \"total_operations\": total,\n            },\n        )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.unregister","title":"unregister  <code>async</code>","text":"<pre><code>unregister(operation_id: str) -&gt; None\n</code></pre> <p>Unregister an operation and add to history.</p> <p>Parameters:</p> Name Type Description Default <code>operation_id</code> <code>str</code> <p>ID of operation to unregister</p> required Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>async def unregister(self, operation_id: str) -&gt; None:\n    \"\"\"Unregister an operation and add to history.\n\n    Args:\n        operation_id: ID of operation to unregister\n    \"\"\"\n    async with self._lock:\n        with self._data_lock:\n            operation = self._operations.pop(operation_id, None)\n            if operation:\n                # Add to history\n                self._history.append(operation.context.model_copy(deep=True))\n\n                # Maintain history limit\n                if len(self._history) &gt; self._history_limit:\n                    self._history = self._history[-self._history_limit :]\n\n        if operation:\n            logger.debug(\n                \"Operation unregistered\",\n                extra={\n                    \"operation_id\": operation_id,\n                    \"final_status\": operation.context.status.value,\n                    \"duration\": operation.context.duration_seconds,\n                },\n            )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.get_operation","title":"get_operation  <code>async</code>","text":"<pre><code>get_operation(operation_id: str) -&gt; Optional[Cancelable]\n</code></pre> <p>Get operation by ID.</p> <p>Parameters:</p> Name Type Description Default <code>operation_id</code> <code>str</code> <p>Operation ID to look up</p> required <p>Returns:</p> Type Description <code>Optional[Cancelable]</code> <p>Cancelable operation or None if not found</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>async def get_operation(self, operation_id: str) -&gt; Optional[\"Cancelable\"]:\n    \"\"\"Get operation by ID.\n\n    Args:\n        operation_id: Operation ID to look up\n\n    Returns:\n        Cancelable operation or None if not found\n    \"\"\"\n    async with self._lock:\n        with self._data_lock:\n            return self._operations.get(operation_id)\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.list_operations","title":"list_operations  <code>async</code>","text":"<pre><code>list_operations(\n    status: OperationStatus | None = None,\n    parent_id: str | None = None,\n    name_pattern: str | None = None,\n) -&gt; list[OperationContext]\n</code></pre> <p>List operations with optional filtering.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>OperationStatus | None</code> <p>Filter by operation status</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>Filter by parent operation ID</p> <code>None</code> <code>name_pattern</code> <code>str | None</code> <p>Filter by name (substring match)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[OperationContext]</code> <p>List of matching operation contexts</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>async def list_operations(\n    self,\n    status: OperationStatus | None = None,\n    parent_id: str | None = None,\n    name_pattern: str | None = None,\n) -&gt; list[OperationContext]:\n    \"\"\"List operations with optional filtering.\n\n    Args:\n        status: Filter by operation status\n        parent_id: Filter by parent operation ID\n        name_pattern: Filter by name (substring match)\n\n    Returns:\n        List of matching operation contexts\n    \"\"\"\n    async with self._lock:\n        with self._data_lock:\n            operations = [op.context for op in self._operations.values()]\n\n        # Apply filters (outside lock - operating on copied list)\n        if status:\n            operations = [op for op in operations if op.status == status]\n\n        if parent_id:\n            operations = [op for op in operations if op.parent_id == parent_id]\n\n        if name_pattern:\n            operations = [op for op in operations if op.name and name_pattern.lower() in op.name.lower()]\n\n        return operations\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.cancel_operation","title":"cancel_operation  <code>async</code>","text":"<pre><code>cancel_operation(\n    operation_id: str,\n    reason: CancelationReason = MANUAL,\n    message: str | None = None,\n) -&gt; bool\n</code></pre> <p>Cancel a specific operation.</p> <p>Parameters:</p> Name Type Description Default <code>operation_id</code> <code>str</code> <p>ID of operation to cancel</p> required <code>reason</code> <code>CancelationReason</code> <p>Reason for cancelation</p> <code>MANUAL</code> <code>message</code> <code>str | None</code> <p>Optional cancelation message</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if operation was cancelled, False if not found</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>async def cancel_operation(\n    self,\n    operation_id: str,\n    reason: CancelationReason = CancelationReason.MANUAL,\n    message: str | None = None,\n) -&gt; bool:\n    \"\"\"Cancel a specific operation.\n\n    Args:\n        operation_id: ID of operation to cancel\n        reason: Reason for cancelation\n        message: Optional cancelation message\n\n    Returns:\n        True if operation was cancelled, False if not found\n    \"\"\"\n    if operation := await self.get_operation(operation_id):\n        await operation.cancel(reason, message)\n        return True\n\n    logger.warning(\n        \"Attempted to cancel non-existent operation\",\n        extra={\"operation_id\": operation_id},\n    )\n    return False\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.cancel_all","title":"cancel_all  <code>async</code>","text":"<pre><code>cancel_all(\n    status: OperationStatus | None = None,\n    reason: CancelationReason = MANUAL,\n    message: str | None = None,\n) -&gt; int\n</code></pre> <p>Cancel all operations with optional status filter.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>OperationStatus | None</code> <p>Only cancel operations with this status</p> <code>None</code> <code>reason</code> <code>CancelationReason</code> <p>Reason for cancelation</p> <code>MANUAL</code> <code>message</code> <code>str | None</code> <p>Optional cancelation message</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of operations cancelled</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>async def cancel_all(\n    self,\n    status: OperationStatus | None = None,\n    reason: CancelationReason = CancelationReason.MANUAL,\n    message: str | None = None,\n) -&gt; int:\n    \"\"\"Cancel all operations with optional status filter.\n\n    Args:\n        status: Only cancel operations with this status\n        reason: Reason for cancelation\n        message: Optional cancelation message\n\n    Returns:\n        Number of operations cancelled\n    \"\"\"\n    async with self._lock:\n        with self._data_lock:\n            to_cancel = list(self._operations.values())\n\n        if status:\n            to_cancel = [op for op in to_cancel if op.context.status == status]\n\n    # Cancel outside lock to avoid deadlock\n    count = 0\n    for operation in to_cancel:\n        try:\n            await operation.cancel(reason, message or \"Bulk cancelation\")\n            count += 1\n        except Exception as e:\n            logger.error(\n                \"Error cancelling operation\",\n                extra={\n                    \"operation_id\": operation.context.id,\n                    \"error\": str(e),\n                },\n                exc_info=True,\n            )\n\n    logger.info(\n        \"Bulk cancelation completed\",\n        extra={\n            \"cancelled_count\": count,\n            \"filter_status\": status.value if status else None,\n        },\n    )\n\n    return count\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.get_history","title":"get_history  <code>async</code>","text":"<pre><code>get_history(\n    limit: int | None = None,\n    status: OperationStatus | None = None,\n    since: datetime | None = None,\n) -&gt; list[OperationContext]\n</code></pre> <p>Get operation history.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum number of operations to return</p> <code>None</code> <code>status</code> <code>OperationStatus | None</code> <p>Filter by final status</p> <code>None</code> <code>since</code> <code>datetime | None</code> <p>Only return operations completed after this time</p> <code>None</code> <p>Returns:</p> Type Description <code>list[OperationContext]</code> <p>List of historical operation contexts</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>async def get_history(\n    self,\n    limit: int | None = None,\n    status: OperationStatus | None = None,\n    since: datetime | None = None,\n) -&gt; list[OperationContext]:\n    \"\"\"Get operation history.\n\n    Args:\n        limit: Maximum number of operations to return\n        status: Filter by final status\n        since: Only return operations completed after this time\n\n    Returns:\n        List of historical operation contexts\n    \"\"\"\n    async with self._lock:\n        with self._data_lock:\n            history = self._history.copy()\n\n        # Apply filters (outside lock - operating on copied list)\n        if status:\n            history = [op for op in history if op.status == status]\n\n        if since:\n            history = [op for op in history if op.end_time and op.end_time &gt;= since]\n\n        # Apply limit\n        if limit:\n            history = history[-limit:]\n\n        return history\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.cleanup_completed","title":"cleanup_completed  <code>async</code>","text":"<pre><code>cleanup_completed(\n    older_than: timedelta | None = None,\n    keep_failed: bool = True,\n) -&gt; int\n</code></pre> <p>Clean up completed operations from active tracking.</p> <p>Parameters:</p> Name Type Description Default <code>older_than</code> <code>timedelta | None</code> <p>Only cleanup operations older than this</p> <code>None</code> <code>keep_failed</code> <code>bool</code> <p>Whether to keep failed operations</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of operations cleaned up</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>async def cleanup_completed(\n    self,\n    older_than: timedelta | None = None,\n    keep_failed: bool = True,\n) -&gt; int:\n    \"\"\"Clean up completed operations from active tracking.\n\n    Args:\n        older_than: Only cleanup operations older than this\n        keep_failed: Whether to keep failed operations\n\n    Returns:\n        Number of operations cleaned up\n    \"\"\"\n    async with self._lock:\n        with self._data_lock:\n            now = datetime.now(UTC)\n            to_remove: list[str] = []\n\n            for op_id, operation in self._operations.items():\n                context = operation.context\n\n                # Skip non-terminal operations\n                if not context.is_terminal:\n                    continue\n\n                # Skip failed operations if requested\n                if keep_failed and context.status == OperationStatus.FAILED:\n                    continue\n\n                # Check age if specified\n                if older_than and context.end_time:\n                    age = now - context.end_time\n                    if age &lt; older_than:\n                        continue\n\n                to_remove.append(op_id)\n\n            # Remove operations\n            for op_id in to_remove:\n                if operation := self._operations.pop(op_id, None):\n                    self._history.append(operation.context.model_copy(deep=True))\n\n            # Maintain history limit\n            if len(self._history) &gt; self._history_limit:\n                self._history = self._history[-self._history_limit :]\n\n    logger.info(\n        \"Cleaned up completed operations\",\n        extra={\n            \"cleaned_count\": len(to_remove),\n            \"older_than_seconds\": older_than.total_seconds() if older_than else None,\n        },\n    )\n\n    return len(to_remove)\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.get_statistics","title":"get_statistics  <code>async</code>","text":"<pre><code>get_statistics() -&gt; dict[str, Any]\n</code></pre> <p>Get registry statistics.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with operation statistics</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>async def get_statistics(self) -&gt; dict[str, Any]:\n    \"\"\"Get registry statistics.\n\n    Returns:\n        Dictionary with operation statistics\n    \"\"\"\n    async with self._lock:\n        with self._data_lock:\n            active_by_status = {}\n            for operation in self._operations.values():\n                status = operation.context.status.value\n                active_by_status[status] = active_by_status.get(status, 0) + 1  # type: ignore[attr-defined]\n\n            history_by_status = {}\n            total_duration = 0.0\n            completed_count = 0\n\n            for context in self._history:\n                status = context.status.value\n                history_by_status[status] = history_by_status.get(status, 0) + 1  # type: ignore[attr-defined]\n\n                if context.duration_seconds and context.is_success:\n                    total_duration += context.duration_seconds\n                    completed_count += 1\n\n            avg_duration = total_duration / completed_count if completed_count &gt; 0 else 0\n\n            return {\n                \"active_operations\": len(self._operations),\n                \"active_by_status\": active_by_status,\n                \"history_size\": len(self._history),\n                \"history_by_status\": history_by_status,\n                \"average_duration_seconds\": avg_duration,\n                \"total_completed\": completed_count,\n            }\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.clear_all","title":"clear_all  <code>async</code>","text":"<pre><code>clear_all() -&gt; None\n</code></pre> <p>Clear all operations and history (for testing).</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>async def clear_all(self) -&gt; None:\n    \"\"\"Clear all operations and history (for testing).\"\"\"\n    async with self._lock:\n        with self._data_lock:\n            self._operations.clear()\n            self._history.clear()\n        logger.warning(\"Registry cleared - all operations removed\")\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.get_operation_sync","title":"get_operation_sync","text":"<pre><code>get_operation_sync(\n    operation_id: str,\n) -&gt; Optional[Cancelable]\n</code></pre> <p>Get operation by ID (thread-safe, synchronous).</p> <p>This method can be called from any thread.</p> <p>Parameters:</p> Name Type Description Default <code>operation_id</code> <code>str</code> <p>Operation ID to look up</p> required <p>Returns:</p> Type Description <code>Optional[Cancelable]</code> <p>Cancelable operation or None if not found</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>def get_operation_sync(self, operation_id: str) -&gt; Optional[\"Cancelable\"]:\n    \"\"\"Get operation by ID (thread-safe, synchronous).\n\n    This method can be called from any thread.\n\n    Args:\n        operation_id: Operation ID to look up\n\n    Returns:\n        Cancelable operation or None if not found\n    \"\"\"\n    with self._data_lock:\n        return self._operations.get(operation_id)\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.list_operations_sync","title":"list_operations_sync","text":"<pre><code>list_operations_sync(\n    status: OperationStatus | None = None,\n    parent_id: str | None = None,\n    name_pattern: str | None = None,\n) -&gt; list[OperationContext]\n</code></pre> <p>List operations with optional filtering (thread-safe, synchronous).</p> <p>This method can be called from any thread.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>OperationStatus | None</code> <p>Filter by operation status</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>Filter by parent operation ID</p> <code>None</code> <code>name_pattern</code> <code>str | None</code> <p>Filter by name (substring match)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[OperationContext]</code> <p>List of matching operation contexts</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>def list_operations_sync(\n    self,\n    status: OperationStatus | None = None,\n    parent_id: str | None = None,\n    name_pattern: str | None = None,\n) -&gt; list[OperationContext]:\n    \"\"\"List operations with optional filtering (thread-safe, synchronous).\n\n    This method can be called from any thread.\n\n    Args:\n        status: Filter by operation status\n        parent_id: Filter by parent operation ID\n        name_pattern: Filter by name (substring match)\n\n    Returns:\n        List of matching operation contexts\n    \"\"\"\n    with self._data_lock:\n        # Create copies to avoid holding lock during filtering\n        operations = [op.context.model_copy() for op in self._operations.values()]\n\n    # Apply filters outside lock\n    if status:\n        operations = [op for op in operations if op.status == status]\n\n    if parent_id:\n        operations = [op for op in operations if op.parent_id == parent_id]\n\n    if name_pattern:\n        operations = [op for op in operations if op.name and name_pattern.lower() in op.name.lower()]\n\n    return operations\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.get_statistics_sync","title":"get_statistics_sync","text":"<pre><code>get_statistics_sync() -&gt; dict[str, Any]\n</code></pre> <p>Get registry statistics (thread-safe, synchronous).</p> <p>This method can be called from any thread.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with operation statistics</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>def get_statistics_sync(self) -&gt; dict[str, Any]:\n    \"\"\"Get registry statistics (thread-safe, synchronous).\n\n    This method can be called from any thread.\n\n    Returns:\n        Dictionary with operation statistics\n    \"\"\"\n    with self._data_lock:\n        active_by_status = {}\n        for operation in self._operations.values():\n            status = operation.context.status.value\n            active_by_status[status] = active_by_status.get(status, 0) + 1  # type: ignore[attr-defined]\n\n        history_by_status = {}\n        total_duration = 0.0\n        completed_count = 0\n\n        for context in self._history:\n            status = context.status.value\n            history_by_status[status] = history_by_status.get(status, 0) + 1  # type: ignore[attr-defined]\n\n            if context.duration_seconds and context.is_success:\n                total_duration += context.duration_seconds\n                completed_count += 1\n\n        avg_duration = total_duration / completed_count if completed_count &gt; 0 else 0\n\n        return {\n            \"active_operations\": len(self._operations),\n            \"active_by_status\": active_by_status,\n            \"history_size\": len(self._history),\n            \"history_by_status\": history_by_status,\n            \"average_duration_seconds\": avg_duration,\n            \"total_completed\": completed_count,\n        }\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.get_history_sync","title":"get_history_sync","text":"<pre><code>get_history_sync(\n    limit: int | None = None,\n    status: OperationStatus | None = None,\n    since: datetime | None = None,\n) -&gt; list[OperationContext]\n</code></pre> <p>Get operation history (thread-safe, synchronous).</p> <p>This method can be called from any thread.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum number of operations to return</p> <code>None</code> <code>status</code> <code>OperationStatus | None</code> <p>Filter by final status</p> <code>None</code> <code>since</code> <code>datetime | None</code> <p>Only return operations completed after this time</p> <code>None</code> <p>Returns:</p> Type Description <code>list[OperationContext]</code> <p>List of historical operation contexts</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>def get_history_sync(\n    self,\n    limit: int | None = None,\n    status: OperationStatus | None = None,\n    since: datetime | None = None,\n) -&gt; list[OperationContext]:\n    \"\"\"Get operation history (thread-safe, synchronous).\n\n    This method can be called from any thread.\n\n    Args:\n        limit: Maximum number of operations to return\n        status: Filter by final status\n        since: Only return operations completed after this time\n\n    Returns:\n        List of historical operation contexts\n    \"\"\"\n    with self._data_lock:\n        history = self._history.copy()\n\n    # Apply filters outside lock\n    if status:\n        history = [op for op in history if op.status == status]\n\n    if since:\n        history = [op for op in history if op.end_time and op.end_time &gt;= since]\n\n    # Apply limit\n    if limit:\n        history = history[-limit:]\n\n    return history\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.cancel_operation_sync","title":"cancel_operation_sync","text":"<pre><code>cancel_operation_sync(\n    operation_id: str,\n    reason: CancelationReason = MANUAL,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Cancel a specific operation (thread-safe, asynchronous execution).</p> <p>This method can be called from any thread. It schedules the cancelation to be executed asynchronously and returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>operation_id</code> <code>str</code> <p>ID of operation to cancel</p> required <code>reason</code> <code>CancelationReason</code> <p>Reason for cancelation</p> <code>MANUAL</code> <code>message</code> <code>str | None</code> <p>Optional cancelation message</p> <code>None</code> Note <p>The cancelation is scheduled via AnyioBridge and executes asynchronously. This method returns immediately without waiting for completion.</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>def cancel_operation_sync(\n    self,\n    operation_id: str,\n    reason: CancelationReason = CancelationReason.MANUAL,\n    message: str | None = None,\n) -&gt; None:\n    \"\"\"Cancel a specific operation (thread-safe, asynchronous execution).\n\n    This method can be called from any thread. It schedules the cancelation\n    to be executed asynchronously and returns immediately.\n\n    Args:\n        operation_id: ID of operation to cancel\n        reason: Reason for cancelation\n        message: Optional cancelation message\n\n    Note:\n        The cancelation is scheduled via AnyioBridge and executes asynchronously.\n        This method returns immediately without waiting for completion.\n    \"\"\"\n    from hother.cancelable.utils.anyio_bridge import call_soon_threadsafe\n\n    async def do_cancel():\n        await self.cancel_operation(operation_id, reason, message)\n\n    call_soon_threadsafe(do_cancel)\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.registry.OperationRegistry.cancel_all_sync","title":"cancel_all_sync","text":"<pre><code>cancel_all_sync(\n    status: OperationStatus | None = None,\n    reason: CancelationReason = MANUAL,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Cancel all operations (thread-safe, asynchronous execution).</p> <p>This method can be called from any thread. It schedules the cancelation to be executed asynchronously and returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>OperationStatus | None</code> <p>Only cancel operations with this status</p> <code>None</code> <code>reason</code> <code>CancelationReason</code> <p>Reason for cancelation</p> <code>MANUAL</code> <code>message</code> <code>str | None</code> <p>Optional cancelation message</p> <code>None</code> Note <p>The cancelation is scheduled via AnyioBridge and executes asynchronously. This method returns immediately without waiting for completion.</p> Source code in <code>src/hother/cancelable/core/registry.py</code> <pre><code>def cancel_all_sync(\n    self,\n    status: OperationStatus | None = None,\n    reason: CancelationReason = CancelationReason.MANUAL,\n    message: str | None = None,\n) -&gt; None:\n    \"\"\"Cancel all operations (thread-safe, asynchronous execution).\n\n    This method can be called from any thread. It schedules the cancelation\n    to be executed asynchronously and returns immediately.\n\n    Args:\n        status: Only cancel operations with this status\n        reason: Reason for cancelation\n        message: Optional cancelation message\n\n    Note:\n        The cancelation is scheduled via AnyioBridge and executes asynchronously.\n        This method returns immediately without waiting for completion.\n    \"\"\"\n    from hother.cancelable.utils.anyio_bridge import call_soon_threadsafe\n\n    async def do_cancel():\n        await self.cancel_all(status, reason, message)\n\n    call_soon_threadsafe(do_cancel)\n</code></pre>"},{"location":"reference/core/#exceptions","title":"Exceptions","text":"<p>All exception classes used by the cancelation system.</p>"},{"location":"reference/core/#hother.cancelable.core.exceptions","title":"hother.cancelable.core.exceptions","text":"<p>Custom exceptions for the async cancelation system.</p>"},{"location":"reference/core/#hother.cancelable.core.exceptions.CancelationError","title":"CancelationError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for cancelation-related errors.</p> <p>Attributes:</p> Name Type Description <code>reason</code> <p>The reason for cancelation</p> <code>message</code> <p>Optional cancelation message</p> <code>context</code> <p>Optional operation context</p> Source code in <code>src/hother/cancelable/core/exceptions.py</code> <pre><code>class CancelationError(Exception):\n    \"\"\"Base exception for cancelation-related errors.\n\n    Attributes:\n        reason: The reason for cancelation\n        message: Optional cancelation message\n        context: Optional operation context\n    \"\"\"\n\n    def __init__(\n        self,\n        reason: CancelationReason,\n        message: str | None = None,\n        context: OperationContext | None = None,\n    ):\n        self.reason = reason\n        self.message = message or f\"Operation cancelled: {reason.value}\"\n        self.context = context\n        super().__init__(self.message)\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.exceptions.CancelationError.reason","title":"reason  <code>instance-attribute</code>","text":"<pre><code>reason = reason\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.exceptions.CancelationError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message or f'Operation cancelled: {value}'\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.exceptions.CancelationError.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context = context\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.exceptions.TimeoutCancelation","title":"TimeoutCancelation","text":"<p>               Bases: <code>CancelationError</code></p> <p>Operation cancelled due to timeout.</p> Source code in <code>src/hother/cancelable/core/exceptions.py</code> <pre><code>class TimeoutCancelation(CancelationError):\n    \"\"\"Operation cancelled due to timeout.\"\"\"\n\n    def __init__(\n        self,\n        timeout_seconds: float,\n        message: str | None = None,\n        context: OperationContext | None = None,\n    ):\n        self.timeout_seconds = timeout_seconds\n        default_message = f\"Operation timed out after {timeout_seconds}s\"\n        super().__init__(\n            CancelationReason.TIMEOUT,\n            message or default_message,\n            context,\n        )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.exceptions.TimeoutCancelation.timeout_seconds","title":"timeout_seconds  <code>instance-attribute</code>","text":"<pre><code>timeout_seconds = timeout_seconds\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.exceptions.ManualCancelation","title":"ManualCancelation","text":"<p>               Bases: <code>CancelationError</code></p> <p>Operation cancelled manually via token or API.</p> Source code in <code>src/hother/cancelable/core/exceptions.py</code> <pre><code>class ManualCancelation(CancelationError):\n    \"\"\"Operation cancelled manually via token or API.\"\"\"\n\n    def __init__(\n        self,\n        message: str | None = None,\n        context: OperationContext | None = None,\n    ):\n        super().__init__(\n            CancelationReason.MANUAL,\n            message or \"Operation cancelled manually\",\n            context,\n        )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.exceptions.SignalCancelation","title":"SignalCancelation","text":"<p>               Bases: <code>CancelationError</code></p> <p>Operation cancelled by system signal.</p> Source code in <code>src/hother/cancelable/core/exceptions.py</code> <pre><code>class SignalCancelation(CancelationError):\n    \"\"\"Operation cancelled by system signal.\"\"\"\n\n    def __init__(\n        self,\n        signal_number: int,\n        message: str | None = None,\n        context: OperationContext | None = None,\n    ):\n        self.signal_number = signal_number\n        default_message = f\"Operation cancelled by signal {signal_number}\"\n        super().__init__(\n            CancelationReason.SIGNAL,\n            message or default_message,\n            context,\n        )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.exceptions.SignalCancelation.signal_number","title":"signal_number  <code>instance-attribute</code>","text":"<pre><code>signal_number = signal_number\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.exceptions.ConditionCancelation","title":"ConditionCancelation","text":"<p>               Bases: <code>CancelationError</code></p> <p>Operation cancelled by condition check.</p> Source code in <code>src/hother/cancelable/core/exceptions.py</code> <pre><code>class ConditionCancelation(CancelationError):\n    \"\"\"Operation cancelled by condition check.\"\"\"\n\n    def __init__(\n        self,\n        condition_name: str | None = None,\n        message: str | None = None,\n        context: OperationContext | None = None,\n    ):\n        self.condition_name = condition_name\n        default_message = \"Operation cancelled: condition met\"\n        if condition_name:\n            default_message = f\"Operation cancelled: {condition_name} condition met\"\n        super().__init__(\n            CancelationReason.CONDITION,\n            message or default_message,\n            context,\n        )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.exceptions.ConditionCancelation.condition_name","title":"condition_name  <code>instance-attribute</code>","text":"<pre><code>condition_name = condition_name\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.exceptions.ParentCancelation","title":"ParentCancelation","text":"<p>               Bases: <code>CancelationError</code></p> <p>Operation cancelled because parent was cancelled.</p> Source code in <code>src/hother/cancelable/core/exceptions.py</code> <pre><code>class ParentCancelation(CancelationError):\n    \"\"\"Operation cancelled because parent was cancelled.\"\"\"\n\n    def __init__(\n        self,\n        parent_id: str,\n        parent_reason: CancelationReason | None = None,\n        message: str | None = None,\n        context: OperationContext | None = None,\n    ):\n        self.parent_id = parent_id\n        self.parent_reason = parent_reason\n        default_message = f\"Operation cancelled: parent {parent_id} was cancelled\"\n        if parent_reason:\n            default_message = f\"Operation cancelled: parent {parent_id} was cancelled ({parent_reason.value})\"\n        super().__init__(\n            CancelationReason.PARENT,\n            message or default_message,\n            context,\n        )\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.exceptions.ParentCancelation.parent_id","title":"parent_id  <code>instance-attribute</code>","text":"<pre><code>parent_id = parent_id\n</code></pre>"},{"location":"reference/core/#hother.cancelable.core.exceptions.ParentCancelation.parent_reason","title":"parent_reason  <code>instance-attribute</code>","text":"<pre><code>parent_reason = parent_reason\n</code></pre>"},{"location":"reference/integrations/","title":"Integrations","text":""},{"location":"reference/integrations/#integrations","title":"Integrations","text":"<p>Integration modules for popular Python frameworks and libraries.</p>"},{"location":"reference/integrations/#fastapi","title":"FastAPI","text":"<p>Middleware and utilities for integrating cancellation with FastAPI applications.</p>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi","title":"hother.cancelable.integrations.fastapi","text":"<p>FastAPI integration for request-scoped cancelation.</p>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = get_logger(__name__)\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.RequestCancelationMiddleware","title":"RequestCancelationMiddleware","text":"<p>FastAPI middleware that provides request-scoped cancelation.</p> Source code in <code>src/hother/cancelable/integrations/fastapi.py</code> <pre><code>class RequestCancelationMiddleware:\n    \"\"\"FastAPI middleware that provides request-scoped cancelation.\"\"\"\n\n    def __init__(self, app: ASGIApp, default_timeout: float | None = None):\n        \"\"\"Initialize middleware.\n\n        Args:\n            app: ASGI application\n            default_timeout: Default timeout for all requests\n        \"\"\"\n        self.app = app\n        self.default_timeout = default_timeout\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        \"\"\"ASGI middleware implementation.\"\"\"\n        if scope[\"type\"] == \"http\":\n            # Create cancelation token for this request\n            token = CancelationToken()\n            scope[\"cancelation_token\"] = token\n\n            # Monitor for client disconnect\n            async def monitor_disconnect():\n                while True:\n                    message = await receive()\n                    if message[\"type\"] == \"http.disconnect\":\n                        await token.cancel(CancelationReason.SIGNAL, \"Client disconnected\")\n                        break\n\n            # Run app with monitoring\n            async with anyio.create_task_group() as tg:\n                tg.start_soon(monitor_disconnect)\n                await self.app(scope, receive, send)\n        else:\n            await self.app(scope, receive, send)\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.RequestCancelationMiddleware.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app = app\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.RequestCancelationMiddleware.default_timeout","title":"default_timeout  <code>instance-attribute</code>","text":"<pre><code>default_timeout = default_timeout\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.CancelableWebSocket","title":"CancelableWebSocket","text":"<p>WebSocket wrapper with cancelation support.</p> Source code in <code>src/hother/cancelable/integrations/fastapi.py</code> <pre><code>class CancelableWebSocket:\n    \"\"\"WebSocket wrapper with cancelation support.\"\"\"\n\n    def __init__(self, websocket: Any, cancelable: Cancelable):\n        self.websocket = websocket\n        self.cancelable = cancelable\n\n    async def accept(self, **kwargs: Any):\n        \"\"\"Accept WebSocket connection.\"\"\"\n        await self.websocket.accept(**kwargs)\n        await self.cancelable.report_progress(\"WebSocket connected\")\n\n    async def send_text(self, data: str):\n        \"\"\"Send text with cancelation check.\"\"\"\n        await self.cancelable.check_cancelation()\n        await self.websocket.send_text(data)\n\n    async def send_json(self, data: Any):\n        \"\"\"Send JSON with cancelation check.\"\"\"\n        await self.cancelable.check_cancelation()\n        await self.websocket.send_json(data)\n\n    async def receive_text(self) -&gt; str:\n        \"\"\"Receive text with cancelation check.\"\"\"\n        await self.cancelable.check_cancelation()\n        return await self.websocket.receive_text()\n\n    async def receive_json(self) -&gt; Any:\n        \"\"\"Receive JSON with cancelation check.\"\"\"\n        await self.cancelable.check_cancelation()\n        return await self.websocket.receive_json()\n\n    async def close(self, code: int = 1000, reason: str = \"\"):\n        \"\"\"Close WebSocket connection.\"\"\"\n        await self.websocket.close(code, reason)\n        await self.cancelable.report_progress(\"WebSocket closed\")\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.CancelableWebSocket.websocket","title":"websocket  <code>instance-attribute</code>","text":"<pre><code>websocket = websocket\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.CancelableWebSocket.cancelable","title":"cancelable  <code>instance-attribute</code>","text":"<pre><code>cancelable = cancelable\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.CancelableWebSocket.accept","title":"accept  <code>async</code>","text":"<pre><code>accept(**kwargs: Any)\n</code></pre> <p>Accept WebSocket connection.</p> Source code in <code>src/hother/cancelable/integrations/fastapi.py</code> <pre><code>async def accept(self, **kwargs: Any):\n    \"\"\"Accept WebSocket connection.\"\"\"\n    await self.websocket.accept(**kwargs)\n    await self.cancelable.report_progress(\"WebSocket connected\")\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.CancelableWebSocket.send_text","title":"send_text  <code>async</code>","text":"<pre><code>send_text(data: str)\n</code></pre> <p>Send text with cancelation check.</p> Source code in <code>src/hother/cancelable/integrations/fastapi.py</code> <pre><code>async def send_text(self, data: str):\n    \"\"\"Send text with cancelation check.\"\"\"\n    await self.cancelable.check_cancelation()\n    await self.websocket.send_text(data)\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.CancelableWebSocket.send_json","title":"send_json  <code>async</code>","text":"<pre><code>send_json(data: Any)\n</code></pre> <p>Send JSON with cancelation check.</p> Source code in <code>src/hother/cancelable/integrations/fastapi.py</code> <pre><code>async def send_json(self, data: Any):\n    \"\"\"Send JSON with cancelation check.\"\"\"\n    await self.cancelable.check_cancelation()\n    await self.websocket.send_json(data)\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.CancelableWebSocket.receive_text","title":"receive_text  <code>async</code>","text":"<pre><code>receive_text() -&gt; str\n</code></pre> <p>Receive text with cancelation check.</p> Source code in <code>src/hother/cancelable/integrations/fastapi.py</code> <pre><code>async def receive_text(self) -&gt; str:\n    \"\"\"Receive text with cancelation check.\"\"\"\n    await self.cancelable.check_cancelation()\n    return await self.websocket.receive_text()\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.CancelableWebSocket.receive_json","title":"receive_json  <code>async</code>","text":"<pre><code>receive_json() -&gt; Any\n</code></pre> <p>Receive JSON with cancelation check.</p> Source code in <code>src/hother/cancelable/integrations/fastapi.py</code> <pre><code>async def receive_json(self) -&gt; Any:\n    \"\"\"Receive JSON with cancelation check.\"\"\"\n    await self.cancelable.check_cancelation()\n    return await self.websocket.receive_json()\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.CancelableWebSocket.close","title":"close  <code>async</code>","text":"<pre><code>close(code: int = 1000, reason: str = '')\n</code></pre> <p>Close WebSocket connection.</p> Source code in <code>src/hother/cancelable/integrations/fastapi.py</code> <pre><code>async def close(self, code: int = 1000, reason: str = \"\"):\n    \"\"\"Close WebSocket connection.\"\"\"\n    await self.websocket.close(code, reason)\n    await self.cancelable.report_progress(\"WebSocket closed\")\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.get_request_token","title":"get_request_token","text":"<pre><code>get_request_token(request: Request) -&gt; CancelationToken\n</code></pre> <p>Get cancelation token from request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>FastAPI request</p> required <p>Returns:</p> Type Description <code>CancelationToken</code> <p>Cancelation token for this request</p> Source code in <code>src/hother/cancelable/integrations/fastapi.py</code> <pre><code>def get_request_token(request: Request) -&gt; CancelationToken:\n    \"\"\"Get cancelation token from request.\n\n    Args:\n        request: FastAPI request\n\n    Returns:\n        Cancelation token for this request\n    \"\"\"\n    if hasattr(request, \"scope\") and \"cancelation_token\" in request.scope:\n        return request.scope[\"cancelation_token\"]\n\n    # Create new token if middleware not installed\n    token = CancelationToken()\n    request.scope[\"cancelation_token\"] = token\n    return token\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.cancelable_dependency","title":"cancelable_dependency  <code>async</code>","text":"<pre><code>cancelable_dependency(\n    request: Request, timeout: float | None = None\n) -&gt; Cancelable\n</code></pre> <p>FastAPI dependency that provides a cancelable for the request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>FastAPI request</p> required <code>timeout</code> <code>float | None</code> <p>Optional timeout override</p> <code>None</code> <p>Returns:</p> Type Description <code>Cancelable</code> <p>Cancelable instance for this request</p> Example <p>@app.get(\"/data\") async def get_data(     cancel: Cancelable = Depends(cancelable_dependency) ):     async with cancel:         return await fetch_data()</p> Source code in <code>src/hother/cancelable/integrations/fastapi.py</code> <pre><code>async def cancelable_dependency(\n    request: Request,\n    timeout: float | None = None,\n) -&gt; Cancelable:\n    \"\"\"FastAPI dependency that provides a cancelable for the request.\n\n    Args:\n        request: FastAPI request\n        timeout: Optional timeout override\n\n    Returns:\n        Cancelable instance for this request\n\n    Example:\n        @app.get(\"/data\")\n        async def get_data(\n            cancel: Cancelable = Depends(cancelable_dependency)\n        ):\n            async with cancel:\n                return await fetch_data()\n    \"\"\"\n    token = get_request_token(request)\n\n    # Create base cancelable with token\n    name = f\"{request.method} {request.url.path}\"\n    metadata: dict[str, str | None] = {\n        \"method\": request.method,\n        \"path\": request.url.path,\n        \"client\": request.client.host if request.client else None,\n    }\n\n    base_cancellable = Cancelable.with_token(token, name=name, metadata=metadata)\n\n    # Add timeout if specified\n    if timeout:\n        timeout_cancellable = Cancelable.with_timeout(timeout, name=f\"timeout_{timeout}s\")\n        # Combine but preserve the original name and metadata\n        combined = base_cancellable.combine(timeout_cancellable)\n        combined.context.name = name  # Override the combined name\n        combined.context.metadata.update(metadata)  # Preserve the original metadata\n        return combined\n\n    return base_cancellable\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.with_cancelation","title":"with_cancelation","text":"<pre><code>with_cancelation(\n    timeout: float | None = None,\n    raise_on_cancel: bool = True,\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]\n</code></pre> <p>Decorator for FastAPI endpoints with automatic cancelation.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>Optional timeout for the endpoint</p> <code>None</code> <code>raise_on_cancel</code> <code>bool</code> <p>Whether to raise HTTPException on cancelation</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., Any]], Callable[..., Any]]</code> <p>Decorator function</p> Example <p>@app.get(\"/slow\") @with_cancelation(timeout=30.0) async def slow_endpoint(request: Request):     # Cancelable is automatically injected     cancelable = current_operation()     await long_operation()</p> Source code in <code>src/hother/cancelable/integrations/fastapi.py</code> <pre><code>def with_cancelation(\n    timeout: float | None = None,\n    raise_on_cancel: bool = True,\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"Decorator for FastAPI endpoints with automatic cancelation.\n\n    Args:\n        timeout: Optional timeout for the endpoint\n        raise_on_cancel: Whether to raise HTTPException on cancelation\n\n    Returns:\n        Decorator function\n\n    Example:\n        @app.get(\"/slow\")\n        @with_cancelation(timeout=30.0)\n        async def slow_endpoint(request: Request):\n            # Cancelable is automatically injected\n            cancelable = current_operation()\n            await long_operation()\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        async def wrapper(request: Request, *args: Any, **kwargs: Any):\n            cancelable = await cancelable_dependency(request, timeout)\n\n            try:\n                async with cancelable:\n                    return await func(request, *args, **kwargs)\n\n            except anyio.get_cancelled_exc_class():\n                if raise_on_cancel:\n                    if cancelable.context.cancel_reason == CancelationReason.TIMEOUT:\n                        raise HTTPException(status_code=504, detail=\"Request timeout\")\n                    if cancelable.context.cancel_reason == CancelationReason.SIGNAL:\n                        raise HTTPException(status_code=499, detail=\"Client closed connection\")\n                    raise HTTPException(status_code=503, detail=f\"Request cancelled: {cancelable.context.cancel_message}\")\n                raise\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/integrations/#hother.cancelable.integrations.fastapi.cancelable_streaming_response","title":"cancelable_streaming_response  <code>async</code>","text":"<pre><code>cancelable_streaming_response(\n    generator: AsyncIterator[Any],\n    cancelable: Cancelable,\n    media_type: str = \"text/plain\",\n    chunk_size: int | None = None,\n) -&gt; StreamingResponse\n</code></pre> <p>Create a streaming response with cancelation support.</p> <pre><code>Args:\n    generator: Async generator producing response chunks\n    cancelable: Cancelable instance\n    media_type: Response media type\n    chunk_size: Optional chunk size hint\n\nReturns:\n    FastAPI StreamingResponse\n\nExample:\n    @app.get(\"/stream\")\n    async def stream_data(cancel: Cancelable = Depends(cancelable_dependency)):\n        async def generate():\n            for i in range(1000):\n                await anyio.sleep(0.1)\n                yield f\"data: {i}\n</code></pre> <p>\"</p> <pre><code>        return await cancelable_streaming_response(\n            generate(),\n            cancel,\n            media_type=\"text/event-stream\"\n        )\n</code></pre> Source code in <code>src/hother/cancelable/integrations/fastapi.py</code> <pre><code>async def cancelable_streaming_response(\n    generator: AsyncIterator[Any],\n    cancelable: Cancelable,\n    media_type: str = \"text/plain\",\n    chunk_size: int | None = None,\n) -&gt; StreamingResponse:\n    \"\"\"Create a streaming response with cancelation support.\n\n    Args:\n        generator: Async generator producing response chunks\n        cancelable: Cancelable instance\n        media_type: Response media type\n        chunk_size: Optional chunk size hint\n\n    Returns:\n        FastAPI StreamingResponse\n\n    Example:\n        @app.get(\"/stream\")\n        async def stream_data(cancel: Cancelable = Depends(cancelable_dependency)):\n            async def generate():\n                for i in range(1000):\n                    await anyio.sleep(0.1)\n                    yield f\"data: {i}\\n\\n\"\n\n            return await cancelable_streaming_response(\n                generate(),\n                cancel,\n                media_type=\"text/event-stream\"\n            )\n    \"\"\"\n\n    async def wrapped_generator():\n        try:\n            async for chunk in cancelable.stream(generator):\n                yield chunk\n        except anyio.get_cancelled_exc_class():\n            # Handle cancelation gracefully\n            logger.info(\n                \"Streaming response cancelled\",\n                extra={\n                    \"operation_id\": cancelable.context.id,\n                    \"cancel_reason\": cancelable.context.cancel_reason,\n                },\n            )\n            # Optionally yield a final message\n            if media_type == \"text/event-stream\":\n                yield \"event: cancelled\\ndata: Stream cancelled\\n\\n\"\n\n    return StreamingResponse(\n        wrapped_generator(),\n        media_type=media_type,\n    )\n</code></pre>"},{"location":"reference/sources/","title":"Cancellation Sources","text":""},{"location":"reference/sources/#cancelation-sources","title":"Cancelation Sources","text":"<p>Cancelation sources provide different ways to trigger cancelation of async operations.</p>"},{"location":"reference/sources/#base-source","title":"Base Source","text":""},{"location":"reference/sources/#cancelationsource","title":"CancelationSource","text":"<p>Abstract base class for all cancelation sources.</p>"},{"location":"reference/sources/#hother.cancelable.sources.base.CancelationSource","title":"hother.cancelable.sources.base.CancelationSource","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for cancelation sources.</p> <p>A cancelation source monitors for a specific condition and triggers cancelation when that condition is met.</p> Source code in <code>src/hother/cancelable/sources/base.py</code> <pre><code>class CancelationSource(ABC):\n    \"\"\"Abstract base class for cancelation sources.\n\n    A cancelation source monitors for a specific condition and triggers\n    cancelation when that condition is met.\n    \"\"\"\n\n    def __init__(self, reason: CancelationReason, name: str | None = None):\n        \"\"\"Initialize cancelation source.\n\n        Args:\n            reason: The cancelation reason this source will use\n            name: Optional name for the source\n        \"\"\"\n        self.reason = reason\n        self.name = name or self.__class__.__name__\n        self.scope: anyio.CancelScope | None = None\n        self._cancel_callback: Callable[[CancelationReason, str], None | Awaitable[None]] | None = None\n        self._monitoring_task: anyio.CancelScope | None = None\n        self.triggered: bool = False\n\n    @abstractmethod\n    async def start_monitoring(self, scope: anyio.CancelScope) -&gt; None:\n        \"\"\"Start monitoring for cancelation condition.\n\n        Args:\n            scope: The cancel scope to trigger when condition is met\n        \"\"\"\n        self.scope = scope\n\n    @abstractmethod\n    async def stop_monitoring(self) -&gt; None:\n        \"\"\"Stop monitoring and clean up resources.\"\"\"\n        if self._monitoring_task:\n            self._monitoring_task.cancel()\n            self._monitoring_task = None\n\n    def set_cancel_callback(self, callback: Callable[[CancelationReason, str], None | Awaitable[None]]) -&gt; None:\n        \"\"\"Set callback to be called when cancelation is triggered.\n\n        Args:\n            callback: Callback function that accepts reason and message (can be sync or async)\n        \"\"\"\n        self._cancel_callback = callback\n\n    async def trigger_cancelation(self, message: str | None = None) -&gt; None:\n        \"\"\"Trigger cancelation with the configured reason.\n\n        Args:\n            message: Optional cancelation message\n        \"\"\"\n        if self.scope and not self.scope.cancel_called:\n            logger.info(\n                \"Cancelation triggered\",\n                extra={\n                    \"source\": self.name,\n                    \"reason\": self.reason.value,\n                    \"cancel_message\": message,\n                },\n            )\n\n            # Call callback if set\n            if self._cancel_callback:\n                try:\n                    result = self._cancel_callback(self.reason, message or \"\")\n                    # If result is an Awaitable, await it\n                    if result is not None:\n                        await result\n                except Exception as e:\n                    logger.error(\n                        \"Error in cancelation callback\",\n                        extra={\n                            \"source\": self.name,\n                            \"error\": str(e),\n                        },\n                        exc_info=True,\n                    )\n\n            # Cancel the scope\n            self.scope.cancel()\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation.\"\"\"\n        return f\"{self.name}(reason={self.reason.value})\"\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.base.CancelationSource.reason","title":"reason  <code>instance-attribute</code>","text":"<pre><code>reason = reason\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.base.CancelationSource.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name or __name__\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.base.CancelationSource.scope","title":"scope  <code>instance-attribute</code>","text":"<pre><code>scope: CancelScope | None = None\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.base.CancelationSource.triggered","title":"triggered  <code>instance-attribute</code>","text":"<pre><code>triggered: bool = False\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.base.CancelationSource.start_monitoring","title":"start_monitoring  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>start_monitoring(scope: CancelScope) -&gt; None\n</code></pre> <p>Start monitoring for cancelation condition.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>CancelScope</code> <p>The cancel scope to trigger when condition is met</p> required Source code in <code>src/hother/cancelable/sources/base.py</code> <pre><code>@abstractmethod\nasync def start_monitoring(self, scope: anyio.CancelScope) -&gt; None:\n    \"\"\"Start monitoring for cancelation condition.\n\n    Args:\n        scope: The cancel scope to trigger when condition is met\n    \"\"\"\n    self.scope = scope\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.base.CancelationSource.stop_monitoring","title":"stop_monitoring  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>stop_monitoring() -&gt; None\n</code></pre> <p>Stop monitoring and clean up resources.</p> Source code in <code>src/hother/cancelable/sources/base.py</code> <pre><code>@abstractmethod\nasync def stop_monitoring(self) -&gt; None:\n    \"\"\"Stop monitoring and clean up resources.\"\"\"\n    if self._monitoring_task:\n        self._monitoring_task.cancel()\n        self._monitoring_task = None\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.base.CancelationSource.set_cancel_callback","title":"set_cancel_callback","text":"<pre><code>set_cancel_callback(\n    callback: Callable[\n        [CancelationReason, str], None | Awaitable[None]\n    ],\n) -&gt; None\n</code></pre> <p>Set callback to be called when cancelation is triggered.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[CancelationReason, str], None | Awaitable[None]]</code> <p>Callback function that accepts reason and message (can be sync or async)</p> required Source code in <code>src/hother/cancelable/sources/base.py</code> <pre><code>def set_cancel_callback(self, callback: Callable[[CancelationReason, str], None | Awaitable[None]]) -&gt; None:\n    \"\"\"Set callback to be called when cancelation is triggered.\n\n    Args:\n        callback: Callback function that accepts reason and message (can be sync or async)\n    \"\"\"\n    self._cancel_callback = callback\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.base.CancelationSource.trigger_cancelation","title":"trigger_cancelation  <code>async</code>","text":"<pre><code>trigger_cancelation(message: str | None = None) -&gt; None\n</code></pre> <p>Trigger cancelation with the configured reason.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | None</code> <p>Optional cancelation message</p> <code>None</code> Source code in <code>src/hother/cancelable/sources/base.py</code> <pre><code>async def trigger_cancelation(self, message: str | None = None) -&gt; None:\n    \"\"\"Trigger cancelation with the configured reason.\n\n    Args:\n        message: Optional cancelation message\n    \"\"\"\n    if self.scope and not self.scope.cancel_called:\n        logger.info(\n            \"Cancelation triggered\",\n            extra={\n                \"source\": self.name,\n                \"reason\": self.reason.value,\n                \"cancel_message\": message,\n            },\n        )\n\n        # Call callback if set\n        if self._cancel_callback:\n            try:\n                result = self._cancel_callback(self.reason, message or \"\")\n                # If result is an Awaitable, await it\n                if result is not None:\n                    await result\n            except Exception as e:\n                logger.error(\n                    \"Error in cancelation callback\",\n                    extra={\n                        \"source\": self.name,\n                        \"error\": str(e),\n                    },\n                    exc_info=True,\n                )\n\n        # Cancel the scope\n        self.scope.cancel()\n</code></pre>"},{"location":"reference/sources/#built-in-sources","title":"Built-in Sources","text":""},{"location":"reference/sources/#timeoutsource","title":"TimeoutSource","text":"<p>Cancels operations after a specified time period.</p>"},{"location":"reference/sources/#hother.cancelable.sources.timeout.TimeoutSource","title":"hother.cancelable.sources.timeout.TimeoutSource","text":"<p>               Bases: <code>CancelationSource</code></p> <p>Cancelation source that triggers after a specified timeout.</p> Source code in <code>src/hother/cancelable/sources/timeout.py</code> <pre><code>class TimeoutSource(CancelationSource):\n    \"\"\"Cancelation source that triggers after a specified timeout.\"\"\"\n\n    def __init__(self, timeout: float | timedelta, name: str | None = None):\n        \"\"\"Initialize timeout source.\n\n        Args:\n            timeout: Timeout duration in seconds or as timedelta\n            name: Optional name for the source\n        \"\"\"\n        super().__init__(CancelationReason.TIMEOUT, name)\n\n        if isinstance(timeout, timedelta):\n            timeout = timeout.total_seconds()\n\n        if timeout &lt;= 0:\n            raise ValueError(f\"Timeout must be positive, got {timeout}\")\n\n        self.timeout = timeout\n        self.triggered = False\n        self._deadline_time: float | None = None\n\n    async def start_monitoring(self, scope: anyio.CancelScope) -&gt; None:\n        \"\"\"Set scope deadline for timeout.\n\n        Args:\n            scope: Cancel scope to configure\n        \"\"\"\n        self.scope = scope\n        self._deadline_time = anyio.current_time() + self.timeout\n        scope.deadline = self._deadline_time\n\n        logger.debug(\n            \"Timeout source activated\",\n            extra={\n                \"source\": self.name,\n                \"timeout_seconds\": self.timeout,\n                \"deadline\": scope.deadline,\n            },\n        )\n\n    async def stop_monitoring(self) -&gt; None:\n        \"\"\"Stop timeout monitoring.\"\"\"\n        # Check if timeout occurred by comparing current time with deadline\n        if self._deadline_time and anyio.current_time() &gt;= self._deadline_time:\n            self.triggered = True\n\n        logger.debug(\n            \"Timeout source stopped\",\n            extra={\n                \"source\": self.name,\n                \"triggered\": self.triggered,\n            },\n        )\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.timeout.TimeoutSource.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout = timeout\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.timeout.TimeoutSource.triggered","title":"triggered  <code>instance-attribute</code>","text":"<pre><code>triggered = False\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.timeout.TimeoutSource.start_monitoring","title":"start_monitoring  <code>async</code>","text":"<pre><code>start_monitoring(scope: CancelScope) -&gt; None\n</code></pre> <p>Set scope deadline for timeout.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>CancelScope</code> <p>Cancel scope to configure</p> required Source code in <code>src/hother/cancelable/sources/timeout.py</code> <pre><code>async def start_monitoring(self, scope: anyio.CancelScope) -&gt; None:\n    \"\"\"Set scope deadline for timeout.\n\n    Args:\n        scope: Cancel scope to configure\n    \"\"\"\n    self.scope = scope\n    self._deadline_time = anyio.current_time() + self.timeout\n    scope.deadline = self._deadline_time\n\n    logger.debug(\n        \"Timeout source activated\",\n        extra={\n            \"source\": self.name,\n            \"timeout_seconds\": self.timeout,\n            \"deadline\": scope.deadline,\n        },\n    )\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.timeout.TimeoutSource.stop_monitoring","title":"stop_monitoring  <code>async</code>","text":"<pre><code>stop_monitoring() -&gt; None\n</code></pre> <p>Stop timeout monitoring.</p> Source code in <code>src/hother/cancelable/sources/timeout.py</code> <pre><code>async def stop_monitoring(self) -&gt; None:\n    \"\"\"Stop timeout monitoring.\"\"\"\n    # Check if timeout occurred by comparing current time with deadline\n    if self._deadline_time and anyio.current_time() &gt;= self._deadline_time:\n        self.triggered = True\n\n    logger.debug(\n        \"Timeout source stopped\",\n        extra={\n            \"source\": self.name,\n            \"triggered\": self.triggered,\n        },\n    )\n</code></pre>"},{"location":"reference/sources/#signalsource","title":"SignalSource","text":"<p>Cancels operations when Unix signals are received (e.g., SIGTERM, SIGINT).</p>"},{"location":"reference/sources/#hother.cancelable.sources.signal.SignalSource","title":"hother.cancelable.sources.signal.SignalSource","text":"<p>               Bases: <code>CancelationSource</code></p> <p>Cancelation source that monitors OS signals.</p> <p>Uses anyio's native signal handling for clean integration. Supports graceful shutdown via SIGINT, SIGTERM, etc.</p> <p>Note: Signal handlers can only be installed in the main thread.</p> Source code in <code>src/hother/cancelable/sources/signal.py</code> <pre><code>class SignalSource(CancelationSource):\n    \"\"\"Cancelation source that monitors OS signals.\n\n    Uses anyio's native signal handling for clean integration.\n    Supports graceful shutdown via SIGINT, SIGTERM, etc.\n\n    Note: Signal handlers can only be installed in the main thread.\n    \"\"\"\n\n    def __init__(self, *signals: int, name: str | None = None) -&gt; None:\n        \"\"\"Initialize signal source.\n\n        Args:\n            *signals: Signal numbers to monitor (e.g., signal.SIGINT)\n            name: Optional name for the source\n        \"\"\"\n        super().__init__(CancelationReason.SIGNAL, name)\n\n        # Validate signals\n        for sig in signals:\n            if not isinstance(sig, int):\n                raise TypeError(f\"Signal must be an integer, got {type(sig)}\")\n\n        if not signals:\n            # Default to SIGINT and SIGTERM\n            self.signals = (signal.SIGINT, signal.SIGTERM)\n        else:\n            self.signals = tuple(signals)\n\n        self.triggered = False\n        self._signal_received: int | None = None\n        self._task_group: anyio.abc.TaskGroup | None = None\n\n    async def start_monitoring(self, scope: anyio.CancelScope) -&gt; None:\n        \"\"\"Start monitoring for signals.\n\n        Args:\n            scope: Cancel scope to trigger when signal is received\n        \"\"\"\n        self.scope = scope\n\n        # Create task group for background monitoring\n        self._task_group = anyio.create_task_group()\n        await self._task_group.__aenter__()\n\n        # Start signal monitoring task\n        self._task_group.start_soon(self._monitor_signals)\n\n        logger.debug(\n            \"Signal source activated\",\n            extra={\n                \"source\": self.name,\n                \"signals\": [signal.Signals(s).name for s in self.signals if s in signal.Signals._value2member_map_],\n            },\n        )\n\n    async def stop_monitoring(self) -&gt; None:\n        \"\"\"Stop monitoring signals and clean up resources.\"\"\"\n        if self._task_group:\n            # Cancel the task group to stop the monitoring task\n            try:\n                self._task_group.cancel_scope.cancel()\n                await self._task_group.__aexit__(None, None, None)\n            except BaseException as e:\n                # Suppress CancelledError and other exceptions during cleanup\n                logger.debug(f\"Task group exit: {type(e).__name__}: {e}\")\n            finally:\n                self._task_group = None\n\n        logger.debug(\n            \"Signal source stopped\",\n            extra={\n                \"source\": self.name,\n                \"triggered\": self.triggered,\n                \"signal_received\": self._signal_received,\n            },\n        )\n\n    async def _monitor_signals(self) -&gt; None:\n        \"\"\"Monitor for signals using anyio's native signal handling.\n\n        This runs in a background task and waits for any of the configured signals.\n        When a signal is received, it triggers cancelation and exits.\n        \"\"\"\n        try:\n            # Open signal receiver (sync context manager)\n            with anyio.open_signal_receiver(*self.signals) as signals:  # type: ignore[arg-type]\n                logger.debug(\n                    \"Signal source monitoring started\",\n                    extra={\n                        \"source\": self.name,\n                        \"signals\": [signal.Signals(s).name for s in self.signals if s in signal.Signals._value2member_map_],\n                    },\n                )\n\n                # Wait for signals\n                # Signal reception happens via anyio's native receiver\n                # Tested through integration examples (examples/02_advanced/08_signal_handling.py)\n                async for signum in signals:  # pragma: no cover\n                    if not self.triggered:\n                        self.triggered = True\n                        self._signal_received = signum\n\n                        # Get signal name\n                        signal_name = \"UNKNOWN\"\n                        if signum in signal.Signals._value2member_map_:\n                            signal_name = signal.Signals(signum).name\n\n                        message = f\"Received signal {signal_name} ({signum})\"\n\n                        logger.info(\n                            \"Signal received, triggering cancelation\",\n                            extra={\n                                \"source\": self.name,\n                                \"signal\": signal_name,\n                                \"signum\": signum,\n                            },\n                        )\n\n                        # Trigger cancelation\n                        await self.trigger_cancelation(message)\n                        break\n\n        # Exception handling for unexpected errors during signal monitoring\n        # Defensive code - difficult to trigger without breaking anyio internals\n        except Exception as e:  # pragma: no cover\n            logger.error(\n                \"Signal monitoring error\",\n                extra={\n                    \"source\": self.name,\n                    \"error\": str(e),\n                },\n                exc_info=True,\n            )\n            raise\n        finally:\n            logger.debug(\n                \"Signal source monitoring stopped\",\n                extra={\n                    \"source\": self.name,\n                    \"triggered\": self.triggered,\n                    \"signal_received\": self._signal_received,\n                },\n            )\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.signal.SignalSource.signals","title":"signals  <code>instance-attribute</code>","text":"<pre><code>signals = (SIGINT, SIGTERM)\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.signal.SignalSource.triggered","title":"triggered  <code>instance-attribute</code>","text":"<pre><code>triggered = False\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.signal.SignalSource.start_monitoring","title":"start_monitoring  <code>async</code>","text":"<pre><code>start_monitoring(scope: CancelScope) -&gt; None\n</code></pre> <p>Start monitoring for signals.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>CancelScope</code> <p>Cancel scope to trigger when signal is received</p> required Source code in <code>src/hother/cancelable/sources/signal.py</code> <pre><code>async def start_monitoring(self, scope: anyio.CancelScope) -&gt; None:\n    \"\"\"Start monitoring for signals.\n\n    Args:\n        scope: Cancel scope to trigger when signal is received\n    \"\"\"\n    self.scope = scope\n\n    # Create task group for background monitoring\n    self._task_group = anyio.create_task_group()\n    await self._task_group.__aenter__()\n\n    # Start signal monitoring task\n    self._task_group.start_soon(self._monitor_signals)\n\n    logger.debug(\n        \"Signal source activated\",\n        extra={\n            \"source\": self.name,\n            \"signals\": [signal.Signals(s).name for s in self.signals if s in signal.Signals._value2member_map_],\n        },\n    )\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.signal.SignalSource.stop_monitoring","title":"stop_monitoring  <code>async</code>","text":"<pre><code>stop_monitoring() -&gt; None\n</code></pre> <p>Stop monitoring signals and clean up resources.</p> Source code in <code>src/hother/cancelable/sources/signal.py</code> <pre><code>async def stop_monitoring(self) -&gt; None:\n    \"\"\"Stop monitoring signals and clean up resources.\"\"\"\n    if self._task_group:\n        # Cancel the task group to stop the monitoring task\n        try:\n            self._task_group.cancel_scope.cancel()\n            await self._task_group.__aexit__(None, None, None)\n        except BaseException as e:\n            # Suppress CancelledError and other exceptions during cleanup\n            logger.debug(f\"Task group exit: {type(e).__name__}: {e}\")\n        finally:\n            self._task_group = None\n\n    logger.debug(\n        \"Signal source stopped\",\n        extra={\n            \"source\": self.name,\n            \"triggered\": self.triggered,\n            \"signal_received\": self._signal_received,\n        },\n    )\n</code></pre>"},{"location":"reference/sources/#conditionsource","title":"ConditionSource","text":"<p>Cancels operations when a predicate function returns True.</p>"},{"location":"reference/sources/#hother.cancelable.sources.condition.ConditionSource","title":"hother.cancelable.sources.condition.ConditionSource","text":"<p>               Bases: <code>CancelationSource</code></p> <p>Cancelation source that monitors a condition function.</p> <p>Cancels when the condition function returns True.</p> Source code in <code>src/hother/cancelable/sources/condition.py</code> <pre><code>class ConditionSource(CancelationSource):\n    \"\"\"Cancelation source that monitors a condition function.\n\n    Cancels when the condition function returns True.\n    \"\"\"\n\n    def __init__(\n        self,\n        condition: Callable[[], bool | Awaitable[bool]],\n        check_interval: float = 0.1,\n        condition_name: str | None = None,\n        name: str | None = None,\n    ):\n        \"\"\"Initialize condition source.\n\n        Args:\n            condition: Function that returns True when cancelation should occur\n            check_interval: How often to check condition (seconds)\n            condition_name: Name for the condition (for logging)\n            name: Optional name for the source\n        \"\"\"\n        super().__init__(CancelationReason.CONDITION, name)\n\n        self.condition = condition\n        self.check_interval = check_interval\n        self.condition_name = condition_name or getattr(condition, \"__name__\", \"condition\")\n        self.triggered = False\n        self._task_group: anyio.abc.TaskGroup | None = None\n        self._stop_event: anyio.Event | None = None\n\n        # Validate check interval\n        if check_interval &lt;= 0:\n            raise ValueError(f\"Check interval must be positive, got {check_interval}\")\n\n        # Determine if condition is async\n        self._is_async = inspect.iscoroutinefunction(condition)\n\n    async def start_monitoring(self, scope: anyio.CancelScope) -&gt; None:\n        \"\"\"Start monitoring the condition.\n\n        Args:\n            scope: Cancel scope to trigger when condition is met\n        \"\"\"\n        self.scope = scope\n\n        # Create stop event for graceful shutdown\n        self._stop_event = anyio.Event()\n\n        # Create task group for background monitoring\n        self._task_group = anyio.create_task_group()\n        await self._task_group.__aenter__()\n\n        # Start monitoring task\n        self._task_group.start_soon(self._monitor_condition)\n\n        logger.debug(\n            \"Condition source activated\",\n            extra={\n                \"source\": self.name,\n                \"condition_name\": self.condition_name,\n                \"check_interval\": self.check_interval,\n            },\n        )\n\n    async def stop_monitoring(self) -&gt; None:\n        \"\"\"Stop monitoring the condition.\"\"\"\n        if self._task_group and self._stop_event:\n            # Signal the monitoring task to stop gracefully\n            self._stop_event.set()\n\n            # Exit the task group normally (monitoring task will complete)\n            try:\n                await self._task_group.__aexit__(None, None, None)\n            except Exception as e:\n                logger.debug(f\"Task group exit error: {type(e).__name__}: {e}\")\n            finally:\n                self._task_group = None\n                self._stop_event = None\n\n        logger.debug(\n            \"Condition source stopped\",\n            extra={\n                \"source\": self.name,\n                \"condition_name\": self.condition_name,\n                \"triggered\": self.triggered,\n            },\n        )\n\n    async def _monitor_condition(self) -&gt; None:\n        \"\"\"Monitor the condition in a loop.\"\"\"\n        # Ensure stop event is set (should be guaranteed by start_monitoring)\n        assert self._stop_event is not None, \"stop_event must be set before monitoring\"\n\n        check_count = 0\n\n        try:\n            while not self.triggered and not self._stop_event.is_set():\n                check_count += 1\n                logger.debug(f\"Condition check #{check_count} for {self.condition_name}\")\n\n                # Check condition\n                try:\n                    result: bool\n                    if self._is_async:\n                        result = await self.condition()  # type: ignore[misc]\n                    else:\n                        # Run sync condition in thread pool\n                        result = await anyio.to_thread.run_sync(self.condition)  # type: ignore[arg-type]\n\n                    logger.debug(f\"Condition check #{check_count} returned: {result}\")\n\n                    if result:\n                        self.triggered = True\n                        logger.debug(f\"Condition '{self.condition_name}' met after {check_count} checks\")\n\n                        # Trigger cancelation through the base class method\n                        await self.trigger_cancelation(f\"Condition '{self.condition_name}' met after {check_count} checks\")\n                        break\n\n                except Exception as e:\n                    logger.error(\n                        \"Error checking condition\",\n                        extra={\n                            \"source\": self.name,\n                            \"condition_name\": self.condition_name,\n                            \"error\": str(e),\n                        },\n                        exc_info=True,\n                    )\n                    # Continue monitoring despite errors\n\n                # Wait before next check, but break early if stop event is set\n                with anyio.move_on_after(self.check_interval):\n                    await self._stop_event.wait()\n\n        except anyio.get_cancelled_exc_class():\n            # Task was cancelled\n            logger.debug(\"Condition monitoring task cancelled\")\n            raise\n        except Exception as e:\n            logger.error(\n                \"Unexpected error in condition monitor\",\n                extra={\n                    \"source\": self.name,\n                    \"error\": str(e),\n                },\n                exc_info=True,\n            )\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.condition.ConditionSource.condition","title":"condition  <code>instance-attribute</code>","text":"<pre><code>condition = condition\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.condition.ConditionSource.check_interval","title":"check_interval  <code>instance-attribute</code>","text":"<pre><code>check_interval = check_interval\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.condition.ConditionSource.condition_name","title":"condition_name  <code>instance-attribute</code>","text":"<pre><code>condition_name = condition_name or getattr(\n    condition, \"__name__\", \"condition\"\n)\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.condition.ConditionSource.triggered","title":"triggered  <code>instance-attribute</code>","text":"<pre><code>triggered = False\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.condition.ConditionSource.start_monitoring","title":"start_monitoring  <code>async</code>","text":"<pre><code>start_monitoring(scope: CancelScope) -&gt; None\n</code></pre> <p>Start monitoring the condition.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>CancelScope</code> <p>Cancel scope to trigger when condition is met</p> required Source code in <code>src/hother/cancelable/sources/condition.py</code> <pre><code>async def start_monitoring(self, scope: anyio.CancelScope) -&gt; None:\n    \"\"\"Start monitoring the condition.\n\n    Args:\n        scope: Cancel scope to trigger when condition is met\n    \"\"\"\n    self.scope = scope\n\n    # Create stop event for graceful shutdown\n    self._stop_event = anyio.Event()\n\n    # Create task group for background monitoring\n    self._task_group = anyio.create_task_group()\n    await self._task_group.__aenter__()\n\n    # Start monitoring task\n    self._task_group.start_soon(self._monitor_condition)\n\n    logger.debug(\n        \"Condition source activated\",\n        extra={\n            \"source\": self.name,\n            \"condition_name\": self.condition_name,\n            \"check_interval\": self.check_interval,\n        },\n    )\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.condition.ConditionSource.stop_monitoring","title":"stop_monitoring  <code>async</code>","text":"<pre><code>stop_monitoring() -&gt; None\n</code></pre> <p>Stop monitoring the condition.</p> Source code in <code>src/hother/cancelable/sources/condition.py</code> <pre><code>async def stop_monitoring(self) -&gt; None:\n    \"\"\"Stop monitoring the condition.\"\"\"\n    if self._task_group and self._stop_event:\n        # Signal the monitoring task to stop gracefully\n        self._stop_event.set()\n\n        # Exit the task group normally (monitoring task will complete)\n        try:\n            await self._task_group.__aexit__(None, None, None)\n        except Exception as e:\n            logger.debug(f\"Task group exit error: {type(e).__name__}: {e}\")\n        finally:\n            self._task_group = None\n            self._stop_event = None\n\n    logger.debug(\n        \"Condition source stopped\",\n        extra={\n            \"source\": self.name,\n            \"condition_name\": self.condition_name,\n            \"triggered\": self.triggered,\n        },\n    )\n</code></pre>"},{"location":"reference/sources/#resourceconditionsource","title":"ResourceConditionSource","text":"<p>Specialized condition source for monitoring system resources (CPU, memory).</p>"},{"location":"reference/sources/#hother.cancelable.sources.condition.ResourceConditionSource","title":"hother.cancelable.sources.condition.ResourceConditionSource","text":"<p>               Bases: <code>ConditionSource</code></p> <p>Specialized condition source for monitoring system resources.</p> <p>Useful for cancelling operations when resources are constrained.</p> Source code in <code>src/hother/cancelable/sources/condition.py</code> <pre><code>class ResourceConditionSource(ConditionSource):\n    \"\"\"Specialized condition source for monitoring system resources.\n\n    Useful for cancelling operations when resources are constrained.\n    \"\"\"\n\n    def __init__(\n        self,\n        memory_threshold: float | None = None,\n        cpu_threshold: float | None = None,\n        disk_threshold: float | None = None,\n        check_interval: float = 5.0,\n        name: str | None = None,\n    ):\n        \"\"\"Initialize resource condition source.\n\n        Args:\n            memory_threshold: Cancel if memory usage exceeds this percentage\n            cpu_threshold: Cancel if CPU usage exceeds this percentage\n            disk_threshold: Cancel if disk usage exceeds this percentage\n            check_interval: How often to check resources (seconds)\n            name: Optional name for the source\n        \"\"\"\n        self.memory_threshold = memory_threshold\n        self.cpu_threshold = cpu_threshold\n        self.disk_threshold = disk_threshold\n\n        # Build condition name\n        conditions: list[str] = []\n        if memory_threshold:\n            conditions.append(f\"memory&gt;{memory_threshold}%\")\n        if cpu_threshold:\n            conditions.append(f\"cpu&gt;{cpu_threshold}%\")\n        if disk_threshold:\n            conditions.append(f\"disk&gt;{disk_threshold}%\")\n\n        condition_name = f\"resource_check({', '.join(conditions)})\"\n\n        super().__init__(\n            condition=self._check_resources,\n            check_interval=check_interval,\n            condition_name=condition_name,\n            name=name or \"resource_monitor\",\n        )\n\n    async def _check_resources(self) -&gt; bool:\n        \"\"\"Check if any resource threshold is exceeded.\"\"\"\n        try:\n            import psutil\n        except ImportError:\n            logger.warning(\"psutil not available, resource monitoring disabled\")\n            return False\n\n        # Check memory\n        if self.memory_threshold:\n            memory_percent = psutil.virtual_memory().percent\n            if memory_percent &gt; self.memory_threshold:\n                logger.info(\n                    \"Memory threshold exceeded\",\n                    extra={\n                        \"current\": memory_percent,\n                        \"threshold\": self.memory_threshold,\n                    },\n                )\n                return True\n\n        # Check CPU\n        if self.cpu_threshold:\n            cpu_percent = psutil.cpu_percent(interval=0.1)\n            if cpu_percent &gt; self.cpu_threshold:\n                logger.info(\n                    \"CPU threshold exceeded\",\n                    extra={\n                        \"current\": cpu_percent,\n                        \"threshold\": self.cpu_threshold,\n                    },\n                )\n                return True\n\n        # Check disk\n        if self.disk_threshold:\n            disk_usage = psutil.disk_usage(\"/\").percent\n            if disk_usage &gt; self.disk_threshold:\n                logger.info(\n                    \"Disk threshold exceeded\",\n                    extra={\n                        \"current\": disk_usage,\n                        \"threshold\": self.disk_threshold,\n                    },\n                )\n                return True\n\n        return False\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.condition.ResourceConditionSource.memory_threshold","title":"memory_threshold  <code>instance-attribute</code>","text":"<pre><code>memory_threshold = memory_threshold\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.condition.ResourceConditionSource.cpu_threshold","title":"cpu_threshold  <code>instance-attribute</code>","text":"<pre><code>cpu_threshold = cpu_threshold\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.condition.ResourceConditionSource.disk_threshold","title":"disk_threshold  <code>instance-attribute</code>","text":"<pre><code>disk_threshold = disk_threshold\n</code></pre>"},{"location":"reference/sources/#composite-sources","title":"Composite Sources","text":"<p>Composite sources allow combining multiple cancelation sources with different logic:</p>"},{"location":"reference/sources/#or-vs-and-logic-comparison","title":"OR vs AND Logic Comparison","text":"Feature CompositeSource / AnyOfSource AllOfSource Trigger Logic Cancels when ANY source triggers Cancels when ALL sources trigger Use Case Safety nets, failsafes, OR conditions Requirements, gates, AND conditions Example Timeout OR manual cancel OR signal Minimum time AND target count Thread Safety \u2705 Yes \u2705 Yes (with <code>anyio.Lock()</code>) Typical Usage <code>Cancelable.combine()</code> Manual construction with <code>AllOfSource([...])</code>"},{"location":"reference/sources/#usage-examples","title":"Usage Examples","text":"<p>OR Logic (Any-Of) - Default: </p><pre><code>from hother.cancelable.sources.composite import CompositeSource\nfrom hother.cancelable.sources.timeout import TimeoutSource\nfrom hother.cancelable.sources.signal import SignalSource\n\n# Cancels when timeout OR signal (whichever comes first)\nor_source = CompositeSource([\n    TimeoutSource(timeout=60.0),\n    SignalSource(signal.SIGTERM)\n])\n</code></pre><p></p> <p>AND Logic (All-Of) - Require All: </p><pre><code>from hother.cancelable.sources.composite import AllOfSource\nfrom hother.cancelable.sources.timeout import TimeoutSource\nfrom hother.cancelable.sources.condition import ConditionSource\n\n# Cancels only when BOTH timeout AND condition are met\nand_source = AllOfSource([\n    TimeoutSource(timeout=60.0),\n    ConditionSource(lambda: items_processed &gt;= 100, 1.0)\n])\n</code></pre><p></p>"},{"location":"reference/sources/#compositesource","title":"CompositeSource","text":"<p>Combines multiple cancelation sources into a single source (any-of logic).</p>"},{"location":"reference/sources/#hother.cancelable.sources.composite.CompositeSource","title":"hother.cancelable.sources.composite.CompositeSource","text":"<p>               Bases: <code>CancelationSource</code></p> <p>Cancelation source that combines multiple other sources.</p> <p>Triggers when any of the component sources trigger.</p> Source code in <code>src/hother/cancelable/sources/composite.py</code> <pre><code>class CompositeSource(CancelationSource):\n    \"\"\"Cancelation source that combines multiple other sources.\n\n    Triggers when any of the component sources trigger.\n    \"\"\"\n\n    def __init__(\n        self,\n        sources: list[CancelationSource],\n        name: str | None = None,\n    ):\n        \"\"\"Initialize composite source.\n\n        Args:\n            sources: List of cancelation sources to combine\n            name: Optional name for the source\n        \"\"\"\n        # Use MANUAL as default reason (will be overridden by actual source)\n        super().__init__(CancelationReason.MANUAL, name or \"composite\")\n\n        if not sources:\n            raise ValueError(\"At least one source is required\")\n\n        self.sources = sources\n        self.triggered_source: CancelationSource | None = None\n\n    async def start_monitoring(self, scope: anyio.CancelScope) -&gt; None:\n        \"\"\"Start monitoring all component sources.\n\n        Args:\n            scope: Cancel scope to trigger when any source triggers\n        \"\"\"\n        self.scope = scope\n\n        # Create task group for background monitoring\n        self._task_group = anyio.create_task_group()\n        await self._task_group.__aenter__()\n\n        # Start each source with a wrapper\n        for source in self.sources:\n            self._task_group.start_soon(self._monitor_source, source)\n\n        logger.debug(\n            \"Composite source activated: %s with %d sources (%s)\",\n            self.name,\n            len(self.sources),\n            [type(s).__name__ for s in self.sources],\n        )\n\n    async def stop_monitoring(self) -&gt; None:\n        \"\"\"Stop monitoring all component sources.\"\"\"\n        # Cancel monitoring task group\n        if hasattr(self, \"_task_group\") and self._task_group:\n            self._task_group.cancel_scope.cancel()\n\n            # Try to properly exit the task group, but shield from cancelation\n            # and handle errors if we're in a different context\n            try:\n                with anyio.CancelScope(shield=True):\n                    await self._task_group.__aexit__(None, None, None)\n            except (anyio.get_cancelled_exc_class(), RuntimeError, Exception) as e:\n                # Task group exit failed, likely due to context mismatch\n                # This is acceptable as the cancel scope was already cancelled\n                logger.debug(f\"Task group cleanup skipped: {type(e).__name__}\")\n            finally:\n                self._task_group = None\n\n        # Stop each source\n        for source in self.sources:\n            try:\n                await source.stop_monitoring()\n            except Exception as e:\n                logger.error(\n                    \"Error stopping source %s: %s\",\n                    str(source),\n                    str(e),\n                    exc_info=True,\n                )\n\n        logger.debug(\n            \"Composite source stopped: %s (triggered by %s)\",\n            self.name,\n            str(self.triggered_source) if self.triggered_source else None,\n        )\n\n    async def _monitor_source(self, source: CancelationSource) -&gt; None:\n        \"\"\"Monitor a single source and propagate its cancelation.\n\n        Args:\n            source: Source to monitor\n        \"\"\"\n        # Override the source's trigger method to capture which source triggered\n        original_trigger = source.trigger_cancelation\n\n        async def wrapped_trigger(message: str | None = None):\n            self.triggered_source = source\n            self.reason = source.reason  # Use the source's reason\n            await original_trigger(message)\n\n            # Trigger our own cancelation\n            if self.scope and not self.scope.cancel_called:\n                await self.trigger_cancelation(f\"Composite source triggered by {source.name}: {message}\")\n\n        source.trigger_cancelation = wrapped_trigger\n\n        try:\n            # Start the source\n            await source.start_monitoring(anyio.CancelScope())\n        except Exception as e:\n            logger.error(\n                \"Error in component source %s of composite %s: %s\",\n                str(source),\n                self.name,\n                str(e),\n                exc_info=True,\n            )\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.composite.CompositeSource.sources","title":"sources  <code>instance-attribute</code>","text":"<pre><code>sources = sources\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.composite.CompositeSource.triggered_source","title":"triggered_source  <code>instance-attribute</code>","text":"<pre><code>triggered_source: CancelationSource | None = None\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.composite.CompositeSource.start_monitoring","title":"start_monitoring  <code>async</code>","text":"<pre><code>start_monitoring(scope: CancelScope) -&gt; None\n</code></pre> <p>Start monitoring all component sources.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>CancelScope</code> <p>Cancel scope to trigger when any source triggers</p> required Source code in <code>src/hother/cancelable/sources/composite.py</code> <pre><code>async def start_monitoring(self, scope: anyio.CancelScope) -&gt; None:\n    \"\"\"Start monitoring all component sources.\n\n    Args:\n        scope: Cancel scope to trigger when any source triggers\n    \"\"\"\n    self.scope = scope\n\n    # Create task group for background monitoring\n    self._task_group = anyio.create_task_group()\n    await self._task_group.__aenter__()\n\n    # Start each source with a wrapper\n    for source in self.sources:\n        self._task_group.start_soon(self._monitor_source, source)\n\n    logger.debug(\n        \"Composite source activated: %s with %d sources (%s)\",\n        self.name,\n        len(self.sources),\n        [type(s).__name__ for s in self.sources],\n    )\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.composite.CompositeSource.stop_monitoring","title":"stop_monitoring  <code>async</code>","text":"<pre><code>stop_monitoring() -&gt; None\n</code></pre> <p>Stop monitoring all component sources.</p> Source code in <code>src/hother/cancelable/sources/composite.py</code> <pre><code>async def stop_monitoring(self) -&gt; None:\n    \"\"\"Stop monitoring all component sources.\"\"\"\n    # Cancel monitoring task group\n    if hasattr(self, \"_task_group\") and self._task_group:\n        self._task_group.cancel_scope.cancel()\n\n        # Try to properly exit the task group, but shield from cancelation\n        # and handle errors if we're in a different context\n        try:\n            with anyio.CancelScope(shield=True):\n                await self._task_group.__aexit__(None, None, None)\n        except (anyio.get_cancelled_exc_class(), RuntimeError, Exception) as e:\n            # Task group exit failed, likely due to context mismatch\n            # This is acceptable as the cancel scope was already cancelled\n            logger.debug(f\"Task group cleanup skipped: {type(e).__name__}\")\n        finally:\n            self._task_group = None\n\n    # Stop each source\n    for source in self.sources:\n        try:\n            await source.stop_monitoring()\n        except Exception as e:\n            logger.error(\n                \"Error stopping source %s: %s\",\n                str(source),\n                str(e),\n                exc_info=True,\n            )\n\n    logger.debug(\n        \"Composite source stopped: %s (triggered by %s)\",\n        self.name,\n        str(self.triggered_source) if self.triggered_source else None,\n    )\n</code></pre>"},{"location":"reference/sources/#anyofsource","title":"AnyOfSource","text":"<p>Alias for CompositeSource - cancels when any source triggers.</p>"},{"location":"reference/sources/#hother.cancelable.sources.composite.AnyOfSource","title":"hother.cancelable.sources.composite.AnyOfSource","text":"<p>               Bases: <code>CompositeSource</code></p> <p>Alias for CompositeSource - triggers when ANY source triggers.</p> Source code in <code>src/hother/cancelable/sources/composite.py</code> <pre><code>class AnyOfSource(CompositeSource):\n    \"\"\"Alias for CompositeSource - triggers when ANY source triggers.\"\"\"\n</code></pre>"},{"location":"reference/sources/#allofsource","title":"AllOfSource","text":"<p>Cancels when all sources have triggered (all-of logic).</p>"},{"location":"reference/sources/#hother.cancelable.sources.composite.AllOfSource","title":"hother.cancelable.sources.composite.AllOfSource","text":"<p>               Bases: <code>CancelationSource</code></p> <p>Cancelation source that requires ALL component sources to trigger.</p> <p>Only cancels when all component sources have triggered.</p> Source code in <code>src/hother/cancelable/sources/composite.py</code> <pre><code>class AllOfSource(CancelationSource):\n    \"\"\"Cancelation source that requires ALL component sources to trigger.\n\n    Only cancels when all component sources have triggered.\n    \"\"\"\n\n    def __init__(\n        self,\n        sources: list[CancelationSource],\n        name: str | None = None,\n    ):\n        \"\"\"Initialize all-of source.\n\n        Args:\n            sources: List of cancelation sources that must all trigger\n            name: Optional name for the source\n        \"\"\"\n        super().__init__(CancelationReason.MANUAL, name or \"all_of\")\n\n        if not sources:\n            raise ValueError(\"At least one source is required\")\n\n        self.sources = sources\n        self.triggered_sources: set[CancelationSource] = set()\n        self._lock = anyio.Lock()\n\n    async def start_monitoring(self, scope: anyio.CancelScope) -&gt; None:\n        \"\"\"Start monitoring all component sources.\"\"\"\n        self.scope = scope\n\n        # Create a task group for all sources\n        self._task_group = anyio.create_task_group()\n        await self._task_group.__aenter__()\n\n        # Start each source with a wrapper\n        for source in self.sources:\n            self._task_group.start_soon(self._monitor_source, source)\n\n        logger.debug(\n            \"All-of source activated: %s with %d sources\",\n            self.name,\n            len(self.sources),\n        )\n\n    async def stop_monitoring(self) -&gt; None:\n        \"\"\"Stop monitoring all component sources.\"\"\"\n        # Cancel monitoring task group\n        if hasattr(self, \"_task_group\") and self._task_group:\n            self._task_group.cancel_scope.cancel()\n            await self._task_group.__aexit__(None, None, None)\n\n        # Stop each source\n        for source in self.sources:\n            try:\n                await source.stop_monitoring()\n            except Exception as e:\n                logger.error(\n                    \"Error stopping source %s: %s\",\n                    str(source),\n                    str(e),\n                    exc_info=True,\n                )\n\n    async def _monitor_source(self, source: CancelationSource) -&gt; None:\n        \"\"\"Monitor a single source and check if all have triggered.\"\"\"\n        # Override the source's trigger method\n        original_trigger = source.trigger_cancelation\n\n        async def wrapped_trigger(message: str | None = None):\n            async with self._lock:\n                self.triggered_sources.add(source)\n\n                # Check if all sources have triggered\n                if len(self.triggered_sources) == len(self.sources):\n                    # All sources triggered, cancel\n                    await self.trigger_cancelation(f\"All {len(self.sources)} sources have triggered\")\n\n            # Still call original trigger for logging\n            await original_trigger(message)\n\n        source.trigger_cancelation = wrapped_trigger\n\n        try:\n            # Start the source with a dummy scope\n            await source.start_monitoring(anyio.CancelScope())\n        except Exception as e:\n            logger.error(\n                \"Error in component source %s of all-of %s: %s\",\n                str(source),\n                self.name,\n                str(e),\n                exc_info=True,\n            )\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.composite.AllOfSource.sources","title":"sources  <code>instance-attribute</code>","text":"<pre><code>sources = sources\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.composite.AllOfSource.triggered_sources","title":"triggered_sources  <code>instance-attribute</code>","text":"<pre><code>triggered_sources: set[CancelationSource] = set()\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.composite.AllOfSource.start_monitoring","title":"start_monitoring  <code>async</code>","text":"<pre><code>start_monitoring(scope: CancelScope) -&gt; None\n</code></pre> <p>Start monitoring all component sources.</p> Source code in <code>src/hother/cancelable/sources/composite.py</code> <pre><code>async def start_monitoring(self, scope: anyio.CancelScope) -&gt; None:\n    \"\"\"Start monitoring all component sources.\"\"\"\n    self.scope = scope\n\n    # Create a task group for all sources\n    self._task_group = anyio.create_task_group()\n    await self._task_group.__aenter__()\n\n    # Start each source with a wrapper\n    for source in self.sources:\n        self._task_group.start_soon(self._monitor_source, source)\n\n    logger.debug(\n        \"All-of source activated: %s with %d sources\",\n        self.name,\n        len(self.sources),\n    )\n</code></pre>"},{"location":"reference/sources/#hother.cancelable.sources.composite.AllOfSource.stop_monitoring","title":"stop_monitoring  <code>async</code>","text":"<pre><code>stop_monitoring() -&gt; None\n</code></pre> <p>Stop monitoring all component sources.</p> Source code in <code>src/hother/cancelable/sources/composite.py</code> <pre><code>async def stop_monitoring(self) -&gt; None:\n    \"\"\"Stop monitoring all component sources.\"\"\"\n    # Cancel monitoring task group\n    if hasattr(self, \"_task_group\") and self._task_group:\n        self._task_group.cancel_scope.cancel()\n        await self._task_group.__aexit__(None, None, None)\n\n    # Stop each source\n    for source in self.sources:\n        try:\n            await source.stop_monitoring()\n        except Exception as e:\n            logger.error(\n                \"Error stopping source %s: %s\",\n                str(source),\n                str(e),\n                exc_info=True,\n            )\n</code></pre>"},{"location":"reference/utilities/","title":"Utilities","text":""},{"location":"reference/utilities/#utilities","title":"Utilities","text":"<p>Utility modules providing helper functions, decorators, bridges, and testing tools.</p>"},{"location":"reference/utilities/#decorators","title":"Decorators","text":"<p>The <code>@cancelable</code> decorator for easily making functions cancelable.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators","title":"hother.cancelable.utils.decorators","text":"<p>Decorators and convenience functions for async cancelation.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = get_logger(__name__)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators.P","title":"P  <code>module-attribute</code>","text":"<pre><code>P = ParamSpec('P')\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators.R","title":"R  <code>module-attribute</code>","text":"<pre><code>R = TypeVar('R')\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators.cancelable","title":"cancelable","text":"<pre><code>cancelable(\n    timeout: float | timedelta | None = None,\n    operation_id: str | None = None,\n    name: str | None = None,\n    register_globally: bool = False,\n    inject_param: str | None = \"cancelable\",\n) -&gt; Callable[\n    [Callable[P, Awaitable[R]]],\n    Callable[P, Awaitable[R]],\n]\n</code></pre> <p>Decorator to make async function cancelable.</p> <p>The decorator automatically creates a Cancelable context and injects it via the specified parameter name (default: 'cancelable'). The decorated function will ALWAYS receive a non-None Cancelable instance.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | timedelta | None</code> <p>Optional timeout for the operation</p> <code>None</code> <code>operation_id</code> <code>str | None</code> <p>Optional operation ID (auto-generated if not provided)</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional operation name (defaults to function name)</p> <code>None</code> <code>register_globally</code> <code>bool</code> <p>Whether to register with global registry</p> <code>False</code> <code>inject_param</code> <code>str | None</code> <p>Parameter name to inject cancelable (None to disable)</p> <code>'cancelable'</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]</code> <p>Decorator function</p> Example <p>@cancelable(timeout=30.0, register_globally=True) async def my_operation(data: str, cancelable: Cancelable = None):     await cancelable.report_progress(\"Starting\")     # ... do work ...     return result</p> Note <p>Type the injected parameter as <code>Cancelable = None</code> for type checker compatibility. The decorator ALWAYS provides a non-None instance, but the <code>= None</code> default signals to type checkers that callers don't need to provide this argument.</p> <p>For strict type checking within the function, optionally add: <code>assert cancelable is not None</code></p> <p>Alternatively, disable injection with <code>inject_param=None</code> and use <code>current_operation()</code> instead.</p> Source code in <code>src/hother/cancelable/utils/decorators.py</code> <pre><code>def cancelable(\n    timeout: float | timedelta | None = None,\n    operation_id: str | None = None,\n    name: str | None = None,\n    register_globally: bool = False,\n    inject_param: str | None = \"cancelable\",\n) -&gt; Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]:\n    \"\"\"Decorator to make async function cancelable.\n\n    The decorator automatically creates a Cancelable context and injects it\n    via the specified parameter name (default: 'cancelable'). The decorated\n    function will ALWAYS receive a non-None Cancelable instance.\n\n    Args:\n        timeout: Optional timeout for the operation\n        operation_id: Optional operation ID (auto-generated if not provided)\n        name: Optional operation name (defaults to function name)\n        register_globally: Whether to register with global registry\n        inject_param: Parameter name to inject cancelable (None to disable)\n\n    Returns:\n        Decorator function\n\n    Example:\n        @cancelable(timeout=30.0, register_globally=True)\n        async def my_operation(data: str, cancelable: Cancelable = None):\n            await cancelable.report_progress(\"Starting\")\n            # ... do work ...\n            return result\n\n    Note:\n        **Type the injected parameter as `Cancelable = None` for type checker\n        compatibility.** The decorator ALWAYS provides a non-None instance,\n        but the `= None` default signals to type checkers that callers don't\n        need to provide this argument.\n\n        For strict type checking within the function, optionally add:\n        `assert cancelable is not None`\n\n        Alternatively, disable injection with `inject_param=None` and use\n        `current_operation()` instead.\n    \"\"\"\n\n    def decorator(func: Callable[P, Awaitable[R]]) -&gt; Callable[P, Awaitable[R]]:\n        @wraps(func)\n        async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n            # Create cancelable\n            cancel_kwargs: dict[str, Any] = {\n                \"operation_id\": operation_id,\n                \"name\": name or func.__name__,\n                \"register_globally\": register_globally,\n            }\n\n            cancel = Cancelable.with_timeout(timeout, **cancel_kwargs) if timeout else Cancelable(**cancel_kwargs)\n\n            async with cancel:\n                # Inject cancelable if requested\n                if inject_param:\n                    sig = inspect.signature(func)\n                    if inject_param in sig.parameters:\n                        kwargs[inject_param] = cancel\n\n                # Call the function\n                return await func(*args, **kwargs)\n\n            # Unreachable - async with block always completes above\n            raise AssertionError(\"Unreachable\")  # pragma: no cover\n\n        # Add attribute to access decorator parameters (dynamic attribute, no type annotation needed)\n        wrapper._cancelable_params = {  # type: ignore[attr-defined]\n            \"timeout\": timeout,\n            \"operation_id\": operation_id,\n            \"name\": name or func.__name__,\n            \"register_globally\": register_globally,\n        }\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators.with_timeout","title":"with_timeout  <code>async</code>","text":"<pre><code>with_timeout(\n    timeout: float | timedelta,\n    coro: Awaitable[T],\n    operation_id: str | None = None,\n    name: str | None = None,\n) -&gt; T\n</code></pre> <p>Run coroutine with timeout.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | timedelta</code> <p>Timeout duration</p> required <code>coro</code> <code>Awaitable[T]</code> <p>Coroutine to run</p> required <code>operation_id</code> <code>str | None</code> <p>Optional operation ID</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional operation name</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>Result from coroutine</p> <p>Raises:</p> Type Description <code>CancelledError</code> <p>If operation times out</p> Example <p>result = await with_timeout(5.0, fetch_data())</p> Source code in <code>src/hother/cancelable/utils/decorators.py</code> <pre><code>async def with_timeout(\n    timeout: float | timedelta,\n    coro: Awaitable[T],\n    operation_id: str | None = None,\n    name: str | None = None,\n) -&gt; T:\n    \"\"\"Run coroutine with timeout.\n\n    Args:\n        timeout: Timeout duration\n        coro: Coroutine to run\n        operation_id: Optional operation ID\n        name: Optional operation name\n\n    Returns:\n        Result from coroutine\n\n    Raises:\n        CancelledError: If operation times out\n\n    Example:\n        result = await with_timeout(5.0, fetch_data())\n    \"\"\"\n    cancelable = Cancelable.with_timeout(\n        timeout,\n        operation_id=operation_id,\n        name=name,\n    )\n\n    async with cancelable:\n        return await coro\n\n    # Unreachable - async with block always completes above\n    raise AssertionError(\"Unreachable\")  # pragma: no cover\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators.with_current_operation","title":"with_current_operation","text":"<pre><code>with_current_operation() -&gt; (\n    Callable[\n        [Callable[P, Awaitable[R]]],\n        Callable[P, Awaitable[R]],\n    ]\n)\n</code></pre> <p>Decorator that injects current operation into function.</p> <p>The function must have a parameter named 'operation'. The decorator will inject the current operation context if available (may be None if called outside a Cancelable context).</p> Example <p>@with_current_operation() async def process_item(item: str, operation: Cancelable | None):     if operation:         await operation.report_progress(f\"Processing {item}\")     return item.upper()</p> Note <p>Unlike @cancelable, this decorator injects the CURRENT operation (if one exists) rather than creating a new one. The operation parameter may be None if no cancelable context is active.</p> Source code in <code>src/hother/cancelable/utils/decorators.py</code> <pre><code>def with_current_operation() -&gt; Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]:\n    \"\"\"Decorator that injects current operation into function.\n\n    The function must have a parameter named 'operation'. The decorator\n    will inject the current operation context if available (may be None\n    if called outside a Cancelable context).\n\n    Example:\n        @with_current_operation()\n        async def process_item(item: str, operation: Cancelable | None):\n            if operation:\n                await operation.report_progress(f\"Processing {item}\")\n            return item.upper()\n\n    Note:\n        Unlike @cancelable, this decorator injects the CURRENT operation\n        (if one exists) rather than creating a new one. The operation\n        parameter may be None if no cancelable context is active.\n    \"\"\"\n\n    def decorator(func: Callable[P, Awaitable[R]]) -&gt; Callable[P, Awaitable[R]]:\n        @wraps(func)\n        async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n            operation = current_operation()\n\n            # Inject operation if function accepts it\n            sig = inspect.signature(func)\n            if \"operation\" in sig.parameters and \"operation\" not in kwargs:\n                kwargs[\"operation\"] = operation\n\n            return await func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators.cancelable_method","title":"cancelable_method","text":"<pre><code>cancelable_method(\n    timeout: float | timedelta | None = None,\n    name: str | None = None,\n    register_globally: bool = False,\n) -&gt; Callable[\n    [Callable[..., Awaitable[R]]],\n    Callable[..., Awaitable[R]],\n]\n</code></pre> <p>Decorator for async methods that should be cancelable.</p> <p>Similar to @cancelable but designed for class methods. The decorator automatically creates a Cancelable context and injects it as a 'cancelable' parameter. The decorated method will ALWAYS receive a non-None Cancelable instance.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | timedelta | None</code> <p>Optional timeout for the operation</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional operation name (defaults to ClassName.method_name)</p> <code>None</code> <code>register_globally</code> <code>bool</code> <p>Whether to register with global registry</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., Awaitable[R]]], Callable[..., Awaitable[R]]]</code> <p>Decorator function</p> Example <p>class DataProcessor:     @cancelable_method(timeout=60.0)     async def process(self, data: list, cancelable: Cancelable = None):         for item in data:             await self._process_item(item)             await cancelable.report_progress(f\"Processed {item}\")</p> Note <p>Type the injected parameter as <code>Cancelable = None</code> for type checker compatibility. The decorator ALWAYS provides a non-None instance, but the <code>= None</code> default signals to type checkers that callers don't need to provide this argument.</p> Source code in <code>src/hother/cancelable/utils/decorators.py</code> <pre><code>def cancelable_method(\n    timeout: float | timedelta | None = None,\n    name: str | None = None,\n    register_globally: bool = False,\n) -&gt; Callable[[Callable[..., Awaitable[R]]], Callable[..., Awaitable[R]]]:\n    \"\"\"Decorator for async methods that should be cancelable.\n\n    Similar to @cancelable but designed for class methods. The decorator\n    automatically creates a Cancelable context and injects it as a\n    'cancelable' parameter. The decorated method will ALWAYS receive a\n    non-None Cancelable instance.\n\n    Args:\n        timeout: Optional timeout for the operation\n        name: Optional operation name (defaults to ClassName.method_name)\n        register_globally: Whether to register with global registry\n\n    Returns:\n        Decorator function\n\n    Example:\n        class DataProcessor:\n            @cancelable_method(timeout=60.0)\n            async def process(self, data: list, cancelable: Cancelable = None):\n                for item in data:\n                    await self._process_item(item)\n                    await cancelable.report_progress(f\"Processed {item}\")\n\n    Note:\n        **Type the injected parameter as `Cancelable = None` for type checker\n        compatibility.** The decorator ALWAYS provides a non-None instance,\n        but the `= None` default signals to type checkers that callers don't\n        need to provide this argument.\n    \"\"\"\n\n    def decorator(func: Callable[..., Awaitable[R]]) -&gt; Callable[..., Awaitable[R]]:\n        @wraps(func)\n        async def wrapper(self: Any, *args: Any, **kwargs: Any) -&gt; R:\n            # Get method name including class\n            method_name = f\"{self.__class__.__name__}.{func.__name__}\"\n\n            cancel_kwargs: dict[str, Any] = {\n                \"name\": name or method_name,\n                \"register_globally\": register_globally,\n            }\n\n            cancel = Cancelable.with_timeout(timeout, **cancel_kwargs) if timeout else Cancelable(**cancel_kwargs)\n\n            async with cancel:\n                # Inject cancelable\n                sig = inspect.signature(func)\n                if \"cancelable\" in sig.parameters:\n                    kwargs[\"cancelable\"] = cancel\n\n                return await func(self, *args, **kwargs)\n\n            # Unreachable - async with block always completes above\n            raise AssertionError(\"Unreachable\")  # pragma: no cover\n\n        # Add attribute to access decorator parameters\n        wrapper._cancelable_params = {  # type: ignore[attr-defined]\n            \"timeout\": timeout,\n            \"name\": name,\n            \"register_globally\": register_globally,\n        }\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators.cancelable_with_token","title":"cancelable_with_token","text":"<pre><code>cancelable_with_token(\n    token: CancelationToken,\n    operation_id: str | None = None,\n    name: str | None = None,\n    register_globally: bool = False,\n    inject_param: str | None = \"cancelable\",\n) -&gt; Callable[\n    [Callable[P, Awaitable[R]]],\n    Callable[P, Awaitable[R]],\n]\n</code></pre> <p>Decorator for token-based cancelation.</p> <p>Creates a cancelable operation that can be cancelled via the provided token. Useful for operations that need to be cancelled from other tasks or threads.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>CancelationToken</code> <p>CancelationToken to use for cancelation</p> required <code>operation_id</code> <code>str | None</code> <p>Optional operation ID (auto-generated if not provided)</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional operation name (defaults to function name)</p> <code>None</code> <code>register_globally</code> <code>bool</code> <p>Whether to register with global registry</p> <code>False</code> <code>inject_param</code> <code>str | None</code> <p>Parameter name to inject Cancelable (None to disable)</p> <code>'cancelable'</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]</code> <p>Decorator function</p> Example <pre><code>token = CancelationToken()\n\n@cancelable_with_token(token, name=\"fetch_data\")\nasync def fetch_data(url: str, cancelable: Cancelable = None):\n    await cancelable.report_progress(\"Fetching...\")\n    return await httpx.get(url)\n\n# Cancel from another task\nawait token.cancel(CancelationReason.MANUAL, \"User cancelled\")\n</code></pre> Note <p>Type the injected parameter as <code>Cancelable = None</code> for type checker compatibility.</p> Source code in <code>src/hother/cancelable/utils/decorators.py</code> <pre><code>def cancelable_with_token(\n    token: \"CancelationToken\",\n    operation_id: str | None = None,\n    name: str | None = None,\n    register_globally: bool = False,\n    inject_param: str | None = \"cancelable\",\n) -&gt; Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]:\n    \"\"\"Decorator for token-based cancelation.\n\n    Creates a cancelable operation that can be cancelled via the provided token.\n    Useful for operations that need to be cancelled from other tasks or threads.\n\n    Args:\n        token: CancelationToken to use for cancelation\n        operation_id: Optional operation ID (auto-generated if not provided)\n        name: Optional operation name (defaults to function name)\n        register_globally: Whether to register with global registry\n        inject_param: Parameter name to inject Cancelable (None to disable)\n\n    Returns:\n        Decorator function\n\n    Example:\n        ```python\n        token = CancelationToken()\n\n        @cancelable_with_token(token, name=\"fetch_data\")\n        async def fetch_data(url: str, cancelable: Cancelable = None):\n            await cancelable.report_progress(\"Fetching...\")\n            return await httpx.get(url)\n\n        # Cancel from another task\n        await token.cancel(CancelationReason.MANUAL, \"User cancelled\")\n        ```\n\n    Note:\n        Type the injected parameter as `Cancelable = None` for type checker compatibility.\n    \"\"\"\n\n    def decorator(func: Callable[P, Awaitable[R]]) -&gt; Callable[P, Awaitable[R]]:\n        @wraps(func)\n        async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n            cancel = Cancelable.with_token(\n                token, operation_id=operation_id, name=name or func.__name__, register_globally=register_globally\n            )\n\n            async with cancel:\n                # Inject cancelable if requested\n                if inject_param:\n                    sig = inspect.signature(func)\n                    if inject_param in sig.parameters:\n                        kwargs[inject_param] = cancel\n\n                return await func(*args, **kwargs)\n\n            # Unreachable - async with block always completes above\n            raise AssertionError(\"Unreachable\")  # pragma: no cover\n\n        # Add attribute to access decorator parameters\n        wrapper._cancelable_params = {  # type: ignore[attr-defined]\n            \"token\": token,\n            \"operation_id\": operation_id,\n            \"name\": name,\n            \"register_globally\": register_globally,\n            \"inject_param\": inject_param,\n        }\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators.cancelable_with_signal","title":"cancelable_with_signal","text":"<pre><code>cancelable_with_signal(\n    *signals: int,\n    operation_id: str | None = None,\n    name: str | None = None,\n    register_globally: bool = False,\n    inject_param: str | None = \"cancelable\",\n) -&gt; Callable[\n    [Callable[P, Awaitable[R]]],\n    Callable[P, Awaitable[R]],\n]\n</code></pre> <p>Decorator for signal-based cancelation.</p> <p>Creates a cancelable operation that responds to OS signals (Unix only). Useful for graceful shutdown of long-running services.</p> <p>Parameters:</p> Name Type Description Default <code>*signals</code> <code>int</code> <p>Signal numbers to handle (e.g., signal.SIGTERM, signal.SIGINT)</p> <code>()</code> <code>operation_id</code> <code>str | None</code> <p>Optional operation ID (auto-generated if not provided)</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional operation name (defaults to function name)</p> <code>None</code> <code>register_globally</code> <code>bool</code> <p>Whether to register with global registry</p> <code>False</code> <code>inject_param</code> <code>str | None</code> <p>Parameter name to inject Cancelable (None to disable)</p> <code>'cancelable'</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]</code> <p>Decorator function</p> Example <pre><code>import signal\n\n@cancelable_with_signal(signal.SIGTERM, signal.SIGINT, name=\"service\")\nasync def long_running_service(cancelable: Cancelable = None):\n    while True:\n        await cancelable.report_progress(\"Processing...\")\n        await process_batch()\n</code></pre> Note <p>Type the injected parameter as <code>Cancelable = None</code> for type checker compatibility.</p> Source code in <code>src/hother/cancelable/utils/decorators.py</code> <pre><code>def cancelable_with_signal(\n    *signals: int,\n    operation_id: str | None = None,\n    name: str | None = None,\n    register_globally: bool = False,\n    inject_param: str | None = \"cancelable\",\n) -&gt; Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]:\n    \"\"\"Decorator for signal-based cancelation.\n\n    Creates a cancelable operation that responds to OS signals (Unix only).\n    Useful for graceful shutdown of long-running services.\n\n    Args:\n        *signals: Signal numbers to handle (e.g., signal.SIGTERM, signal.SIGINT)\n        operation_id: Optional operation ID (auto-generated if not provided)\n        name: Optional operation name (defaults to function name)\n        register_globally: Whether to register with global registry\n        inject_param: Parameter name to inject Cancelable (None to disable)\n\n    Returns:\n        Decorator function\n\n    Example:\n        ```python\n        import signal\n\n        @cancelable_with_signal(signal.SIGTERM, signal.SIGINT, name=\"service\")\n        async def long_running_service(cancelable: Cancelable = None):\n            while True:\n                await cancelable.report_progress(\"Processing...\")\n                await process_batch()\n        ```\n\n    Note:\n        Type the injected parameter as `Cancelable = None` for type checker compatibility.\n    \"\"\"\n\n    def decorator(func: Callable[P, Awaitable[R]]) -&gt; Callable[P, Awaitable[R]]:\n        @wraps(func)\n        async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:  # pyright: ignore[reportReturnType]\n            cancel = Cancelable.with_signal(\n                *signals, operation_id=operation_id, name=name or func.__name__, register_globally=register_globally\n            )\n\n            async with cancel:\n                # Inject cancelable if requested\n                if inject_param:\n                    sig = inspect.signature(func)\n                    if inject_param in sig.parameters:\n                        kwargs[inject_param] = cancel\n\n                return await func(*args, **kwargs)\n\n        # Add attribute to access decorator parameters\n        wrapper._cancelable_params = {  # type: ignore[attr-defined]\n            \"signals\": signals,\n            \"operation_id\": operation_id,\n            \"name\": name,\n            \"register_globally\": register_globally,\n            \"inject_param\": inject_param,\n        }\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators.cancelable_with_condition","title":"cancelable_with_condition","text":"<pre><code>cancelable_with_condition(\n    condition: Callable[[], bool | Awaitable[bool]],\n    check_interval: float = 0.1,\n    condition_name: str | None = None,\n    operation_id: str | None = None,\n    name: str | None = None,\n    register_globally: bool = False,\n    inject_param: str | None = \"cancelable\",\n) -&gt; Callable[\n    [Callable[P, Awaitable[R]]],\n    Callable[P, Awaitable[R]],\n]\n</code></pre> <p>Decorator for condition-based cancelation.</p> <p>Creates a cancelable operation that cancels when a condition becomes True. Useful for resource-based cancelation (disk full, memory limit, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Callable[[], bool | Awaitable[bool]]</code> <p>Callable that returns True when cancelation should occur</p> required <code>check_interval</code> <code>float</code> <p>How often to check the condition (seconds)</p> <code>0.1</code> <code>condition_name</code> <code>str | None</code> <p>Name for the condition (for logging)</p> <code>None</code> <code>operation_id</code> <code>str | None</code> <p>Optional operation ID (auto-generated if not provided)</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional operation name (defaults to function name)</p> <code>None</code> <code>register_globally</code> <code>bool</code> <p>Whether to register with global registry</p> <code>False</code> <code>inject_param</code> <code>str | None</code> <p>Parameter name to inject Cancelable (None to disable)</p> <code>'cancelable'</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]</code> <p>Decorator function</p> Example <pre><code>@cancelable_with_condition(\n    lambda: disk_full(),\n    check_interval=1.0,\n    condition_name=\"disk_space\"\n)\nasync def data_processing(cancelable: Cancelable = None):\n    await process_large_dataset()\n</code></pre> Note <p>Type the injected parameter as <code>Cancelable = None</code> for type checker compatibility.</p> Source code in <code>src/hother/cancelable/utils/decorators.py</code> <pre><code>def cancelable_with_condition(\n    condition: Callable[[], bool | Awaitable[bool]],\n    check_interval: float = 0.1,\n    condition_name: str | None = None,\n    operation_id: str | None = None,\n    name: str | None = None,\n    register_globally: bool = False,\n    inject_param: str | None = \"cancelable\",\n) -&gt; Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]:\n    \"\"\"Decorator for condition-based cancelation.\n\n    Creates a cancelable operation that cancels when a condition becomes True.\n    Useful for resource-based cancelation (disk full, memory limit, etc.).\n\n    Args:\n        condition: Callable that returns True when cancelation should occur\n        check_interval: How often to check the condition (seconds)\n        condition_name: Name for the condition (for logging)\n        operation_id: Optional operation ID (auto-generated if not provided)\n        name: Optional operation name (defaults to function name)\n        register_globally: Whether to register with global registry\n        inject_param: Parameter name to inject Cancelable (None to disable)\n\n    Returns:\n        Decorator function\n\n    Example:\n        ```python\n        @cancelable_with_condition(\n            lambda: disk_full(),\n            check_interval=1.0,\n            condition_name=\"disk_space\"\n        )\n        async def data_processing(cancelable: Cancelable = None):\n            await process_large_dataset()\n        ```\n\n    Note:\n        Type the injected parameter as `Cancelable = None` for type checker compatibility.\n    \"\"\"\n\n    def decorator(func: Callable[P, Awaitable[R]]) -&gt; Callable[P, Awaitable[R]]:\n        @wraps(func)\n        async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:  # pyright: ignore[reportReturnType]\n            cancel = Cancelable.with_condition(\n                condition,\n                check_interval=check_interval,\n                condition_name=condition_name,\n                operation_id=operation_id,\n                name=name or func.__name__,\n                register_globally=register_globally,\n            )\n\n            async with cancel:\n                # Inject cancelable if requested\n                if inject_param:\n                    sig = inspect.signature(func)\n                    if inject_param in sig.parameters:\n                        kwargs[inject_param] = cancel\n\n                return await func(*args, **kwargs)\n\n        # Add attribute to access decorator parameters\n        wrapper._cancelable_params = {  # type: ignore[attr-defined]\n            \"condition\": condition,\n            \"check_interval\": check_interval,\n            \"condition_name\": condition_name,\n            \"operation_id\": operation_id,\n            \"name\": name,\n            \"register_globally\": register_globally,\n            \"inject_param\": inject_param,\n        }\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators.cancelable_combine","title":"cancelable_combine","text":"<pre><code>cancelable_combine(\n    *cancelables: Cancelable,\n    operation_id: str | None = None,\n    name: str | None = None,\n    register_globally: bool = False,\n    inject_param: str | None = \"cancelable\",\n) -&gt; Callable[\n    [Callable[P, Awaitable[R]]],\n    Callable[P, Awaitable[R]],\n]\n</code></pre> <p>Decorator for combining multiple cancelation sources.</p> <p>Creates a cancelable operation that cancels when ANY of the provided cancelables trigger. Useful for operations with multiple cancelation conditions.</p> <p>Parameters:</p> Name Type Description Default <code>*cancelables</code> <code>Cancelable</code> <p>Cancelables to combine</p> <code>()</code> <code>operation_id</code> <code>str | None</code> <p>Optional operation ID (auto-generated if not provided)</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional operation name (defaults to function name)</p> <code>None</code> <code>register_globally</code> <code>bool</code> <p>Whether to register with global registry</p> <code>False</code> <code>inject_param</code> <code>str | None</code> <p>Parameter name to inject Cancelable (None to disable)</p> <code>'cancelable'</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]</code> <p>Decorator function</p> Example <pre><code>token = CancelationToken()\n\n@cancelable_combine(\n    Cancelable.with_timeout(60),\n    Cancelable.with_token(token),\n    Cancelable.with_signal(signal.SIGTERM),\n    name=\"resilient_op\"\n)\nasync def resilient_operation(cancelable: Cancelable = None):\n    return await complex_task()\n</code></pre> Note <p>Type the injected parameter as <code>Cancelable = None</code> for type checker compatibility.</p> Source code in <code>src/hother/cancelable/utils/decorators.py</code> <pre><code>def cancelable_combine(\n    *cancelables: Cancelable,\n    operation_id: str | None = None,\n    name: str | None = None,\n    register_globally: bool = False,\n    inject_param: str | None = \"cancelable\",\n) -&gt; Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]:\n    \"\"\"Decorator for combining multiple cancelation sources.\n\n    Creates a cancelable operation that cancels when ANY of the provided\n    cancelables trigger. Useful for operations with multiple cancelation conditions.\n\n    Args:\n        *cancelables: Cancelables to combine\n        operation_id: Optional operation ID (auto-generated if not provided)\n        name: Optional operation name (defaults to function name)\n        register_globally: Whether to register with global registry\n        inject_param: Parameter name to inject Cancelable (None to disable)\n\n    Returns:\n        Decorator function\n\n    Example:\n        ```python\n        token = CancelationToken()\n\n        @cancelable_combine(\n            Cancelable.with_timeout(60),\n            Cancelable.with_token(token),\n            Cancelable.with_signal(signal.SIGTERM),\n            name=\"resilient_op\"\n        )\n        async def resilient_operation(cancelable: Cancelable = None):\n            return await complex_task()\n        ```\n\n    Note:\n        Type the injected parameter as `Cancelable = None` for type checker compatibility.\n    \"\"\"\n\n    def decorator(func: Callable[P, Awaitable[R]]) -&gt; Callable[P, Awaitable[R]]:\n        @wraps(func)\n        async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:  # pyright: ignore[reportReturnType]\n            # Combine all cancelables\n            if not cancelables:\n                raise ValueError(\"At least one cancelable must be provided to cancelable_combine\")\n\n            # Get first cancelable and combine with rest\n            # Note: We use the provided cancelables as-is since they may have\n            # internal state and sources already configured\n            first = cancelables[0]\n            cancel = first.combine(*cancelables[1:]) if len(cancelables) &gt; 1 else first\n\n            # Determine the effective name\n            # Always prefer explicit name, then function name (for decorator consistency)\n            effective_name = name or func.__name__\n\n            # Create a new cancelable with the desired name to avoid mutating shared state\n            # We'll use the combined token from the original\n\n            # Always wrap to apply decorator settings (name, operation_id, register_globally)\n            final_cancel = Cancelable.with_token(\n                cancel.token,\n                operation_id=operation_id or cancel.context.id,\n                name=effective_name,\n                register_globally=register_globally,\n            )\n\n            async with final_cancel:\n                # Inject cancelable if requested\n                if inject_param:\n                    sig = inspect.signature(func)\n                    if inject_param in sig.parameters:\n                        kwargs[inject_param] = final_cancel\n\n                return await func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.decorators.with_cancelable","title":"with_cancelable","text":"<pre><code>with_cancelable(\n    cancel: Cancelable,\n    inject: bool = False,\n    inject_param: str = \"cancelable\",\n) -&gt; Callable[\n    [Callable[P, Awaitable[R]]],\n    Callable[P, Awaitable[R]],\n]\n</code></pre> <p>Decorator that wraps a function with an existing Cancelable instance.</p> <p>This decorator allows you to use a pre-configured Cancelable context with your async function. Unlike @cancelable which creates a new context, this decorator uses an existing one, enabling sharing of cancelation state across multiple functions.</p> <p>Parameters:</p> Name Type Description Default <code>cancel</code> <code>Cancelable</code> <p>Existing Cancelable instance to use</p> required <code>inject</code> <code>bool</code> <p>Whether to inject the Cancelable into the function signature (default: False)</p> <code>False</code> <code>inject_param</code> <code>str</code> <p>Parameter name to inject Cancelable as (default: \"cancelable\")</p> <code>'cancelable'</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]</code> <p>Decorator function</p> Example <pre><code>from hother.cancelable import Cancelable, with_cancelable, current_operation\n\n# Create a shared cancelable context\ncancel = Cancelable.with_timeout(30.0, name=\"data_pipeline\")\n\n@with_cancelable(cancel)\nasync def fetch_data():\n    # No injection, access via current_operation()\n    ctx = current_operation()\n    await ctx.report_progress(\"Fetching data...\")\n    return await fetch()\n\n@with_cancelable(cancel, inject=True)\nasync def process_data(cancelable: Cancelable = None):\n    # With injection\n    await cancelable.report_progress(\"Processing...\")\n    return await process()\n\n# Both functions share the same cancelation context\nasync with cancel:\n    data = await fetch_data()\n    result = await process_data()\n</code></pre> Note <p>When inject=False (default), use current_operation() to access the context from within the function if needed.</p> Source code in <code>src/hother/cancelable/utils/decorators.py</code> <pre><code>def with_cancelable(\n    cancel: Cancelable,\n    inject: bool = False,\n    inject_param: str = \"cancelable\",\n) -&gt; Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]:\n    \"\"\"Decorator that wraps a function with an existing Cancelable instance.\n\n    This decorator allows you to use a pre-configured Cancelable context\n    with your async function. Unlike @cancelable which creates a new context,\n    this decorator uses an existing one, enabling sharing of cancelation state\n    across multiple functions.\n\n    Args:\n        cancel: Existing Cancelable instance to use\n        inject: Whether to inject the Cancelable into the function signature (default: False)\n        inject_param: Parameter name to inject Cancelable as (default: \"cancelable\")\n\n    Returns:\n        Decorator function\n\n    Example:\n        ```python\n        from hother.cancelable import Cancelable, with_cancelable, current_operation\n\n        # Create a shared cancelable context\n        cancel = Cancelable.with_timeout(30.0, name=\"data_pipeline\")\n\n        @with_cancelable(cancel)\n        async def fetch_data():\n            # No injection, access via current_operation()\n            ctx = current_operation()\n            await ctx.report_progress(\"Fetching data...\")\n            return await fetch()\n\n        @with_cancelable(cancel, inject=True)\n        async def process_data(cancelable: Cancelable = None):\n            # With injection\n            await cancelable.report_progress(\"Processing...\")\n            return await process()\n\n        # Both functions share the same cancelation context\n        async with cancel:\n            data = await fetch_data()\n            result = await process_data()\n        ```\n\n    Note:\n        When inject=False (default), use current_operation() to access the context\n        from within the function if needed.\n    \"\"\"\n\n    def decorator(func: Callable[P, Awaitable[R]]) -&gt; Callable[P, Awaitable[R]]:\n        @wraps(func)\n        async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n            # Note: We don't enter the cancel context here - that's the user's responsibility\n            # This decorator just makes the cancel instance available to the function\n            # The user must use: async with cancel: await decorated_function()\n\n            # Inject cancelable if requested\n            if inject:\n                sig = inspect.signature(func)\n                if inject_param in sig.parameters:\n                    kwargs[inject_param] = cancel\n\n            return await func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/utilities/#bridges","title":"Bridges","text":""},{"location":"reference/utilities/#anyio-bridge","title":"AnyIO Bridge","text":"<p>Bridge for integrating with anyio-based async code.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.anyio_bridge","title":"hother.cancelable.utils.anyio_bridge","text":"<p>Global bridge for thread-safe anyio operations.</p> <p>Allows regular Python threads to schedule callbacks in anyio context, providing an equivalent to asyncio's loop.call_soon_threadsafe().</p>"},{"location":"reference/utilities/#hother.cancelable.utils.anyio_bridge.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = get_logger(__name__)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.anyio_bridge.AnyioBridge","title":"AnyioBridge","text":"<p>Singleton bridge for thread-to-anyio communication.</p> <p>Provides call_soon_threadsafe equivalent for anyio by using memory object streams and a background worker task.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_size</code> <code>int</code> <p>Maximum number of queued callbacks before blocking (default: 1000)</p> <code>1000</code> Example <pre><code># Custom buffer size for high-throughput applications\nbridge = AnyioBridge(buffer_size=5000)\nawait bridge.start()\n\n# Or use default\nbridge = AnyioBridge.get_instance()\n\nasync with anyio.create_task_group() as tg:\n    tg.start_soon(bridge.start)\n\n    # Now thread-safe calls work\n    def from_thread():\n        bridge.call_soon_threadsafe(some_callback)\n</code></pre> Source code in <code>src/hother/cancelable/utils/anyio_bridge.py</code> <pre><code>class AnyioBridge:\n    \"\"\"Singleton bridge for thread-to-anyio communication.\n\n    Provides call_soon_threadsafe equivalent for anyio by using\n    memory object streams and a background worker task.\n\n    Args:\n        buffer_size: Maximum number of queued callbacks before blocking (default: 1000)\n\n    Example:\n        ```python\n        # Custom buffer size for high-throughput applications\n        bridge = AnyioBridge(buffer_size=5000)\n        await bridge.start()\n\n        # Or use default\n        bridge = AnyioBridge.get_instance()\n\n        async with anyio.create_task_group() as tg:\n            tg.start_soon(bridge.start)\n\n            # Now thread-safe calls work\n            def from_thread():\n                bridge.call_soon_threadsafe(some_callback)\n        ```\n    \"\"\"\n\n    _instance: AnyioBridge | None = None\n    _lock = threading.Lock()\n\n    def __init__(self, buffer_size: int = 1000) -&gt; None:\n        \"\"\"Initialize the AnyioBridge.\n\n        Args:\n            buffer_size: Maximum number of queued callbacks before blocking (default: 1000)\n        \"\"\"\n        self._buffer_size = buffer_size\n        self._send_stream: anyio.abc.ObjectSendStream | None = None  # type: ignore[attr-defined]\n        self._receive_stream: anyio.abc.ObjectReceiveStream | None = None  # type: ignore[attr-defined]\n        self._started: bool = False\n\n        # Fallback queue for callbacks received before bridge starts\n        self._pending_callbacks: deque[Callable[[], Any]] = deque()\n        self._pending_lock = threading.Lock()\n\n    @classmethod\n    def get_instance(cls) -&gt; Self:\n        \"\"\"Get singleton instance of the bridge.\n\n        Thread-safe lazy initialization.\n\n        Returns:\n            The singleton AnyioBridge instance\n        \"\"\"\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = cls()\n        return cls._instance  # type: ignore[return-value]\n\n    async def start(self) -&gt; None:\n        \"\"\"Start the bridge worker task.\n\n        Should be called once at application startup from async context.\n        Must be run in a task group as it blocks forever.\n\n        Example:\n            ```python\n            async with anyio.create_task_group() as tg:\n                tg.start_soon(bridge.start)\n                # Bridge is now running\n            ```\n        \"\"\"\n        if self._started:\n            logger.warning(\"Bridge already started, ignoring duplicate start\")\n            logger.info(f\"Bridge worker alive check - stream is: {self._receive_stream}\")  # type: ignore[attr-defined]\n            return\n\n        logger.debug(\"Starting anyio bridge\")\n\n        # Create communication streams\n        self._send_stream, self._receive_stream = anyio.create_memory_object_stream(self._buffer_size)\n\n        # Process any pending callbacks that arrived before bridge started\n        with self._pending_lock:\n            pending_count = len(self._pending_callbacks)\n            if pending_count &gt; 0:\n                logger.info(f\"Processing {pending_count} pending callbacks\")\n                while self._pending_callbacks:\n                    callback = self._pending_callbacks.popleft()\n                    try:\n                        self._send_stream.send_nowait(callback)  # type: ignore[union-attr]\n                    except anyio.WouldBlock:\n                        logger.warning(\"Bridge queue full during startup, callback dropped\")\n\n        self._started = True\n        logger.info(\"Anyio bridge started and ready\")\n\n        # Start worker loop (blocks forever)\n        await self._worker()\n\n    async def _worker(self) -&gt; None:\n        \"\"\"Worker task that processes callbacks from threads.\n\n        Runs forever until the receive stream is closed.\n        \"\"\"\n        logger.info(\"Bridge worker started, waiting for callbacks...\")\n        try:\n            while True:\n                # Explicitly receive next callback (yields properly)\n                logger.debug(\"Bridge worker waiting for next callback...\")\n                callback = await self._receive_stream.receive()  # type: ignore[union-attr]\n                logger.debug(f\"Bridge worker received callback: {callback}\")\n\n                try:\n                    # Execute callback\n                    logger.debug(\"Bridge worker executing callback...\")\n                    result = callback()  # type: ignore[var-annotated]\n                    logger.debug(f\"Callback result: {result}\")\n\n                    # If it's a coroutine, await it\n                    if hasattr(result, \"__await__\"):  # type: ignore[arg-type]\n                        logger.debug(\"Callback is coroutine, awaiting...\")\n                        await result\n                        logger.debug(\"Coroutine completed\")\n                    else:\n                        logger.debug(\"Callback completed (sync)\")\n                except Exception as e:\n                    logger.error(f\"Bridge callback error: {e}\", exc_info=True)\n\n                # Explicitly yield control to anyio scheduler\n                await checkpoint()\n\n        except anyio.EndOfStream:\n            logger.info(\"Bridge stream closed, worker ending normally\")\n        except Exception as e:\n            logger.error(f\"Bridge worker error: {e}\", exc_info=True)\n\n        logger.warning(\"Bridge worker loop ended\")\n\n    def call_soon_threadsafe(self, callback: Callable[[], Any]) -&gt; None:\n        \"\"\"Schedule callback to run in anyio context from any thread.\n\n        This is the anyio equivalent of asyncio's loop.call_soon_threadsafe().\n        The callback will be executed in the anyio event loop context.\n\n        Args:\n            callback: Function to call (can be sync or async)\n\n        Note:\n            If the bridge hasn't started yet, callbacks are queued\n            and will be processed once the bridge starts.\n        \"\"\"\n        if not self._started:\n            # Queue for later processing\n            with self._pending_lock:\n                self._pending_callbacks.append(callback)\n                logger.debug(f\"Bridge not started, queuing callback (queue size: {len(self._pending_callbacks)})\")\n            return\n\n        logger.debug(f\"Queueing callback to bridge: {callback}\")\n        try:\n            self._send_stream.send_nowait(callback)  # type: ignore[union-attr]\n            logger.debug(\"Callback successfully queued to bridge stream\")\n        except anyio.WouldBlock:\n            logger.warning(\n                f\"Bridge queue full ({self._buffer_size} callbacks), \" \"callback dropped - consider increasing buffer size\"\n            )\n        except Exception as e:\n            logger.error(f\"Failed to schedule callback: {e}\", exc_info=True)\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop the bridge and clean up resources.\n\n        Properly closes the send and receive streams to avoid\n        resource leak warnings during garbage collection.\n\n        Should be called before cancelling the task group running the bridge.\n\n        Example:\n            ```python\n            async with anyio.create_task_group() as tg:\n                tg.start_soon(bridge.start)\n                # ... use bridge ...\n                await bridge.stop()\n                tg.cancel_scope.cancel()\n            ```\n        \"\"\"\n        logger.debug(\"Stopping anyio bridge\")\n\n        # Close streams if they exist\n        if self._send_stream is not None:  # type: ignore[attr-defined]\n            try:\n                await self._send_stream.aclose()  # type: ignore[union-attr]\n                logger.debug(\"Send stream closed\")\n            except Exception as e:\n                logger.warning(f\"Error closing send stream: {e}\")\n\n        if self._receive_stream is not None:  # type: ignore[attr-defined]\n            try:\n                await self._receive_stream.aclose()  # type: ignore[union-attr]\n                logger.debug(\"Receive stream closed\")\n            except Exception as e:\n                logger.warning(f\"Error closing receive stream: {e}\")\n\n        self._started = False\n        self._send_stream = None\n        self._receive_stream = None\n        logger.info(\"Anyio bridge stopped and cleaned up\")\n\n    @property\n    def is_started(self) -&gt; bool:\n        \"\"\"Check if bridge is started and ready.\"\"\"\n        return self._started\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.anyio_bridge.AnyioBridge.is_started","title":"is_started  <code>property</code>","text":"<pre><code>is_started: bool\n</code></pre> <p>Check if bridge is started and ready.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.anyio_bridge.AnyioBridge.get_instance","title":"get_instance  <code>classmethod</code>","text":"<pre><code>get_instance() -&gt; Self\n</code></pre> <p>Get singleton instance of the bridge.</p> <p>Thread-safe lazy initialization.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The singleton AnyioBridge instance</p> Source code in <code>src/hother/cancelable/utils/anyio_bridge.py</code> <pre><code>@classmethod\ndef get_instance(cls) -&gt; Self:\n    \"\"\"Get singleton instance of the bridge.\n\n    Thread-safe lazy initialization.\n\n    Returns:\n        The singleton AnyioBridge instance\n    \"\"\"\n    if cls._instance is None:\n        with cls._lock:\n            if cls._instance is None:\n                cls._instance = cls()\n    return cls._instance  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.anyio_bridge.AnyioBridge.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the bridge worker task.</p> <p>Should be called once at application startup from async context. Must be run in a task group as it blocks forever.</p> Example <pre><code>async with anyio.create_task_group() as tg:\n    tg.start_soon(bridge.start)\n    # Bridge is now running\n</code></pre> Source code in <code>src/hother/cancelable/utils/anyio_bridge.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the bridge worker task.\n\n    Should be called once at application startup from async context.\n    Must be run in a task group as it blocks forever.\n\n    Example:\n        ```python\n        async with anyio.create_task_group() as tg:\n            tg.start_soon(bridge.start)\n            # Bridge is now running\n        ```\n    \"\"\"\n    if self._started:\n        logger.warning(\"Bridge already started, ignoring duplicate start\")\n        logger.info(f\"Bridge worker alive check - stream is: {self._receive_stream}\")  # type: ignore[attr-defined]\n        return\n\n    logger.debug(\"Starting anyio bridge\")\n\n    # Create communication streams\n    self._send_stream, self._receive_stream = anyio.create_memory_object_stream(self._buffer_size)\n\n    # Process any pending callbacks that arrived before bridge started\n    with self._pending_lock:\n        pending_count = len(self._pending_callbacks)\n        if pending_count &gt; 0:\n            logger.info(f\"Processing {pending_count} pending callbacks\")\n            while self._pending_callbacks:\n                callback = self._pending_callbacks.popleft()\n                try:\n                    self._send_stream.send_nowait(callback)  # type: ignore[union-attr]\n                except anyio.WouldBlock:\n                    logger.warning(\"Bridge queue full during startup, callback dropped\")\n\n    self._started = True\n    logger.info(\"Anyio bridge started and ready\")\n\n    # Start worker loop (blocks forever)\n    await self._worker()\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.anyio_bridge.AnyioBridge.call_soon_threadsafe","title":"call_soon_threadsafe","text":"<pre><code>call_soon_threadsafe(callback: Callable[[], Any]) -&gt; None\n</code></pre> <p>Schedule callback to run in anyio context from any thread.</p> <p>This is the anyio equivalent of asyncio's loop.call_soon_threadsafe(). The callback will be executed in the anyio event loop context.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[], Any]</code> <p>Function to call (can be sync or async)</p> required Note <p>If the bridge hasn't started yet, callbacks are queued and will be processed once the bridge starts.</p> Source code in <code>src/hother/cancelable/utils/anyio_bridge.py</code> <pre><code>def call_soon_threadsafe(self, callback: Callable[[], Any]) -&gt; None:\n    \"\"\"Schedule callback to run in anyio context from any thread.\n\n    This is the anyio equivalent of asyncio's loop.call_soon_threadsafe().\n    The callback will be executed in the anyio event loop context.\n\n    Args:\n        callback: Function to call (can be sync or async)\n\n    Note:\n        If the bridge hasn't started yet, callbacks are queued\n        and will be processed once the bridge starts.\n    \"\"\"\n    if not self._started:\n        # Queue for later processing\n        with self._pending_lock:\n            self._pending_callbacks.append(callback)\n            logger.debug(f\"Bridge not started, queuing callback (queue size: {len(self._pending_callbacks)})\")\n        return\n\n    logger.debug(f\"Queueing callback to bridge: {callback}\")\n    try:\n        self._send_stream.send_nowait(callback)  # type: ignore[union-attr]\n        logger.debug(\"Callback successfully queued to bridge stream\")\n    except anyio.WouldBlock:\n        logger.warning(\n            f\"Bridge queue full ({self._buffer_size} callbacks), \" \"callback dropped - consider increasing buffer size\"\n        )\n    except Exception as e:\n        logger.error(f\"Failed to schedule callback: {e}\", exc_info=True)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.anyio_bridge.AnyioBridge.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the bridge and clean up resources.</p> <p>Properly closes the send and receive streams to avoid resource leak warnings during garbage collection.</p> <p>Should be called before cancelling the task group running the bridge.</p> Example <pre><code>async with anyio.create_task_group() as tg:\n    tg.start_soon(bridge.start)\n    # ... use bridge ...\n    await bridge.stop()\n    tg.cancel_scope.cancel()\n</code></pre> Source code in <code>src/hother/cancelable/utils/anyio_bridge.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the bridge and clean up resources.\n\n    Properly closes the send and receive streams to avoid\n    resource leak warnings during garbage collection.\n\n    Should be called before cancelling the task group running the bridge.\n\n    Example:\n        ```python\n        async with anyio.create_task_group() as tg:\n            tg.start_soon(bridge.start)\n            # ... use bridge ...\n            await bridge.stop()\n            tg.cancel_scope.cancel()\n        ```\n    \"\"\"\n    logger.debug(\"Stopping anyio bridge\")\n\n    # Close streams if they exist\n    if self._send_stream is not None:  # type: ignore[attr-defined]\n        try:\n            await self._send_stream.aclose()  # type: ignore[union-attr]\n            logger.debug(\"Send stream closed\")\n        except Exception as e:\n            logger.warning(f\"Error closing send stream: {e}\")\n\n    if self._receive_stream is not None:  # type: ignore[attr-defined]\n        try:\n            await self._receive_stream.aclose()  # type: ignore[union-attr]\n            logger.debug(\"Receive stream closed\")\n        except Exception as e:\n            logger.warning(f\"Error closing receive stream: {e}\")\n\n    self._started = False\n    self._send_stream = None\n    self._receive_stream = None\n    logger.info(\"Anyio bridge stopped and cleaned up\")\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.anyio_bridge.call_soon_threadsafe","title":"call_soon_threadsafe","text":"<pre><code>call_soon_threadsafe(callback: Callable[[], Any]) -&gt; None\n</code></pre> <p>Convenience function for thread-safe anyio scheduling.</p> <p>Equivalent to bridge.get_instance().call_soon_threadsafe(callback).</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[], Any]</code> <p>Function to call in anyio context</p> required Example <pre><code>def on_signal(signum):\n    # Called from signal handler thread\n    async def cancel_operation():\n        await token.cancel()\n\n    call_soon_threadsafe(cancel_operation)\n</code></pre> Source code in <code>src/hother/cancelable/utils/anyio_bridge.py</code> <pre><code>def call_soon_threadsafe(callback: Callable[[], Any]) -&gt; None:\n    \"\"\"Convenience function for thread-safe anyio scheduling.\n\n    Equivalent to bridge.get_instance().call_soon_threadsafe(callback).\n\n    Args:\n        callback: Function to call in anyio context\n\n    Example:\n        ```python\n        def on_signal(signum):\n            # Called from signal handler thread\n            async def cancel_operation():\n                await token.cancel()\n\n            call_soon_threadsafe(cancel_operation)\n        ```\n    \"\"\"\n    bridge = AnyioBridge.get_instance()\n    bridge.call_soon_threadsafe(callback)\n</code></pre>"},{"location":"reference/utilities/#threading-bridge","title":"Threading Bridge","text":"<p>Bridge for canceling operations from threads.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.threading_bridge","title":"hother.cancelable.utils.threading_bridge","text":"<p>Thread-safe wrapper for OperationRegistry.</p> <p>Provides synchronous API for accessing the registry from threads.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.threading_bridge.ThreadSafeRegistry","title":"ThreadSafeRegistry","text":"<p>Thread-safe wrapper for OperationRegistry.</p> <p>Provides synchronous API for accessing the registry from threads. All methods are thread-safe and can be called from any thread.</p> <p>This class wraps the OperationRegistry singleton and provides convenience methods without the <code>_sync</code> suffix.</p> Example <pre><code># From a thread (e.g., Flask/Django handler)\nfrom hother.cancelable import ThreadSafeRegistry\n\nregistry = ThreadSafeRegistry()\n\n# List running operations\noperations = registry.list_operations(status=OperationStatus.RUNNING)\n\n# Cancel a specific operation\nregistry.cancel_operation(op_id, reason=CancelationReason.MANUAL)\n\n# Get statistics\nstats = registry.get_statistics()\nprint(f\"Active operations: {stats['active_operations']}\")\n</code></pre> Note <ul> <li>Read operations (get, list, statistics, history) return immediately with data</li> <li>Write operations (cancel) schedule async work and return immediately</li> <li>For async code, use OperationRegistry directly instead</li> </ul> Source code in <code>src/hother/cancelable/utils/threading_bridge.py</code> <pre><code>class ThreadSafeRegistry:\n    \"\"\"Thread-safe wrapper for OperationRegistry.\n\n    Provides synchronous API for accessing the registry from threads.\n    All methods are thread-safe and can be called from any thread.\n\n    This class wraps the OperationRegistry singleton and provides\n    convenience methods without the `_sync` suffix.\n\n    Example:\n        ```python\n        # From a thread (e.g., Flask/Django handler)\n        from hother.cancelable import ThreadSafeRegistry\n\n        registry = ThreadSafeRegistry()\n\n        # List running operations\n        operations = registry.list_operations(status=OperationStatus.RUNNING)\n\n        # Cancel a specific operation\n        registry.cancel_operation(op_id, reason=CancelationReason.MANUAL)\n\n        # Get statistics\n        stats = registry.get_statistics()\n        print(f\"Active operations: {stats['active_operations']}\")\n        ```\n\n    Note:\n        - Read operations (get, list, statistics, history) return immediately with data\n        - Write operations (cancel) schedule async work and return immediately\n        - For async code, use OperationRegistry directly instead\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize thread-safe registry wrapper.\"\"\"\n        self._registry = OperationRegistry.get_instance()\n\n    def get_operation(self, operation_id: str) -&gt; Cancelable | None:\n        \"\"\"Get operation by ID.\n\n        Args:\n            operation_id: Operation ID to look up\n\n        Returns:\n            Cancelable operation or None if not found\n        \"\"\"\n        return self._registry.get_operation_sync(operation_id)\n\n    def list_operations(\n        self,\n        status: OperationStatus | None = None,\n        parent_id: str | None = None,\n        name_pattern: str | None = None,\n    ) -&gt; list[OperationContext]:\n        \"\"\"List operations with optional filtering.\n\n        Args:\n            status: Filter by operation status\n            parent_id: Filter by parent operation ID\n            name_pattern: Filter by name (substring match)\n\n        Returns:\n            List of matching operation contexts\n        \"\"\"\n        return self._registry.list_operations_sync(status, parent_id, name_pattern)\n\n    def get_statistics(self) -&gt; dict[str, Any]:\n        \"\"\"Get registry statistics.\n\n        Returns:\n            Dictionary with operation statistics containing:\n            - active_operations: Number of active operations\n            - active_by_status: Active operations grouped by status\n            - history_size: Number of operations in history\n            - history_by_status: Historical operations grouped by status\n            - average_duration_seconds: Average duration of completed operations\n            - total_completed: Total number of completed operations\n        \"\"\"\n        return self._registry.get_statistics_sync()\n\n    def get_history(\n        self,\n        limit: int | None = None,\n        status: OperationStatus | None = None,\n        since: datetime | None = None,\n    ) -&gt; list[OperationContext]:\n        \"\"\"Get operation history.\n\n        Args:\n            limit: Maximum number of operations to return\n            status: Filter by final status\n            since: Only return operations completed after this time\n\n        Returns:\n            List of historical operation contexts\n        \"\"\"\n        return self._registry.get_history_sync(limit, status, since)\n\n    def cancel_operation(\n        self,\n        operation_id: str,\n        reason: CancelationReason = CancelationReason.MANUAL,\n        message: str | None = None,\n    ) -&gt; None:\n        \"\"\"Cancel a specific operation.\n\n        Schedules cancelation to be executed asynchronously and returns immediately.\n\n        Args:\n            operation_id: ID of operation to cancel\n            reason: Reason for cancelation\n            message: Optional cancelation message\n\n        Note:\n            This method returns immediately. The cancelation is scheduled\n            asynchronously via AnyioBridge.\n        \"\"\"\n        self._registry.cancel_operation_sync(operation_id, reason, message)\n\n    def cancel_all(\n        self,\n        status: OperationStatus | None = None,\n        reason: CancelationReason = CancelationReason.MANUAL,\n        message: str | None = None,\n    ) -&gt; None:\n        \"\"\"Cancel all operations with optional status filter.\n\n        Schedules cancelation to be executed asynchronously and returns immediately.\n\n        Args:\n            status: Only cancel operations with this status\n            reason: Reason for cancelation\n            message: Optional cancelation message\n\n        Note:\n            This method returns immediately. The cancelation is scheduled\n            asynchronously via AnyioBridge.\n        \"\"\"\n        self._registry.cancel_all_sync(status, reason, message)\n\n    # Singleton pattern (optional - users can create instances directly or use singleton)\n\n    _instance: ThreadSafeRegistry | None = None\n    _lock = threading.Lock()\n\n    @classmethod\n    def get_instance(cls) -&gt; ThreadSafeRegistry:\n        \"\"\"Get singleton instance of thread-safe registry.\n\n        Thread-safe lazy initialization.\n\n        Returns:\n            The singleton ThreadSafeRegistry instance\n\n        Example:\n            ```python\n            registry = ThreadSafeRegistry.get_instance()\n            stats = registry.get_statistics()\n            ```\n        \"\"\"\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = cls()\n        return cls._instance\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.threading_bridge.ThreadSafeRegistry.get_operation","title":"get_operation","text":"<pre><code>get_operation(operation_id: str) -&gt; Cancelable | None\n</code></pre> <p>Get operation by ID.</p> <p>Parameters:</p> Name Type Description Default <code>operation_id</code> <code>str</code> <p>Operation ID to look up</p> required <p>Returns:</p> Type Description <code>Cancelable | None</code> <p>Cancelable operation or None if not found</p> Source code in <code>src/hother/cancelable/utils/threading_bridge.py</code> <pre><code>def get_operation(self, operation_id: str) -&gt; Cancelable | None:\n    \"\"\"Get operation by ID.\n\n    Args:\n        operation_id: Operation ID to look up\n\n    Returns:\n        Cancelable operation or None if not found\n    \"\"\"\n    return self._registry.get_operation_sync(operation_id)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.threading_bridge.ThreadSafeRegistry.list_operations","title":"list_operations","text":"<pre><code>list_operations(\n    status: OperationStatus | None = None,\n    parent_id: str | None = None,\n    name_pattern: str | None = None,\n) -&gt; list[OperationContext]\n</code></pre> <p>List operations with optional filtering.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>OperationStatus | None</code> <p>Filter by operation status</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>Filter by parent operation ID</p> <code>None</code> <code>name_pattern</code> <code>str | None</code> <p>Filter by name (substring match)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[OperationContext]</code> <p>List of matching operation contexts</p> Source code in <code>src/hother/cancelable/utils/threading_bridge.py</code> <pre><code>def list_operations(\n    self,\n    status: OperationStatus | None = None,\n    parent_id: str | None = None,\n    name_pattern: str | None = None,\n) -&gt; list[OperationContext]:\n    \"\"\"List operations with optional filtering.\n\n    Args:\n        status: Filter by operation status\n        parent_id: Filter by parent operation ID\n        name_pattern: Filter by name (substring match)\n\n    Returns:\n        List of matching operation contexts\n    \"\"\"\n    return self._registry.list_operations_sync(status, parent_id, name_pattern)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.threading_bridge.ThreadSafeRegistry.get_statistics","title":"get_statistics","text":"<pre><code>get_statistics() -&gt; dict[str, Any]\n</code></pre> <p>Get registry statistics.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with operation statistics containing:</p> <code>dict[str, Any]</code> <ul> <li>active_operations: Number of active operations</li> </ul> <code>dict[str, Any]</code> <ul> <li>active_by_status: Active operations grouped by status</li> </ul> <code>dict[str, Any]</code> <ul> <li>history_size: Number of operations in history</li> </ul> <code>dict[str, Any]</code> <ul> <li>history_by_status: Historical operations grouped by status</li> </ul> <code>dict[str, Any]</code> <ul> <li>average_duration_seconds: Average duration of completed operations</li> </ul> <code>dict[str, Any]</code> <ul> <li>total_completed: Total number of completed operations</li> </ul> Source code in <code>src/hother/cancelable/utils/threading_bridge.py</code> <pre><code>def get_statistics(self) -&gt; dict[str, Any]:\n    \"\"\"Get registry statistics.\n\n    Returns:\n        Dictionary with operation statistics containing:\n        - active_operations: Number of active operations\n        - active_by_status: Active operations grouped by status\n        - history_size: Number of operations in history\n        - history_by_status: Historical operations grouped by status\n        - average_duration_seconds: Average duration of completed operations\n        - total_completed: Total number of completed operations\n    \"\"\"\n    return self._registry.get_statistics_sync()\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.threading_bridge.ThreadSafeRegistry.get_history","title":"get_history","text":"<pre><code>get_history(\n    limit: int | None = None,\n    status: OperationStatus | None = None,\n    since: datetime | None = None,\n) -&gt; list[OperationContext]\n</code></pre> <p>Get operation history.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum number of operations to return</p> <code>None</code> <code>status</code> <code>OperationStatus | None</code> <p>Filter by final status</p> <code>None</code> <code>since</code> <code>datetime | None</code> <p>Only return operations completed after this time</p> <code>None</code> <p>Returns:</p> Type Description <code>list[OperationContext]</code> <p>List of historical operation contexts</p> Source code in <code>src/hother/cancelable/utils/threading_bridge.py</code> <pre><code>def get_history(\n    self,\n    limit: int | None = None,\n    status: OperationStatus | None = None,\n    since: datetime | None = None,\n) -&gt; list[OperationContext]:\n    \"\"\"Get operation history.\n\n    Args:\n        limit: Maximum number of operations to return\n        status: Filter by final status\n        since: Only return operations completed after this time\n\n    Returns:\n        List of historical operation contexts\n    \"\"\"\n    return self._registry.get_history_sync(limit, status, since)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.threading_bridge.ThreadSafeRegistry.cancel_operation","title":"cancel_operation","text":"<pre><code>cancel_operation(\n    operation_id: str,\n    reason: CancelationReason = MANUAL,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Cancel a specific operation.</p> <p>Schedules cancelation to be executed asynchronously and returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>operation_id</code> <code>str</code> <p>ID of operation to cancel</p> required <code>reason</code> <code>CancelationReason</code> <p>Reason for cancelation</p> <code>MANUAL</code> <code>message</code> <code>str | None</code> <p>Optional cancelation message</p> <code>None</code> Note <p>This method returns immediately. The cancelation is scheduled asynchronously via AnyioBridge.</p> Source code in <code>src/hother/cancelable/utils/threading_bridge.py</code> <pre><code>def cancel_operation(\n    self,\n    operation_id: str,\n    reason: CancelationReason = CancelationReason.MANUAL,\n    message: str | None = None,\n) -&gt; None:\n    \"\"\"Cancel a specific operation.\n\n    Schedules cancelation to be executed asynchronously and returns immediately.\n\n    Args:\n        operation_id: ID of operation to cancel\n        reason: Reason for cancelation\n        message: Optional cancelation message\n\n    Note:\n        This method returns immediately. The cancelation is scheduled\n        asynchronously via AnyioBridge.\n    \"\"\"\n    self._registry.cancel_operation_sync(operation_id, reason, message)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.threading_bridge.ThreadSafeRegistry.cancel_all","title":"cancel_all","text":"<pre><code>cancel_all(\n    status: OperationStatus | None = None,\n    reason: CancelationReason = MANUAL,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Cancel all operations with optional status filter.</p> <p>Schedules cancelation to be executed asynchronously and returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>OperationStatus | None</code> <p>Only cancel operations with this status</p> <code>None</code> <code>reason</code> <code>CancelationReason</code> <p>Reason for cancelation</p> <code>MANUAL</code> <code>message</code> <code>str | None</code> <p>Optional cancelation message</p> <code>None</code> Note <p>This method returns immediately. The cancelation is scheduled asynchronously via AnyioBridge.</p> Source code in <code>src/hother/cancelable/utils/threading_bridge.py</code> <pre><code>def cancel_all(\n    self,\n    status: OperationStatus | None = None,\n    reason: CancelationReason = CancelationReason.MANUAL,\n    message: str | None = None,\n) -&gt; None:\n    \"\"\"Cancel all operations with optional status filter.\n\n    Schedules cancelation to be executed asynchronously and returns immediately.\n\n    Args:\n        status: Only cancel operations with this status\n        reason: Reason for cancelation\n        message: Optional cancelation message\n\n    Note:\n        This method returns immediately. The cancelation is scheduled\n        asynchronously via AnyioBridge.\n    \"\"\"\n    self._registry.cancel_all_sync(status, reason, message)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.threading_bridge.ThreadSafeRegistry.get_instance","title":"get_instance  <code>classmethod</code>","text":"<pre><code>get_instance() -&gt; ThreadSafeRegistry\n</code></pre> <p>Get singleton instance of thread-safe registry.</p> <p>Thread-safe lazy initialization.</p> <p>Returns:</p> Type Description <code>ThreadSafeRegistry</code> <p>The singleton ThreadSafeRegistry instance</p> Example <pre><code>registry = ThreadSafeRegistry.get_instance()\nstats = registry.get_statistics()\n</code></pre> Source code in <code>src/hother/cancelable/utils/threading_bridge.py</code> <pre><code>@classmethod\ndef get_instance(cls) -&gt; ThreadSafeRegistry:\n    \"\"\"Get singleton instance of thread-safe registry.\n\n    Thread-safe lazy initialization.\n\n    Returns:\n        The singleton ThreadSafeRegistry instance\n\n    Example:\n        ```python\n        registry = ThreadSafeRegistry.get_instance()\n        stats = registry.get_statistics()\n        ```\n    \"\"\"\n    if cls._instance is None:\n        with cls._lock:\n            if cls._instance is None:\n                cls._instance = cls()\n    return cls._instance\n</code></pre>"},{"location":"reference/utilities/#context-bridge","title":"Context Bridge","text":"<p>Context propagation utilities.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.context_bridge","title":"hother.cancelable.utils.context_bridge","text":"<p>Context bridge utilities for thread-safe context variable propagation.</p> <p>This module provides utilities to safely propagate context variables between async tasks and OS threads, solving the context variable thread safety issue.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.context_bridge.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.context_bridge.ContextBridge","title":"ContextBridge","text":"<p>Thread-safe context variable bridge for async-to-thread communication.</p> <p>This class solves the issue where context variables don't propagate to OS threads created by ThreadPoolExecutor, breaking operation tracking in multi-threaded applications.</p> Source code in <code>src/hother/cancelable/utils/context_bridge.py</code> <pre><code>class ContextBridge:\n    \"\"\"Thread-safe context variable bridge for async-to-thread communication.\n\n    This class solves the issue where context variables don't propagate\n    to OS threads created by ThreadPoolExecutor, breaking operation tracking\n    in multi-threaded applications.\n    \"\"\"\n\n    @staticmethod\n    def copy_context() -&gt; dict[contextvars.ContextVar[Any], Any]:\n        \"\"\"Copy current context variables to a dict for thread transport.\n\n        Returns:\n            Dictionary mapping context variables to their current values\n        \"\"\"\n        ctx = contextvars.copy_context()\n        return dict(ctx)\n\n    @staticmethod\n    def restore_context(context_dict: dict[contextvars.ContextVar[Any], Any]) -&gt; None:\n        \"\"\"Restore context variables from a dictionary.\n\n        Args:\n            context_dict: Dictionary mapping context variables to values\n        \"\"\"\n        for var, value in context_dict.items():\n            var.set(value)\n\n    @staticmethod\n    async def run_in_thread_with_context(\n        func: Callable[..., T], *args: Any, executor: ThreadPoolExecutor | None = None, **kwargs: Any\n    ) -&gt; T:\n        \"\"\"Run function in thread with context variables propagated.\n\n        This method safely copies context variables to the thread, runs the\n        function, and returns the result.\n\n        Args:\n            func: Function to run in thread\n            *args: Positional arguments for func\n            executor: Optional thread pool executor (default: None for default executor)\n            **kwargs: Keyword arguments for func\n\n        Returns:\n            Result of func execution\n\n        Example:\n            ```python\n            async def async_func():\n                result = await ContextBridge.run_in_thread_with_context(\n                    expensive_computation, data, param=value\n                )\n                return result\n            ```\n        \"\"\"\n        # Copy current context\n        ctx = ContextBridge.copy_context()\n\n        def thread_func():\n            # Restore context in thread\n            ContextBridge.restore_context(ctx)\n            return func(*args, **kwargs)\n\n        # Run in thread\n        loop = asyncio.get_event_loop()\n        return await loop.run_in_executor(executor, thread_func)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.context_bridge.ContextBridge.copy_context","title":"copy_context  <code>staticmethod</code>","text":"<pre><code>copy_context() -&gt; dict[ContextVar[Any], Any]\n</code></pre> <p>Copy current context variables to a dict for thread transport.</p> <p>Returns:</p> Type Description <code>dict[ContextVar[Any], Any]</code> <p>Dictionary mapping context variables to their current values</p> Source code in <code>src/hother/cancelable/utils/context_bridge.py</code> <pre><code>@staticmethod\ndef copy_context() -&gt; dict[contextvars.ContextVar[Any], Any]:\n    \"\"\"Copy current context variables to a dict for thread transport.\n\n    Returns:\n        Dictionary mapping context variables to their current values\n    \"\"\"\n    ctx = contextvars.copy_context()\n    return dict(ctx)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.context_bridge.ContextBridge.restore_context","title":"restore_context  <code>staticmethod</code>","text":"<pre><code>restore_context(\n    context_dict: dict[ContextVar[Any], Any],\n) -&gt; None\n</code></pre> <p>Restore context variables from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>context_dict</code> <code>dict[ContextVar[Any], Any]</code> <p>Dictionary mapping context variables to values</p> required Source code in <code>src/hother/cancelable/utils/context_bridge.py</code> <pre><code>@staticmethod\ndef restore_context(context_dict: dict[contextvars.ContextVar[Any], Any]) -&gt; None:\n    \"\"\"Restore context variables from a dictionary.\n\n    Args:\n        context_dict: Dictionary mapping context variables to values\n    \"\"\"\n    for var, value in context_dict.items():\n        var.set(value)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.context_bridge.ContextBridge.run_in_thread_with_context","title":"run_in_thread_with_context  <code>async</code> <code>staticmethod</code>","text":"<pre><code>run_in_thread_with_context(\n    func: Callable[..., T],\n    *args: Any,\n    executor: ThreadPoolExecutor | None = None,\n    **kwargs: Any,\n) -&gt; T\n</code></pre> <p>Run function in thread with context variables propagated.</p> <p>This method safely copies context variables to the thread, runs the function, and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., T]</code> <p>Function to run in thread</p> required <code>*args</code> <code>Any</code> <p>Positional arguments for func</p> <code>()</code> <code>executor</code> <code>ThreadPoolExecutor | None</code> <p>Optional thread pool executor (default: None for default executor)</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for func</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>Result of func execution</p> Example <pre><code>async def async_func():\n    result = await ContextBridge.run_in_thread_with_context(\n        expensive_computation, data, param=value\n    )\n    return result\n</code></pre> Source code in <code>src/hother/cancelable/utils/context_bridge.py</code> <pre><code>@staticmethod\nasync def run_in_thread_with_context(\n    func: Callable[..., T], *args: Any, executor: ThreadPoolExecutor | None = None, **kwargs: Any\n) -&gt; T:\n    \"\"\"Run function in thread with context variables propagated.\n\n    This method safely copies context variables to the thread, runs the\n    function, and returns the result.\n\n    Args:\n        func: Function to run in thread\n        *args: Positional arguments for func\n        executor: Optional thread pool executor (default: None for default executor)\n        **kwargs: Keyword arguments for func\n\n    Returns:\n        Result of func execution\n\n    Example:\n        ```python\n        async def async_func():\n            result = await ContextBridge.run_in_thread_with_context(\n                expensive_computation, data, param=value\n            )\n            return result\n        ```\n    \"\"\"\n    # Copy current context\n    ctx = ContextBridge.copy_context()\n\n    def thread_func():\n        # Restore context in thread\n        ContextBridge.restore_context(ctx)\n        return func(*args, **kwargs)\n\n    # Run in thread\n    loop = asyncio.get_event_loop()\n    return await loop.run_in_executor(executor, thread_func)\n</code></pre>"},{"location":"reference/utilities/#stream-processing","title":"Stream Processing","text":"<p>Utilities for cancelable async stream processing.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.streams","title":"hother.cancelable.utils.streams","text":"<p>Stream utilities for async cancelation.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.streams.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = get_logger(__name__)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.streams.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.streams.CancelableAsyncIterator","title":"CancelableAsyncIterator","text":"<p>               Bases: <code>AsyncIterator[T]</code></p> <p>Wrapper class that makes any async iterator cancelable.</p> <p>This provides a class-based alternative to the cancelable_stream function.</p> Source code in <code>src/hother/cancelable/utils/streams.py</code> <pre><code>class CancelableAsyncIterator(AsyncIterator[T]):\n    \"\"\"Wrapper class that makes any async iterator cancelable.\n\n    This provides a class-based alternative to the cancelable_stream function.\n    \"\"\"\n\n    def __init__(\n        self,\n        iterator: AsyncIterator[T],\n        cancelable: Cancelable,\n        report_interval: int | None = None,\n        buffer_partial: bool = False,\n    ):\n        \"\"\"Initialize cancelable iterator.\n\n        Args:\n            iterator: Async iterator to wrap\n            cancelable: Cancelable instance to use\n            report_interval: Report progress every N items\n            buffer_partial: Whether to buffer items\n        \"\"\"\n        self._iterator: AsyncIterator[T] = iterator\n        self._cancellable: Cancelable = cancelable\n        self._report_interval = report_interval\n        self._buffer_partial = buffer_partial\n        self._count = 0\n        self._buffer: list[T] | None = [] if buffer_partial else None\n        self._stream_iter = None\n        self._completed = False\n\n    def __aiter__(self) -&gt; \"CancelableAsyncIterator[T]\":\n        \"\"\"Return self as async iterator.\"\"\"\n        return self\n\n    async def __anext__(self) -&gt; T:\n        \"\"\"Get next item with cancelation checking.\"\"\"\n        # Check cancelation\n        await self._cancellable.token.check_async()\n\n        try:\n            # Get next item\n            item = await self._iterator.__anext__()\n\n            # Update count and buffer\n            self._count += 1\n            if self._buffer is not None:\n                self._buffer.append(item)\n                if len(self._buffer) &gt; _MAX_BUFFER_SIZE:\n                    self._buffer = self._buffer[-_MAX_BUFFER_SIZE:]\n\n            # Report progress if needed\n            if self._report_interval and self._count % self._report_interval == 0:\n                await self._cancellable.report_progress(\n                    f\"Processed {self._count} items\", {\"count\": self._count, \"latest_item\": item}\n                )\n\n            return item\n\n        except StopAsyncIteration:\n            # Stream ended normally\n            self._completed = True\n            if self._buffer is not None:\n                self._cancellable.context.partial_result = {\n                    \"count\": self._count,\n                    \"buffer\": self._buffer,\n                    \"completed\": True,\n                }\n            raise\n\n        except anyio.get_cancelled_exc_class():\n            # Cancelled\n            if self._buffer is not None:\n                self._cancellable.context.partial_result = {\n                    \"count\": self._count,\n                    \"buffer\": self._buffer,\n                    \"completed\": False,\n                }\n            raise\n\n        except Exception:  # Intentionally broad to save partial results on any error\n            # Error\n            if self._buffer is not None:\n                self._cancellable.context.partial_result = {\n                    \"count\": self._count,\n                    \"buffer\": self._buffer,\n                    \"completed\": False,\n                }\n            raise\n\n    async def aclose(self) -&gt; None:\n        \"\"\"Close the iterator.\"\"\"\n        if hasattr(self._iterator, \"aclose\"):\n            await self._iterator.aclose()  # type: ignore[union-attr]\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.streams.CancelableAsyncIterator.aclose","title":"aclose  <code>async</code>","text":"<pre><code>aclose() -&gt; None\n</code></pre> <p>Close the iterator.</p> Source code in <code>src/hother/cancelable/utils/streams.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Close the iterator.\"\"\"\n    if hasattr(self._iterator, \"aclose\"):\n        await self._iterator.aclose()  # type: ignore[union-attr]\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.streams.cancelable_stream","title":"cancelable_stream  <code>async</code>","text":"<pre><code>cancelable_stream(\n    stream: AsyncIterator[T],\n    timeout: float | timedelta | None = None,\n    token: Optional[CancelationToken] = None,\n    report_interval: int | None = None,\n    on_progress: Callable[[int, T], Any] | None = None,\n    buffer_partial: bool = False,\n    operation_id: str | None = None,\n    name: str | None = None,\n) -&gt; AsyncIterator[T]\n</code></pre> <p>Make any async iterator cancelable with various options.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>AsyncIterator[T]</code> <p>Async iterator to wrap</p> required <code>timeout</code> <code>float | timedelta | None</code> <p>Optional timeout for the entire stream</p> <code>None</code> <code>token</code> <code>Optional[CancelationToken]</code> <p>Optional cancelation token</p> <code>None</code> <code>report_interval</code> <code>int | None</code> <p>Report progress every N items</p> <code>None</code> <code>on_progress</code> <code>Callable[[int, T], Any] | None</code> <p>Optional progress callback (item_count, latest_item)</p> <code>None</code> <code>buffer_partial</code> <code>bool</code> <p>Whether to buffer items for partial results</p> <code>False</code> <code>operation_id</code> <code>str | None</code> <p>Optional operation ID</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional operation name</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[T]</code> <p>Items from the wrapped stream</p> Example <p>async for item in cancelable_stream(     fetch_items(),     timeout=30.0,     report_interval=100,     on_progress=lambda n, item: print(f\"Processed {n} items\") ):     process(item)</p> Source code in <code>src/hother/cancelable/utils/streams.py</code> <pre><code>async def cancelable_stream(\n    stream: AsyncIterator[T],\n    timeout: float | timedelta | None = None,\n    token: Optional[\"CancelationToken\"] = None,\n    report_interval: int | None = None,\n    on_progress: Callable[[int, T], Any] | None = None,\n    buffer_partial: bool = False,\n    operation_id: str | None = None,\n    name: str | None = None,\n) -&gt; AsyncIterator[T]:\n    \"\"\"Make any async iterator cancelable with various options.\n\n    Args:\n        stream: Async iterator to wrap\n        timeout: Optional timeout for the entire stream\n        token: Optional cancelation token\n        report_interval: Report progress every N items\n        on_progress: Optional progress callback (item_count, latest_item)\n        buffer_partial: Whether to buffer items for partial results\n        operation_id: Optional operation ID\n        name: Optional operation name\n\n    Yields:\n        Items from the wrapped stream\n\n    Example:\n        async for item in cancelable_stream(\n            fetch_items(),\n            timeout=30.0,\n            report_interval=100,\n            on_progress=lambda n, item: print(f\"Processed {n} items\")\n        ):\n            process(item)\n    \"\"\"\n    # Create appropriate cancelable\n    if timeout and token:\n        cancelable = Cancelable.with_timeout(timeout, operation_id=operation_id, name=name).combine(\n            Cancelable.with_token(token)\n        )\n    elif timeout:\n        cancelable = Cancelable.with_timeout(\n            timeout,\n            operation_id=operation_id,\n            name=name or \"stream_timeout\",\n        )\n    elif token:\n        cancelable = Cancelable.with_token(\n            token,\n            operation_id=operation_id,\n            name=name or \"stream_token\",\n        )\n    else:\n        cancelable = Cancelable(\n            operation_id=operation_id,\n            name=name or \"stream\",\n        )\n\n    # Add progress callback if provided\n    if on_progress:\n\n        async def report_wrapper(op_id: str, msg: Any, meta: dict[str, Any] | None):\n            if meta and \"count\" in meta and \"latest_item\" in meta:\n                result = on_progress(meta[\"count\"], meta[\"latest_item\"])\n                if hasattr(result, \"__await__\"):\n                    await result\n\n        cancelable.on_progress(report_wrapper)\n\n    # Process stream\n    async with cancelable:\n        async for item in cancelable.stream(\n            stream,\n            report_interval=report_interval,\n            buffer_partial=buffer_partial,\n        ):\n            yield item\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.streams.chunked_cancelable_stream","title":"chunked_cancelable_stream  <code>async</code>","text":"<pre><code>chunked_cancelable_stream(\n    stream: AsyncIterator[T],\n    chunk_size: int,\n    cancelable: Cancelable,\n) -&gt; AsyncIterator[list[T]]\n</code></pre> <p>Process stream in chunks with cancelation support.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>AsyncIterator[T]</code> <p>Source async iterator</p> required <code>chunk_size</code> <code>int</code> <p>Size of chunks to yield</p> required <code>cancelable</code> <code>Cancelable</code> <p>Cancelable instance</p> required <p>Yields:</p> Type Description <code>AsyncIterator[list[T]]</code> <p>Lists of items (chunks)</p> Example <p>async for chunk in chunked_cancelable_stream(items, 100, cancel):     await process_batch(chunk)</p> Source code in <code>src/hother/cancelable/utils/streams.py</code> <pre><code>async def chunked_cancelable_stream(\n    stream: AsyncIterator[T],\n    chunk_size: int,\n    cancelable: Cancelable,\n) -&gt; AsyncIterator[list[T]]:\n    \"\"\"Process stream in chunks with cancelation support.\n\n    Args:\n        stream: Source async iterator\n        chunk_size: Size of chunks to yield\n        cancelable: Cancelable instance\n\n    Yields:\n        Lists of items (chunks)\n\n    Example:\n        async for chunk in chunked_cancelable_stream(items, 100, cancel):\n            await process_batch(chunk)\n    \"\"\"\n    chunk: list[T] = []\n\n    async for item in cancelable.stream(stream):\n        chunk.append(item)\n\n        if len(chunk) &gt;= chunk_size:\n            yield chunk\n            chunk = []\n\n            # Report progress\n            await cancelable.report_progress(f\"Processed chunk of {chunk_size} items\")\n\n    # Yield remaining items\n    if chunk:\n        yield chunk\n        await cancelable.report_progress(f\"Processed final chunk of {len(chunk)} items\")\n</code></pre>"},{"location":"reference/utilities/#streaming-simulator","title":"Streaming Simulator","text":"<p>Stream cancellation simulator for testing and demonstration.</p>"},{"location":"reference/utilities/#hother.cancelable.streaming.simulator.simulator","title":"hother.cancelable.streaming.simulator.simulator","text":"<p>Core stream simulation functionality.</p>"},{"location":"reference/utilities/#hother.cancelable.streaming.simulator.simulator.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.streaming.simulator.simulator.simulate_stream","title":"simulate_stream  <code>async</code>","text":"<pre><code>simulate_stream(\n    text: str,\n    config: StreamConfig | None = None,\n    cancelable: Cancelable | None = None,\n) -&gt; AsyncGenerator[dict[str, Any]]\n</code></pre> <p>Simulate a realistic network stream with variable timing and cancellation support.</p> <p>This function simulates network streaming behavior including bursts, stalls, jitter, and variable chunk sizes. It's useful for testing cancellable stream processing and demonstrating async cancellation patterns.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text content to stream</p> required <code>config</code> <code>StreamConfig | None</code> <p>Optional StreamConfig to control simulation behavior. If None, uses default configuration.</p> <code>None</code> <code>cancelable</code> <code>Cancelable | None</code> <p>Optional Cancelable instance for cancellation support. If provided, the stream will check for cancellation and report progress.</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncGenerator[dict[str, Any]]</code> <p>Dictionary chunks with the following types:</p> <code>AsyncGenerator[dict[str, Any]]</code> <ul> <li>{\"type\": \"data\", \"chunk\": str, \"chunk_size\": int, ...} - Data chunks</li> </ul> <code>AsyncGenerator[dict[str, Any]]</code> <ul> <li>{\"type\": \"stall\", \"duration\": float, ...} - Network stalls</li> </ul> <code>AsyncGenerator[dict[str, Any]]</code> <ul> <li>{\"type\": \"complete\", \"total_chunks\": int, ...} - Stream completion</li> </ul> <p>Raises:</p> Type Description <code>CancelledError</code> <p>If the associated Cancelable is cancelled during streaming</p> Example <pre><code>async with Cancelable.with_timeout(5.0) as cancel:\n    config = StreamConfig(base_delay=0.1, stall_probability=0.1)\n\n    async for event in simulate_stream(\"Hello world\", config, cancel):\n        if event[\"type\"] == \"data\":\n            print(event[\"chunk\"], end=\"\", flush=True)\n</code></pre> Source code in <code>src/hother/cancelable/streaming/simulator/simulator.py</code> <pre><code>async def simulate_stream(\n    text: str, config: StreamConfig | None = None, cancelable: Cancelable | None = None\n) -&gt; AsyncGenerator[dict[str, Any]]:\n    \"\"\"Simulate a realistic network stream with variable timing and cancellation support.\n\n    This function simulates network streaming behavior including bursts, stalls,\n    jitter, and variable chunk sizes. It's useful for testing cancellable stream\n    processing and demonstrating async cancellation patterns.\n\n    Args:\n        text: The text content to stream\n        config: Optional StreamConfig to control simulation behavior.\n            If None, uses default configuration.\n        cancelable: Optional Cancelable instance for cancellation support.\n            If provided, the stream will check for cancellation and report progress.\n\n    Yields:\n        Dictionary chunks with the following types:\n        - {\"type\": \"data\", \"chunk\": str, \"chunk_size\": int, ...} - Data chunks\n        - {\"type\": \"stall\", \"duration\": float, ...} - Network stalls\n        - {\"type\": \"complete\", \"total_chunks\": int, ...} - Stream completion\n\n    Raises:\n        CancelledError: If the associated Cancelable is cancelled during streaming\n\n    Example:\n        ```python\n        async with Cancelable.with_timeout(5.0) as cancel:\n            config = StreamConfig(base_delay=0.1, stall_probability=0.1)\n\n            async for event in simulate_stream(\"Hello world\", config, cancel):\n                if event[\"type\"] == \"data\":\n                    print(event[\"chunk\"], end=\"\", flush=True)\n        ```\n    \"\"\"\n    if config is None:\n        config = StreamConfig()\n\n    start_time = time.time()\n    chunk_count = 0\n\n    i = 0\n    while i &lt; len(text):\n        # Check for cancelation\n        if cancelable:\n            await cancelable.token.check_async()\n\n        if random.random() &lt; config.stall_probability:\n            await anyio.sleep(config.stall_duration)\n\n            if cancelable:\n                await cancelable.report_progress(\n                    f\"Network stall: {config.stall_duration:.3f}s\", {\"type\": \"stall\", \"duration\": config.stall_duration}\n                )\n\n            yield {\"type\": \"stall\", \"duration\": config.stall_duration, \"timestamp\": time.time() - start_time}\n\n        if random.random() &lt; config.burst_probability:\n            for _ in range(config.burst_size):\n                if i &gt;= len(text):\n                    break\n\n                # Check for cancelation in burst\n                if cancelable:\n                    await cancelable.token.check_async()\n\n                chunk_size = get_random_chunk_size(config)\n                chunk = text[i : i + chunk_size]\n                i += len(chunk)\n                chunk_count += 1\n\n                yield {\n                    \"type\": \"data\",\n                    \"chunk\": chunk,\n                    \"chunk_size\": len(chunk),\n                    \"requested_chunk_size\": chunk_size,\n                    \"position\": i,\n                    \"total_length\": len(text),\n                    \"timestamp\": time.time() - start_time,\n                    \"burst\": True,\n                    \"chunk_number\": chunk_count,\n                }\n\n                await anyio.sleep(0.001)\n        else:\n            chunk_size = get_random_chunk_size(config)\n            chunk = text[i : i + chunk_size]\n            i += len(chunk)\n            chunk_count += 1\n\n            delay = config.base_delay\n            if random.random() &lt; config.jitter_probability:\n                delay += random.uniform(-config.jitter, config.jitter)\n            delay = max(0, delay)\n\n            await anyio.sleep(delay)\n\n            yield {\n                \"type\": \"data\",\n                \"chunk\": chunk,\n                \"chunk_size\": len(chunk),\n                \"requested_chunk_size\": chunk_size,\n                \"position\": i,\n                \"total_length\": len(text),\n                \"timestamp\": time.time() - start_time,\n                \"burst\": False,\n                \"chunk_number\": chunk_count,\n            }\n\n            # Report progress periodically\n            if cancelable and chunk_count % 10 == 0:\n                progress = (i / len(text)) * 100\n                await cancelable.report_progress(\n                    f\"Stream progress: {progress:.1f}%\",\n                    {\n                        \"chunks_sent\": chunk_count,\n                        \"bytes_sent\": i,\n                        \"total_bytes\": len(text),\n                        \"progress_percent\": progress,\n                    },\n                )\n\n    yield {\"type\": \"complete\", \"timestamp\": time.time() - start_time, \"total_chunks\": chunk_count}\n</code></pre>"},{"location":"reference/utilities/#logging","title":"Logging","text":"<p>Structured logging utilities for cancellation events.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.logging","title":"hother.cancelable.utils.logging","text":"<p>Logging utilities for the cancelable library.</p> <p>Following Python library best practices, this module provides logger access but does not configure logging. Applications using cancelable should configure their own logging as needed.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.logging.get_logger","title":"get_logger","text":"<pre><code>get_logger(name: str | None = None) -&gt; Logger\n</code></pre> <p>Get a standard library logger instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Logger name. If None, uses the calling module's name</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>A configured standard library logger</p> Note <p>This function does not configure logging handlers or formatters. Applications should configure logging using logging.basicConfig() or their preferred logging configuration method.</p> Example <p>In your application code: </p><pre><code>import logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\nfrom hother.cancelable.utils.logging import get_logger\nlogger = get_logger(__name__)\nlogger.info(\"Application started\")\n</code></pre><p></p> Source code in <code>src/hother/cancelable/utils/logging.py</code> <pre><code>def get_logger(name: str | None = None) -&gt; logging.Logger:\n    \"\"\"Get a standard library logger instance.\n\n    Args:\n        name: Logger name. If None, uses the calling module's name\n\n    Returns:\n        A configured standard library logger\n\n    Note:\n        This function does not configure logging handlers or formatters.\n        Applications should configure logging using logging.basicConfig()\n        or their preferred logging configuration method.\n\n    Example:\n        In your application code:\n        ```python\n        import logging\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        )\n\n        from hother.cancelable.utils.logging import get_logger\n        logger = get_logger(__name__)\n        logger.info(\"Application started\")\n        ```\n    \"\"\"\n    if name is None:\n        import inspect\n\n        frame = inspect.currentframe()\n        name = frame.f_back.f_globals.get(\"__name__\", \"cancelable\") if frame and frame.f_back else \"cancelable\"\n\n    return logging.getLogger(name)\n</code></pre>"},{"location":"reference/utilities/#testing","title":"Testing","text":"<p>Test utilities and fixtures for cancelable operations.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.testing","title":"hother.cancelable.utils.testing","text":"<p>Testing utilities for async cancelation.</p>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = get_logger(__name__)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.MockCancelationToken","title":"MockCancelationToken","text":"<p>               Bases: <code>CancelationToken</code></p> <p>Mock cancelation token for testing.</p> <p>Provides additional testing capabilities like scheduled cancelation.</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>class MockCancelationToken(CancelationToken):\n    \"\"\"Mock cancelation token for testing.\n\n    Provides additional testing capabilities like scheduled cancelation.\n    \"\"\"\n\n    # Additional fields for testing\n    cancel_history: list[dict[str, Any]] = []\n    _scheduled_cancelation: Any = PrivateAttr(default=None)\n\n    async def cancel(\n        self,\n        reason: CancelationReason = CancelationReason.MANUAL,\n        message: str | None = None,\n    ) -&gt; bool:\n        \"\"\"Cancel and record in history.\"\"\"\n        self.cancel_history.append(\n            {\n                \"time\": datetime.now(UTC),\n                \"reason\": reason,\n                \"message\": message,\n            }\n        )\n        return await super().cancel(reason, message)\n\n    async def schedule_cancel(\n        self,\n        delay: float,\n        reason: CancelationReason = CancelationReason.MANUAL,\n        message: str | None = None,\n    ) -&gt; None:\n        \"\"\"Schedule cancelation after a delay.\n\n        Args:\n            delay: Delay in seconds before cancelation\n            reason: Cancelation reason\n            message: Cancelation message\n        \"\"\"\n\n        async def delayed_cancel():\n            await anyio.sleep(delay)\n            await self.cancel(reason, message)\n\n        self._scheduled_cancelation = anyio.create_task_group()\n        await self._scheduled_cancelation.__aenter__()\n        self._scheduled_cancelation.start_soon(delayed_cancel)\n\n    def get_cancel_count(self) -&gt; int:\n        \"\"\"Get number of times cancel was called.\"\"\"\n        return len(self.cancel_history)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.MockCancelationToken.cancel_history","title":"cancel_history  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cancel_history: list[dict[str, Any]] = []\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.MockCancelationToken.cancel","title":"cancel  <code>async</code>","text":"<pre><code>cancel(\n    reason: CancelationReason = MANUAL,\n    message: str | None = None,\n) -&gt; bool\n</code></pre> <p>Cancel and record in history.</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>async def cancel(\n    self,\n    reason: CancelationReason = CancelationReason.MANUAL,\n    message: str | None = None,\n) -&gt; bool:\n    \"\"\"Cancel and record in history.\"\"\"\n    self.cancel_history.append(\n        {\n            \"time\": datetime.now(UTC),\n            \"reason\": reason,\n            \"message\": message,\n        }\n    )\n    return await super().cancel(reason, message)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.MockCancelationToken.schedule_cancel","title":"schedule_cancel  <code>async</code>","text":"<pre><code>schedule_cancel(\n    delay: float,\n    reason: CancelationReason = MANUAL,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Schedule cancelation after a delay.</p> <p>Parameters:</p> Name Type Description Default <code>delay</code> <code>float</code> <p>Delay in seconds before cancelation</p> required <code>reason</code> <code>CancelationReason</code> <p>Cancelation reason</p> <code>MANUAL</code> <code>message</code> <code>str | None</code> <p>Cancelation message</p> <code>None</code> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>async def schedule_cancel(\n    self,\n    delay: float,\n    reason: CancelationReason = CancelationReason.MANUAL,\n    message: str | None = None,\n) -&gt; None:\n    \"\"\"Schedule cancelation after a delay.\n\n    Args:\n        delay: Delay in seconds before cancelation\n        reason: Cancelation reason\n        message: Cancelation message\n    \"\"\"\n\n    async def delayed_cancel():\n        await anyio.sleep(delay)\n        await self.cancel(reason, message)\n\n    self._scheduled_cancelation = anyio.create_task_group()\n    await self._scheduled_cancelation.__aenter__()\n    self._scheduled_cancelation.start_soon(delayed_cancel)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.MockCancelationToken.get_cancel_count","title":"get_cancel_count","text":"<pre><code>get_cancel_count() -&gt; int\n</code></pre> <p>Get number of times cancel was called.</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>def get_cancel_count(self) -&gt; int:\n    \"\"\"Get number of times cancel was called.\"\"\"\n    return len(self.cancel_history)\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.OperationRecorder","title":"OperationRecorder","text":"<p>Records operation events for testing assertions.</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>class OperationRecorder:\n    \"\"\"Records operation events for testing assertions.\"\"\"\n\n    def __init__(self):\n        self.events: list[dict[str, Any]] = []\n        self.operations: dict[str, OperationContext] = {}\n        self._lock = anyio.Lock()\n\n    async def record_event(\n        self,\n        operation_id: str,\n        event_type: str,\n        data: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Record an operation event.\"\"\"\n        async with self._lock:\n            self.events.append(\n                {\n                    \"time\": datetime.now(UTC),\n                    \"operation_id\": operation_id,\n                    \"event_type\": event_type,\n                    \"data\": data or {},\n                }\n            )\n\n    def attach_to_cancellable(self, cancelable: Cancelable) -&gt; Cancelable:\n        \"\"\"Attach recorder to a cancelable to track its events.\n\n        Args:\n            cancelable: Cancelable to track\n\n        Returns:\n            The cancelable (for chaining)\n        \"\"\"\n        op_id = cancelable.context.id\n        self.operations[op_id] = cancelable.context\n\n        # Record all events\n        async def record_progress(op_id: str, msg: str, meta: dict[str, Any] | None):\n            await self.record_event(op_id, \"progress\", {\"message\": msg, \"meta\": meta})\n\n        async def record_status(ctx: OperationContext):\n            await self.record_event(ctx.id, f\"status_{ctx.status.value}\", ctx.log_context())\n\n        async def record_error(ctx: OperationContext, error: Exception):\n            await self.record_event(ctx.id, \"error\", {\"error_type\": type(error).__name__, \"error_message\": str(error)})\n\n        return (\n            cancelable.on_progress(record_progress)\n            .on_start(record_status)\n            .on_complete(record_status)\n            .on_cancel(record_status)\n            .on_error(record_error)\n        )\n\n    def get_events_for_operation(self, operation_id: str) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all events for a specific operation.\"\"\"\n        return [e for e in self.events if e[\"operation_id\"] == operation_id]\n\n    def get_events_by_type(self, event_type: str) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all events of a specific type.\"\"\"\n        return [e for e in self.events if e[\"event_type\"] == event_type]\n\n    def assert_event_occurred(\n        self,\n        operation_id: str,\n        event_type: str,\n        timeout: float = 1.0,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Assert that an event occurred (synchronous check).\n\n        Args:\n            operation_id: Operation ID to check\n            event_type: Event type to look for\n            timeout: Not used in sync version\n\n        Returns:\n            The event data\n\n        Raises:\n            AssertionError: If event not found\n        \"\"\"\n        events = [e for e in self.events if e[\"operation_id\"] == operation_id and e[\"event_type\"] == event_type]\n\n        if not events:\n            raise AssertionError(f\"Event '{event_type}' not found for operation {operation_id}\")\n\n        return events[-1]  # Return most recent\n\n    def assert_final_status(\n        self,\n        operation_id: str,\n        expected_status: OperationStatus,\n    ) -&gt; None:\n        \"\"\"Assert the final status of an operation.\n\n        Args:\n            operation_id: Operation ID to check\n            expected_status: Expected final status\n\n        Raises:\n            AssertionError: If status doesn't match\n        \"\"\"\n        if operation_id not in self.operations:\n            raise AssertionError(f\"Operation {operation_id} not found\")\n\n        actual_status = self.operations[operation_id].status\n        if actual_status != expected_status:\n            raise AssertionError(f\"Expected status {expected_status.value}, got {actual_status.value}\")\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.OperationRecorder.events","title":"events  <code>instance-attribute</code>","text":"<pre><code>events: list[dict[str, Any]] = []\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.OperationRecorder.operations","title":"operations  <code>instance-attribute</code>","text":"<pre><code>operations: dict[str, OperationContext] = {}\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.OperationRecorder.record_event","title":"record_event  <code>async</code>","text":"<pre><code>record_event(\n    operation_id: str,\n    event_type: str,\n    data: dict[str, Any] | None = None,\n) -&gt; None\n</code></pre> <p>Record an operation event.</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>async def record_event(\n    self,\n    operation_id: str,\n    event_type: str,\n    data: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Record an operation event.\"\"\"\n    async with self._lock:\n        self.events.append(\n            {\n                \"time\": datetime.now(UTC),\n                \"operation_id\": operation_id,\n                \"event_type\": event_type,\n                \"data\": data or {},\n            }\n        )\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.OperationRecorder.attach_to_cancellable","title":"attach_to_cancellable","text":"<pre><code>attach_to_cancellable(cancelable: Cancelable) -&gt; Cancelable\n</code></pre> <p>Attach recorder to a cancelable to track its events.</p> <p>Parameters:</p> Name Type Description Default <code>cancelable</code> <code>Cancelable</code> <p>Cancelable to track</p> required <p>Returns:</p> Type Description <code>Cancelable</code> <p>The cancelable (for chaining)</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>def attach_to_cancellable(self, cancelable: Cancelable) -&gt; Cancelable:\n    \"\"\"Attach recorder to a cancelable to track its events.\n\n    Args:\n        cancelable: Cancelable to track\n\n    Returns:\n        The cancelable (for chaining)\n    \"\"\"\n    op_id = cancelable.context.id\n    self.operations[op_id] = cancelable.context\n\n    # Record all events\n    async def record_progress(op_id: str, msg: str, meta: dict[str, Any] | None):\n        await self.record_event(op_id, \"progress\", {\"message\": msg, \"meta\": meta})\n\n    async def record_status(ctx: OperationContext):\n        await self.record_event(ctx.id, f\"status_{ctx.status.value}\", ctx.log_context())\n\n    async def record_error(ctx: OperationContext, error: Exception):\n        await self.record_event(ctx.id, \"error\", {\"error_type\": type(error).__name__, \"error_message\": str(error)})\n\n    return (\n        cancelable.on_progress(record_progress)\n        .on_start(record_status)\n        .on_complete(record_status)\n        .on_cancel(record_status)\n        .on_error(record_error)\n    )\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.OperationRecorder.get_events_for_operation","title":"get_events_for_operation","text":"<pre><code>get_events_for_operation(\n    operation_id: str,\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Get all events for a specific operation.</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>def get_events_for_operation(self, operation_id: str) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all events for a specific operation.\"\"\"\n    return [e for e in self.events if e[\"operation_id\"] == operation_id]\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.OperationRecorder.get_events_by_type","title":"get_events_by_type","text":"<pre><code>get_events_by_type(event_type: str) -&gt; list[dict[str, Any]]\n</code></pre> <p>Get all events of a specific type.</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>def get_events_by_type(self, event_type: str) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all events of a specific type.\"\"\"\n    return [e for e in self.events if e[\"event_type\"] == event_type]\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.OperationRecorder.assert_event_occurred","title":"assert_event_occurred","text":"<pre><code>assert_event_occurred(\n    operation_id: str, event_type: str, timeout: float = 1.0\n) -&gt; dict[str, Any]\n</code></pre> <p>Assert that an event occurred (synchronous check).</p> <p>Parameters:</p> Name Type Description Default <code>operation_id</code> <code>str</code> <p>Operation ID to check</p> required <code>event_type</code> <code>str</code> <p>Event type to look for</p> required <code>timeout</code> <code>float</code> <p>Not used in sync version</p> <code>1.0</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The event data</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If event not found</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>def assert_event_occurred(\n    self,\n    operation_id: str,\n    event_type: str,\n    timeout: float = 1.0,\n) -&gt; dict[str, Any]:\n    \"\"\"Assert that an event occurred (synchronous check).\n\n    Args:\n        operation_id: Operation ID to check\n        event_type: Event type to look for\n        timeout: Not used in sync version\n\n    Returns:\n        The event data\n\n    Raises:\n        AssertionError: If event not found\n    \"\"\"\n    events = [e for e in self.events if e[\"operation_id\"] == operation_id and e[\"event_type\"] == event_type]\n\n    if not events:\n        raise AssertionError(f\"Event '{event_type}' not found for operation {operation_id}\")\n\n    return events[-1]  # Return most recent\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.OperationRecorder.assert_final_status","title":"assert_final_status","text":"<pre><code>assert_final_status(\n    operation_id: str, expected_status: OperationStatus\n) -&gt; None\n</code></pre> <p>Assert the final status of an operation.</p> <p>Parameters:</p> Name Type Description Default <code>operation_id</code> <code>str</code> <p>Operation ID to check</p> required <code>expected_status</code> <code>OperationStatus</code> <p>Expected final status</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>If status doesn't match</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>def assert_final_status(\n    self,\n    operation_id: str,\n    expected_status: OperationStatus,\n) -&gt; None:\n    \"\"\"Assert the final status of an operation.\n\n    Args:\n        operation_id: Operation ID to check\n        expected_status: Expected final status\n\n    Raises:\n        AssertionError: If status doesn't match\n    \"\"\"\n    if operation_id not in self.operations:\n        raise AssertionError(f\"Operation {operation_id} not found\")\n\n    actual_status = self.operations[operation_id].status\n    if actual_status != expected_status:\n        raise AssertionError(f\"Expected status {expected_status.value}, got {actual_status.value}\")\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.CancelationScenario","title":"CancelationScenario","text":"<p>Test scenario builder for cancelation testing.</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>class CancelationScenario:\n    \"\"\"Test scenario builder for cancelation testing.\"\"\"\n\n    def __init__(self, name: str):\n        self.name = name\n        self.steps: list[dict[str, Any]] = []\n        self.assertions: list[dict[str, Any]] = []\n\n    def add_delay(self, duration: float) -&gt; \"CancelationScenario\":\n        \"\"\"Add a delay step.\"\"\"\n        self.steps.append({\"type\": \"delay\", \"duration\": duration})\n        return self\n\n    def add_cancelation(\n        self,\n        reason: CancelationReason = CancelationReason.MANUAL,\n        message: str | None = None,\n    ) -&gt; \"CancelationScenario\":\n        \"\"\"Add a cancelation step.\"\"\"\n        self.steps.append(\n            {\n                \"type\": \"cancel\",\n                \"reason\": reason,\n                \"message\": message,\n            }\n        )\n        return self\n\n    def add_progress_check(\n        self,\n        expected_message: str,\n        timeout: float = 1.0,\n    ) -&gt; \"CancelationScenario\":\n        \"\"\"Add assertion for progress message.\"\"\"\n        self.assertions.append(\n            {\n                \"type\": \"progress\",\n                \"message\": expected_message,\n                \"timeout\": timeout,\n            }\n        )\n        return self\n\n    def add_status_check(\n        self,\n        expected_status: OperationStatus,\n    ) -&gt; \"CancelationScenario\":\n        \"\"\"Add assertion for operation status.\"\"\"\n        self.assertions.append(\n            {\n                \"type\": \"status\",\n                \"status\": expected_status,\n            }\n        )\n        return self\n\n    async def run(\n        self,\n        operation: Callable[..., Any],\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; OperationRecorder:\n        \"\"\"Run the scenario.\n\n        Args:\n            operation: Async callable to test\n            *args: Positional arguments for operation\n            **kwargs: Keyword arguments for operation\n\n        Returns:\n            Operation recorder with results\n        \"\"\"\n        recorder = OperationRecorder()\n        token = MockCancelationToken()\n\n        # Create cancelable\n        cancelable = Cancelable.with_token(token, name=f\"scenario_{self.name}\")\n        recorder.attach_to_cancellable(cancelable)\n\n        # Schedule steps\n        async def run_steps():\n            for step in self.steps:\n                if step[\"type\"] == \"delay\":\n                    await anyio.sleep(step[\"duration\"])\n                elif step[\"type\"] == \"cancel\":\n                    await token.cancel(step[\"reason\"], step[\"message\"])\n\n        # Run operation and steps concurrently\n        async with anyio.create_task_group() as tg:\n            tg.start_soon(run_steps)\n\n            # Run operation with cancelable\n            async with cancelable:\n                try:\n                    await operation(*args, **kwargs)\n                except anyio.get_cancelled_exc_class():\n                    pass  # Expected\n\n        # Run assertions\n        for assertion in self.assertions:\n            if assertion[\"type\"] == \"progress\":\n                events = recorder.get_events_by_type(\"progress\")\n                messages = [e[\"data\"][\"message\"] for e in events]\n                if assertion[\"message\"] not in messages:\n                    raise AssertionError(f\"Expected progress message '{assertion['message']}' not found\")\n            elif assertion[\"type\"] == \"status\":\n                recorder.assert_final_status(cancelable.context.id, assertion[\"status\"])\n\n        return recorder\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.CancelationScenario.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.CancelationScenario.steps","title":"steps  <code>instance-attribute</code>","text":"<pre><code>steps: list[dict[str, Any]] = []\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.CancelationScenario.assertions","title":"assertions  <code>instance-attribute</code>","text":"<pre><code>assertions: list[dict[str, Any]] = []\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.CancelationScenario.add_delay","title":"add_delay","text":"<pre><code>add_delay(duration: float) -&gt; CancelationScenario\n</code></pre> <p>Add a delay step.</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>def add_delay(self, duration: float) -&gt; \"CancelationScenario\":\n    \"\"\"Add a delay step.\"\"\"\n    self.steps.append({\"type\": \"delay\", \"duration\": duration})\n    return self\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.CancelationScenario.add_cancelation","title":"add_cancelation","text":"<pre><code>add_cancelation(\n    reason: CancelationReason = MANUAL,\n    message: str | None = None,\n) -&gt; CancelationScenario\n</code></pre> <p>Add a cancelation step.</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>def add_cancelation(\n    self,\n    reason: CancelationReason = CancelationReason.MANUAL,\n    message: str | None = None,\n) -&gt; \"CancelationScenario\":\n    \"\"\"Add a cancelation step.\"\"\"\n    self.steps.append(\n        {\n            \"type\": \"cancel\",\n            \"reason\": reason,\n            \"message\": message,\n        }\n    )\n    return self\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.CancelationScenario.add_progress_check","title":"add_progress_check","text":"<pre><code>add_progress_check(\n    expected_message: str, timeout: float = 1.0\n) -&gt; CancelationScenario\n</code></pre> <p>Add assertion for progress message.</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>def add_progress_check(\n    self,\n    expected_message: str,\n    timeout: float = 1.0,\n) -&gt; \"CancelationScenario\":\n    \"\"\"Add assertion for progress message.\"\"\"\n    self.assertions.append(\n        {\n            \"type\": \"progress\",\n            \"message\": expected_message,\n            \"timeout\": timeout,\n        }\n    )\n    return self\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.CancelationScenario.add_status_check","title":"add_status_check","text":"<pre><code>add_status_check(\n    expected_status: OperationStatus,\n) -&gt; CancelationScenario\n</code></pre> <p>Add assertion for operation status.</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>def add_status_check(\n    self,\n    expected_status: OperationStatus,\n) -&gt; \"CancelationScenario\":\n    \"\"\"Add assertion for operation status.\"\"\"\n    self.assertions.append(\n        {\n            \"type\": \"status\",\n            \"status\": expected_status,\n        }\n    )\n    return self\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.CancelationScenario.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    operation: Callable[..., Any], *args: Any, **kwargs: Any\n) -&gt; OperationRecorder\n</code></pre> <p>Run the scenario.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>Callable[..., Any]</code> <p>Async callable to test</p> required <code>*args</code> <code>Any</code> <p>Positional arguments for operation</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for operation</p> <code>{}</code> <p>Returns:</p> Type Description <code>OperationRecorder</code> <p>Operation recorder with results</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>async def run(\n    self,\n    operation: Callable[..., Any],\n    *args: Any,\n    **kwargs: Any,\n) -&gt; OperationRecorder:\n    \"\"\"Run the scenario.\n\n    Args:\n        operation: Async callable to test\n        *args: Positional arguments for operation\n        **kwargs: Keyword arguments for operation\n\n    Returns:\n        Operation recorder with results\n    \"\"\"\n    recorder = OperationRecorder()\n    token = MockCancelationToken()\n\n    # Create cancelable\n    cancelable = Cancelable.with_token(token, name=f\"scenario_{self.name}\")\n    recorder.attach_to_cancellable(cancelable)\n\n    # Schedule steps\n    async def run_steps():\n        for step in self.steps:\n            if step[\"type\"] == \"delay\":\n                await anyio.sleep(step[\"duration\"])\n            elif step[\"type\"] == \"cancel\":\n                await token.cancel(step[\"reason\"], step[\"message\"])\n\n    # Run operation and steps concurrently\n    async with anyio.create_task_group() as tg:\n        tg.start_soon(run_steps)\n\n        # Run operation with cancelable\n        async with cancelable:\n            try:\n                await operation(*args, **kwargs)\n            except anyio.get_cancelled_exc_class():\n                pass  # Expected\n\n    # Run assertions\n    for assertion in self.assertions:\n        if assertion[\"type\"] == \"progress\":\n            events = recorder.get_events_by_type(\"progress\")\n            messages = [e[\"data\"][\"message\"] for e in events]\n            if assertion[\"message\"] not in messages:\n                raise AssertionError(f\"Expected progress message '{assertion['message']}' not found\")\n        elif assertion[\"type\"] == \"status\":\n            recorder.assert_final_status(cancelable.context.id, assertion[\"status\"])\n\n    return recorder\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.create_slow_stream","title":"create_slow_stream  <code>async</code>","text":"<pre><code>create_slow_stream(\n    items: list[T],\n    delay: float = 0.1,\n    cancelable: Cancelable | None = None,\n) -&gt; AsyncIterator[T]\n</code></pre> <p>Create a slow async stream for testing cancelation.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[T]</code> <p>Items to yield</p> required <code>delay</code> <code>float</code> <p>Delay between items (seconds)</p> <code>0.1</code> <code>cancelable</code> <code>Cancelable | None</code> <p>Optional cancelable to check</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[T]</code> <p>Items with delays</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>async def create_slow_stream(\n    items: list[T],\n    delay: float = 0.1,\n    cancelable: Cancelable | None = None,\n) -&gt; AsyncIterator[T]:\n    \"\"\"Create a slow async stream for testing cancelation.\n\n    Args:\n        items: Items to yield\n        delay: Delay between items (seconds)\n        cancelable: Optional cancelable to check\n\n    Yields:\n        Items with delays\n    \"\"\"\n    for i, item in enumerate(items):\n        if i &gt; 0:  # No delay before first item\n            await anyio.sleep(delay)\n\n        if cancelable:\n            await cancelable.token.check_async()\n\n        yield item\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.run_with_timeout_test","title":"run_with_timeout_test  <code>async</code>","text":"<pre><code>run_with_timeout_test(\n    coro: Any,\n    expected_timeout: float,\n    tolerance: float = 0.1,\n) -&gt; None\n</code></pre> <p>Test that a coroutine times out within expected duration.</p> <p>Parameters:</p> Name Type Description Default <code>coro</code> <code>Any</code> <p>Coroutine to run</p> required <code>expected_timeout</code> <code>float</code> <p>Expected timeout duration</p> required <code>tolerance</code> <code>float</code> <p>Acceptable deviation from expected timeout</p> <code>0.1</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If timeout doesn't occur or timing is wrong</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>async def run_with_timeout_test(\n    coro: Any,\n    expected_timeout: float,\n    tolerance: float = 0.1,\n) -&gt; None:\n    \"\"\"Test that a coroutine times out within expected duration.\n\n    Args:\n        coro: Coroutine to run\n        expected_timeout: Expected timeout duration\n        tolerance: Acceptable deviation from expected timeout\n\n    Raises:\n        AssertionError: If timeout doesn't occur or timing is wrong\n    \"\"\"\n    start_time = anyio.current_time()\n\n    try:\n        await coro\n        raise AssertionError(\"Expected timeout but operation completed\")\n    except (anyio.get_cancelled_exc_class(), TimeoutError):\n        # Expected cancelation\n        duration = anyio.current_time() - start_time\n\n        if abs(duration - expected_timeout) &gt; tolerance:\n            raise AssertionError(f\"Timeout occurred after {duration:.2f}s, expected {expected_timeout:.2f}s \u00b1 {tolerance:.2f}s\")\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.assert_cancelation_within","title":"assert_cancelation_within  <code>async</code>","text":"<pre><code>assert_cancelation_within(\n    min_time: float, max_time: float\n) -&gt; AsyncIterator[MockCancelationToken]\n</code></pre> <p>Context manager that asserts cancelation occurs within a time range.</p> <p>Parameters:</p> Name Type Description Default <code>min_time</code> <code>float</code> <p>Minimum time before cancelation</p> required <code>max_time</code> <code>float</code> <p>Maximum time before cancelation</p> required <p>Yields:</p> Type Description <code>AsyncIterator[MockCancelationToken]</code> <p>Mock cancelation token</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If cancelation timing is wrong</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>@asynccontextmanager\nasync def assert_cancelation_within(\n    min_time: float,\n    max_time: float,\n) -&gt; AsyncIterator[MockCancelationToken]:\n    \"\"\"Context manager that asserts cancelation occurs within a time range.\n\n    Args:\n        min_time: Minimum time before cancelation\n        max_time: Maximum time before cancelation\n\n    Yields:\n        Mock cancelation token\n\n    Raises:\n        AssertionError: If cancelation timing is wrong\n    \"\"\"\n    token = MockCancelationToken()\n    start_time = anyio.current_time()\n\n    try:\n        yield token\n    finally:\n        if token.is_cancelled:\n            duration = anyio.current_time() - start_time\n            if duration &lt; min_time:\n                raise AssertionError(f\"Cancelation occurred too early: {duration:.2f}s &lt; {min_time:.2f}s\")\n            if duration &gt; max_time:\n                raise AssertionError(f\"Cancelation occurred too late: {duration:.2f}s &gt; {max_time:.2f}s\")\n        else:\n            raise AssertionError(\"Expected cancelation but none occurred\")\n</code></pre>"},{"location":"reference/utilities/#hother.cancelable.utils.testing.sample_async_operation","title":"sample_async_operation  <code>async</code>","text":"<pre><code>sample_async_operation(\n    duration: float = 1.0,\n    cancelable: Cancelable | None = None,\n) -&gt; str\n</code></pre> <p>Sample async operation for testing.</p> Source code in <code>src/hother/cancelable/utils/testing.py</code> <pre><code>async def sample_async_operation(\n    duration: float = 1.0,\n    cancelable: Cancelable | None = None,\n) -&gt; str:\n    \"\"\"Sample async operation for testing.\"\"\"\n    if cancelable:\n        await cancelable.report_progress(\"Operation started\")\n\n    await anyio.sleep(duration / 2)\n\n    if cancelable:\n        await cancelable.report_progress(\"Operation 50% complete\")\n\n    await anyio.sleep(duration / 2)\n\n    if cancelable:\n        await cancelable.report_progress(\"Operation completed\")\n\n    return \"success\"\n</code></pre>"}]}